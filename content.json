[{"title":"博客搭建图床","date":"2025-07-29T18:59:28.000Z","path":"2025/07/30/博客搭建图床/","text":"一、使用场景图床的核心价值在于解放本地存储、提升图片管理效率、稳定支持多场景图片调用，适合有图片存储、分享、管理需求的个人用户使用。 日常点滴记录，会有一些图片存储和管理的场景。个人博客或者个人站点在访问量并发不高的情况下，使用图床来做对应的图片管理最合适不过。 当下主流的个人博客搭建基于Hexo，个人站点搭建基于Hugo，这两个框架都适合用GitHub Pages的服务器来存储和管理对应的内容，但在这个过程中，图片的管理始终是个麻烦事儿。 今天我基于个人博客的图片管理，介绍下图床的使用。 1.1 使用Hexo内置资源文件来管理博客图片Hexo支持通过资源文件夹管理图片，基于Hexo的个人博客，在创建新文章时，Hexo会自动生成同名文件夹，该文件夹中可以放入当前的文章所需使用的图片，通过Markdown的语法直接引用图片即可（注：这里引用的图片地址的路径是相对路径而非绝对路径）。 在Hexo文章撰写完成后，通过Hexo g&amp;d发布部署到远端后，图片文件会作为静态资源被部署到GitHub Pages服务器上。 此方案虽无技术难度简单易用，但是也暴露了最大的问题就是使用场景受限。 1.2 使用图床来管理博客图片图床的本质是专门用于存储、管理和分发图片文件的在线服务或系统，其核心功能是为用户提供稳定、高效的图片托管能力，并通过网络将图片资源传递给终端用户或应用场景。具备以下特性： 图片的集中存储载体 图片的高效分发枢纽 图片的资源管理工具 降低其他平台的负载常见社区比如知乎，在知乎答题时发一张图片，这张图片并非直接存在知乎的主服务器上，而是由知乎合作的图床服务存储，其他用户查看时，图片从图床的CDN节点快速加载，这就是图床作为 “存储 + 分发” 核心的体现。 二、图床搭建存储服务方案优劣势简介1、GitHub/Gitee/Coding 原理一样，都是免费通过管理项目仓库的形式来管理图片，但GitHub的国内访问网络不稳定，而国内Gitee保持还是独立运营状态，但没有多少注资，Coding已经被腾讯云收购，两者在国内作为过去移动互联网时代最好的GitHub的平替，目前都已经关闭了外链访问（如果你的代码公有库做图床会遭受封禁后转为私有库），防止用户白嫖其作为图床的能力。2、SM.MS，正常域名：https://sm.ms/，部分情况下网络限制时国内的备用域名：https://smms.app/，但很遗憾目前该服务器已经关闭用户注册功能，且无法从海鲜市场买断账号使用，本文对此方案也不过多介绍。3、七牛云、阿里云、腾讯云、百度云等云服务的对象存储的，此外基于工信部政策要求，从2018年开始阿里云、七牛云等云服务厂商，针对对象存储访问需要绑定域名（域名需要付费）并进行备案接入，此方案好处是长期稳定的对象存储及国内外合法访问都可以做到足够稳定，适合个人的海外站点素材投放，这个方案时有一定的费用成本的。 2.1 GitHub + PicGo 图床方案搭建GitHub新建图床专用项目仓库不赘述 解决GitHub访问的加速问题（使用jsdelivr解决）jsdelivr：https://www.jsdelivr.com/，为开源项目提供免费的CDN 12345678jsDelivr是一个开源公共CDN平台，专注于加速静态资源加载，提供免费全球缓存节点服务以提升网站性能。 ‌核心功能：1、‌全球缓存加速‌：通过分布式节点缓存内容，减少源服务器负载，提升访问速度。 ‌‌2、自动优化‌：支持 HTTP/2、GZIP压缩、自动启用HTTPS，优化加载效率。 ‌‌3、资源类型支持‌：涵盖JavaScript、CSS、图片等静态资源，支持npm包及GitHub 项目加速。 ‌国内使用建议：默认节点cdn.jsdelivr.net国内访问受限，建议更换为国内镜像节点（如cdn.jsdmirror.com），可显著改善加载速度。 关于图床操作客户端建议使用PicGo，开源免费，GitHub地址：https://github.com/Molunerfinn/PicGo 方案搭建核心流程1、创建图床专用项目创建项目时，项目需要设置为公开，创建完成后，需要去GitHub个人资料中心拿到settings中的Developer settings，拿到对应的Personal access token，生成的token只会在这里显示一次，所以记得单独保存下来（建议截图保存到电脑本地，后续需要调整token时可以重新生成）。 2、用jsdelivr为开源项目提供免费的CDN，目前jsdelivr使用比较简单，直接设定域名即可，设定自定义域名：https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main 注：Gitee和Coding有对外链访问封禁的风险（两者的图床搭建原理和GitHub类似，只是这两个类GitHub的代码托管服务器，在国内早些年是提供Https的外链访问的，不需要做CDN加速。） 2.2 SM.MS + PicGo 图床方案搭建SM.MS是一个免费的图片服务器，上传图片即可返回图片的网络URL，省去了用户自己搭建专门的图片存储服务器。但很遗憾目前该服务器已经关闭用户注册功能，且无法从海鲜市场买断账号来使用，本文对此方案也不过多介绍。 2.3 七牛云对象存储（域名/CDN的强制HTTPS）+ PicGo 图床方案搭建云存储+域名（CDN加速）+图片上传客户端的图床方案搭建准备 关于域名建议购买云服务商的域名服务（推荐用阿里云，域名相对齐全） 关于对象存储对象存储可在不同的云服务商处按需进行购买，七牛云针对每个用户每个月提供10GB的对象存储的额度，正常情况下，对于存储图片用于个人博客或个人静态页面的站点够用，同时七牛云提供存储对象的Http强制转成Https的服务能力，该能力可以很好的在用户访问博客时，显示加载照片内容。否则按目前网络安全的处理，Http的图片链接，不会直接被网页访问显示。 关于图床操作客户端建议使用PicGo，开源免费，GitHub地址：https://github.com/Molunerfinn/PicGo 方案搭建核心流程对象存储访问需要绑定域名并进行备案接入，该流程比较繁琐，容易出错。1、阿里云域名新增解析2、阿里云域名解析配置3、七牛云创建存储空间和文件目录注：存储区域选海外，大陆需要备案4、七牛云存储空间域名绑定 配合2中的服务商域名解析配置5、七牛云存储空间设置外链域名 七牛云免费赠送30日测试域名，可用于能力测试 设置外链域名后针对域名调整配置6、安装&amp;配置PicGo客户端安装&amp;配置PicGo客户端操作简单，但是配置时关于七牛云的配置设置需要注意，使用到七牛云的密钥管理的AccessKey/SecretKey，七牛云的AK为明文可直接复制粘贴使用，而SK为暗文，需要身份验证后成明文复制粘贴，否则无法复制成功，也会导致配置到PicGo中会配置失败，彼时上传图片时一直失败，在排查问题时，可调取PicGo的操作日志或配置文件，也能发现这个问题（AK和SK的参数value值一样） 操作日志接口返回权限有问题 配置文件中找AK和SK是否和七牛云个人账号中一致 三、图床实操本文涉及的SOP中的图片，分别是通过GitHub+PicGo和七牛云+PicGo搭建图床系统实操。 而本站点在2017年搭建之初，个人头像、文章打赏功能对应的微信支付宝二维码等基础图片，是8年前使用SM.MS的公有云图床URL链接支持的。 如果某天，你读到该文章时发现七牛云+PicGo搭建的图床对应的图片已不可见，那大概率是我忘记给七牛云的CDN流量充值付费:D。 附1、如果对于七牛云+PicGo搭建的图床流程中，依然有细节内容不清楚时，可参考视频别的UP主教程中的细节描述，这是传送门：https://www.bilibili.com/video/BV1fw411t7eU/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=ff56e624427d37d39c601ead9169687d2、图床系统本质是搭建一个畅通无阻的云存储对象上传管理及自由访问能力，在此再次强调，国内必须严格按照相关法律法规要求来落地执行这些多媒体资源的管理。","raw":"---\ntitle: 博客搭建图床\ndate: 2025-07-30 02:59:28\ncategories:\ntoc: ture\ntags:\n     - 图床\n---\n\n\n## 一、使用场景\n图床的核心价值在于解放本地存储、提升图片管理效率、稳定支持多场景图片调用，适合有图片存储、分享、管理需求的个人用户使用。\n\n日常点滴记录，会有一些图片存储和管理的场景。个人博客或者个人站点在访问量并发不高的情况下，使用图床来做对应的图片管理最合适不过。\n\n当下主流的个人博客搭建基于Hexo，个人站点搭建基于Hugo，这两个框架都适合用GitHub Pages的服务器来存储和管理对应的内容，但在这个过程中，图片的管理始终是个麻烦事儿。\n\n今天我基于个人博客的图片管理，介绍下图床的使用。\n\n#### 1.1 使用Hexo内置资源文件来管理博客图片\nHexo支持通过资源文件夹管理图片，基于Hexo的个人博客，在创建新文章时，Hexo会自动生成同名文件夹，该文件夹中可以放入当前的文章所需使用的图片，通过Markdown的语法直接引用图片即可（注：这里引用的图片地址的路径是相对路径而非绝对路径）。\n\n在Hexo文章撰写完成后，通过Hexo g&d发布部署到远端后，图片文件会作为静态资源被部署到GitHub Pages服务器上。\n\n**此方案虽无技术难度简单易用，但是也暴露了最大的问题就是使用场景受限。**\n\n#### 1.2 使用图床来管理博客图片\n图床的本质是专门用于存储、管理和分发图片文件的在线服务或系统，其核心功能是为用户提供稳定、高效的图片托管能力，并通过网络将图片资源传递给终端用户或应用场景。\n具备以下特性：\n* 图片的集中存储载体\n* 图片的高效分发枢纽\n* 图片的资源管理工具\n* 降低其他平台的负载\n常见社区比如知乎，在知乎答题时发一张图片，这张图片并非直接存在知乎的主服务器上，而是由知乎合作的图床服务存储，其他用户查看时，图片从图床的CDN节点快速加载，这就是图床作为 “存储 + 分发” 核心的体现。\n<!--more-->\n\n## 二、图床搭建\n\n###### 存储服务方案优劣势简介\n1、GitHub/Gitee/Coding 原理一样，都是免费通过管理项目仓库的形式来管理图片，但GitHub的国内访问网络不稳定，而国内Gitee保持还是独立运营状态，但没有多少注资，Coding已经被腾讯云收购，两者在国内作为过去移动互联网时代最好的GitHub的平替，目前都已经关闭了外链访问（如果你的代码公有库做图床会遭受封禁后转为私有库），防止用户白嫖其作为图床的能力。\n2、SM.MS，正常域名：[https://sm.ms/]()，部分情况下网络限制时国内的备用域名：[https://smms.app/]()，**但很遗憾目前该服务器已经关闭用户注册功能，且无法从海鲜市场买断账号使用，本文对此方案也不过多介绍**。\n3、七牛云、阿里云、腾讯云、百度云等云服务的对象存储的，此外基于工信部政策要求，从2018年开始阿里云、七牛云等云服务厂商，针对**对象存储访问需要绑定域名（域名需要付费）并进行备案接入**，此方案好处是长期稳定的对象存储及国内外合法访问都可以做到足够稳定，适合个人的海外站点素材投放，这个方案时有一定的费用成本的。\n\n### 2.1 GitHub + PicGo 图床方案搭建\n###### GitHub新建图床专用项目仓库\n不赘述\n###### 解决GitHub访问的加速问题（使用jsdelivr解决）\njsdelivr：[https://www.jsdelivr.com/]()，为开源项目提供免费的CDN\n\n```\njsDelivr是一个开源公共CDN平台，专注于加速静态资源加载，提供免费全球缓存节点服务以提升网站性能。 ‌\n核心功能：\n1、‌全球缓存加速‌：通过分布式节点缓存内容，减少源服务器负载，提升访问速度。 ‌\n‌2、自动优化‌：支持 HTTP/2、GZIP压缩、自动启用HTTPS，优化加载效率。 ‌\n‌3、资源类型支持‌：涵盖JavaScript、CSS、图片等静态资源，支持npm包及GitHub 项目加速。 ‌\n国内使用建议：\n默认节点cdn.jsdelivr.net国内访问受限，建议更换为国内镜像节点（如cdn.jsdmirror.com），可显著改善加载速度。\n\n```\n###### 关于图床操作客户端\n建议使用PicGo，开源免费，GitHub地址：[https://github.com/Molunerfinn/PicGo]()\n\n#### 方案搭建核心流程\n1、创建图床专用项目\n创建项目时，项目需要设置为公开，创建完成后，需要去GitHub个人资料中心拿到settings中的Developer settings，拿到对应的Personal access token，生成的token只会在这里显示一次，所以记得单独保存下来（建议截图保存到电脑本地，后续需要调整token时可以重新生成）。\n\n2、用jsdelivr为开源项目提供免费的CDN，目前jsdelivr使用比较简单，直接设定域名即可，设定自定义域名：https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main\n![](https://cdn.jsdelivr.net/gh/YanCeyMichael/imagesforblogs@main/images/20250801033817035.png)\n\n**注：Gitee和Coding有对外链访问封禁的风险（两者的图床搭建原理和GitHub类似，只是这两个类GitHub的代码托管服务器，在国内早些年是提供Https的外链访问的，不需要做CDN加速。）**\n\n### 2.2 SM.MS + PicGo 图床方案搭建\nSM.MS是一个免费的图片服务器，上传图片即可返回图片的网络URL，省去了用户自己搭建专门的图片存储服务器。**但很遗憾目前该服务器已经关闭用户注册功能，且无法从海鲜市场买断账号来使用，本文对此方案也不过多介绍。**\n\n### 2.3 七牛云对象存储（域名/CDN的强制HTTPS）+ PicGo 图床方案搭建\n云存储+域名（CDN加速）+图片上传客户端的图床方案搭建准备\n###### 关于域名\n建议购买云服务商的域名服务（推荐用阿里云，域名相对齐全）\n###### 关于对象存储\n对象存储可在不同的云服务商处按需进行购买，七牛云针对每个用户每个月提供10GB的对象存储的额度，正常情况下，对于存储图片用于个人博客或个人静态页面的站点够用，同时七牛云提供存储对象的Http强制转成Https的服务能力，该能力可以很好的在用户访问博客时，显示加载照片内容。否则按目前网络安全的处理，Http的图片链接，不会直接被网页访问显示。\n###### 关于图床操作客户端\n建议使用PicGo，开源免费，[GitHub地址：https://github.com/Molunerfinn/PicGo]()\n\n#### 方案搭建核心流程\n对象存储访问需要绑定域名并进行备案接入，该流程比较繁琐，容易出错。\n1、阿里云域名新增解析\n![阿里云域名新增解析](http://imagehostingservice.yanceymichael.com/images/20250730044739439.png)\n2、阿里云域名解析配置\n![阿里云域名解析的记录值配置](http://imagehostingservice.yanceymichael.com/images/20250730045545667.png)\n3、七牛云创建存储空间和文件目录\n注：存储区域选海外，大陆需要备案\n![七牛云新增OSS存储空间和文件路径](http://imagehostingservice.yanceymichael.com/images/20250730045737174.png)\n4、七牛云存储空间域名绑定\n* 配合2中的服务商域名解析配置\n![七牛云域名绑定](http://imagehostingservice.yanceymichael.com/images/20250730045952810.png)\n5、七牛云存储空间设置外链域名\n* 七牛云免费赠送30日测试域名，可用于能力测试\n![存储空间设置外链域名](http://imagehostingservice.yanceymichael.com/images/20250730050305799.png)\n* 设置外链域名后针对域名调整配置\n![设置外链域名后针对域名调整配置](http://imagehostingservice.yanceymichael.com/images/20250731021756691.png)\n![Http强制转成Https的服务能力](http://imagehostingservice.yanceymichael.com/images/20250731085327993.png)\n6、安装&配置PicGo客户端\n安装&配置PicGo客户端操作简单，但是配置时关于七牛云的配置设置需要注意，使用到七牛云的密钥管理的AccessKey/SecretKey，七牛云的AK为明文可直接复制粘贴使用，而SK为暗文，需要身份验证后成明文复制粘贴，否则无法复制成功，也会导致配置到PicGo中会配置失败，彼时上传图片时一直失败，在排查问题时，可调取PicGo的操作日志或配置文件，也能发现这个问题（AK和SK的参数value值一样）\n* 操作日志接口返回权限有问题\n![操作日志接口返回权限有问题](http://imagehostingservice.yanceymichael.com/images/20250730051224384.png)\n* 配置文件中找AK和SK是否和七牛云个人账号中一致\n![配置文件中找AK和SK是否和七牛云个人账号中一致](http://imagehostingservice.yanceymichael.com/images/20250730051707673.png)\n\n## 三、图床实操\n本文涉及的SOP中的图片，分别是通过GitHub+PicGo和七牛云+PicGo搭建图床系统实操。\n\n而本站点在2017年搭建之初，个人头像、文章打赏功能对应的微信支付宝二维码等基础图片，是8年前使用SM.MS的公有云图床URL链接支持的。\n\n如果某天，你读到该文章时发现七牛云+PicGo搭建的图床对应的图片已不可见，那大概率是我忘记给七牛云的CDN流量充值付费:D。\n\n## 附\n1、如果对于七牛云+PicGo搭建的图床流程中，依然有细节内容不清楚时，可参考视频别的UP主教程中的细节描述，这是传送门：[https://www.bilibili.com/video/BV1fw411t7eU/?spm_id_from=333.1387.favlist.content.click&vd_source=ff56e624427d37d39c601ead9169687d]()\n2、图床系统本质是搭建一个畅通无阻的云存储对象上传管理及自由访问能力，在此再次强调，国内必须严格按照相关法律法规要求来落地执行这些多媒体资源的管理。\n\n\n\n\n\n","updated":"2025-07-31T21:03:08.955Z","permalink":"http://yoursite.com/2025/07/30/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","categories":[]},{"title":"帆船博弈论的应用","date":"2021-11-21T15:13:12.000Z","path":"2021/11/21/帆船博弈论的应用/","text":"帆船博弈论模型：1986年，美洲杯帆船比赛，美国和澳大利亚进行帆船比赛，往年都是澳大利亚获胜，美国为了这次比赛，做了很多的努力，改进技术，换老船长上前指挥等等。果然，这一次，美国队一路领先，径直向前。在离终点还有3海里的时候美国队领先澳大利亚队4海里。眼看着马上要胜利了，这个时候海上刮起了一阵大风。帆船是要根据风的方向调节帆的方向才能前进的。海上的风有两种，一种是阵风，一种是旋风。阵风过来的时候调帆，旋风不用调帆，因为旋风会使帆刮过来再刮过去，调了也白调。这个时候怎么办呢？是调帆还是不调？老船长根据自己多年的经验，说这是阵风，于是调帆。但是等帆调整好以后，风向又变了，这是一种阵风式的旋风。于是美国队的帆船在原地打转，浪费了很多时间。这个时候澳大利亚队的帆船赶上来了。澳大利亚队没有调帆，一路向前，超过了美国队。当美国队离终点还有两海里的时候澳大利亚队到达了重点。美国队船员这个时候抱头痛哭，精疲力尽，伤心地不想上岸。 结论：帆船博弈中，当领先对手的时候，不管风向和外部环境怎样，只要跟着后面的对手操作就行了。对手调帆我也调帆，对手不调我也不调，对手往哪个方向调帆我也往哪个方向调帆。这样，不管是前进还是后退还是原地打转，都永远领先4海里。所以这是领导者的指挥问题，跟外部环境没关系。","raw":"---\ntitle: 帆船博弈论的应用\ndate: 2021-11-21 23:13:12\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n帆船博弈论模型：1986年，美洲杯帆船比赛，美国和澳大利亚进行帆船比赛，往年都是澳大利亚获胜，美国为了这次比赛，做了很多的努力，改进技术，换老船长上前指挥等等。果然，这一次，美国队一路领先，径直向前。在离终点还有3海里的时候美国队领先澳大利亚队4海里。眼看着马上要胜利了，这个时候海上刮起了一阵大风。帆船是要根据风的方向调节帆的方向才能前进的。海上的风有两种，一种是阵风，一种是旋风。阵风过来的时候调帆，旋风不用调帆，因为旋风会使帆刮过来再刮过去，调了也白调。这个时候怎么办呢？是调帆还是不调？老船长根据自己多年的经验，说这是阵风，于是调帆。但是等帆调整好以后，风向又变了，这是一种阵风式的旋风。于是美国队的帆船在原地打转，浪费了很多时间。这个时候澳大利亚队的帆船赶上来了。澳大利亚队没有调帆，一路向前，超过了美国队。当美国队离终点还有两海里的时候澳大利亚队到达了重点。美国队船员这个时候抱头痛哭，精疲力尽，伤心地不想上岸。\n\n结论：帆船博弈中，当领先对手的时候，不管风向和外部环境怎样，只要跟着后面的对手操作就行了。对手调帆我也调帆，对手不调我也不调，对手往哪个方向调帆我也往哪个方向调帆。这样，不管是前进还是后退还是原地打转，都永远领先4海里。所以这是领导者的指挥问题，跟外部环境没关系。\n\n\n","updated":"2021-11-21T15:17:10.433Z","permalink":"http://yoursite.com/2021/11/21/%E5%B8%86%E8%88%B9%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%9A%84%E5%BA%94%E7%94%A8/","categories":[]},{"title":"公羊博弈论模型及三个推论","date":"2021-11-21T13:20:29.000Z","path":"2021/11/21/公羊博弈论模型及三个推论/","text":"公羊博弈论模型：当一只红羊和一只黑羊同时从独木桥的两端过独木桥，桥面只能同一时刻容纳一只羊通过，桥下是万丈深渊，如果两只羊都不让道，最后会因体力不支摔死。同归于尽还是某只羊放下身段让道，给双方都活下去的机会？ 由羊的幸福本性出发，如果红羊家财万贯生活美满，黑羊病魔缠身濒临死亡，谁会优先让道？ 幸福的一方会优先让道。 由幸福让的逻辑可以得到三个推论：1、幸福感能降低斗争性2、为小事争执的人生活质量低3、展示自己的艰辛和不容易，别人更容易为你让路","raw":"---\ntitle: 公羊博弈论模型及三个推论\ndate: 2021-11-21 21:20:29\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n公羊博弈论模型：当一只红羊和一只黑羊同时从独木桥的两端过独木桥，桥面只能同一时刻容纳一只羊通过，桥下是万丈深渊，如果两只羊都不让道，最后会因体力不支摔死。同归于尽还是某只羊放下身段让道，给双方都活下去的机会？\n\n\n由羊的幸福本性出发，如果红羊家财万贯生活美满，黑羊病魔缠身濒临死亡，谁会优先让道？\n\n幸福的一方会优先让道。\n\n由幸福让的逻辑可以得到三个推论：\n1、幸福感能降低斗争性\n2、为小事争执的人生活质量低\n3、展示自己的艰辛和不容易，别人更容易为你让路\n\n","updated":"2022-02-07T18:33:04.337Z","permalink":"http://yoursite.com/2021/11/21/%E5%85%AC%E7%BE%8A%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%B8%89%E4%B8%AA%E6%8E%A8%E8%AE%BA/","categories":[]},{"title":"关于人性的几个小故事","date":"2021-06-21T17:54:32.000Z","path":"2021/06/22/关于人性的几个小故事/","text":"以下四个故事，有一些关于人性思考的新的视角。 一一个孩子要天上的月亮就是可爱，要父母买不起的玩具就是不懂事。 1同样是得不到，人们往往会美化绝对得不到，刻意抹黑有可能得到。 二我说钱不是万能的，我爸拍出一叠钞票说：如果你改口，这钱就是你的。我正在犹豫，我妈一把把钱抢过去对我爸说：给他钱你就上当了。 1真正的既得利益者，从不屑参与观点之争。 三我有个发小，他长得没我帅，学习成绩没我好，家庭条件也不如我，从初中到高中，他追了两位数以上的姑娘，但从来没有人说他花心，反倒都说他是个好人。而我因为被两位数以上姑娘喜欢，就背上了滥情、下流的骂名。 1遭人妒忌的，除了你真正拥有的，还有你理论上可以拥有的。 四上一个故事中的我和发小如果用 A 和 B 代替，骂我装逼的人就会减少，夸我讲得很有道理的人就会增多。 1尽量照顾那些心理脆弱的人，你的观点看起来就会非常的客观。","raw":"---\ntitle: 关于人性的几个小故事\ndate: 2021-06-22 01:54:32\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n以下四个故事，有一些关于人性思考的新的视角。\n\n### 一\n\n一个孩子要天上的月亮就是可爱，要父母买不起的玩具就是不懂事。\n\n```\n同样是得不到，人们往往会美化绝对得不到，刻意抹黑有可能得到。\n```\n\n\n### 二\n\n我说钱不是万能的，我爸拍出一叠钞票说：如果你改口，这钱就是你的。我正在犹豫，我妈一把把钱抢过去对我爸说：给他钱你就上当了。\n\n```\n真正的既得利益者，从不屑参与观点之争。\n```\n\n### 三\n\n我有个发小，他长得没我帅，学习成绩没我好，家庭条件也不如我，从初中到高中，他追了两位数以上的姑娘，但从来没有人说他花心，反倒都说他是个好人。而我因为被两位数以上姑娘喜欢，就背上了滥情、下流的骂名。\n\n```\n遭人妒忌的，除了你真正拥有的，还有你理论上可以拥有的。\n```\n\n\n### 四\n\n上一个故事中的我和发小如果用 A 和 B 代替，骂我装逼的人就会减少，夸我讲得很有道理的人就会增多。\n\n```\n尽量照顾那些心理脆弱的人，你的观点看起来就会非常的客观。\n```\n\n\n","updated":"2021-06-21T18:35:35.120Z","permalink":"http://yoursite.com/2021/06/22/%E5%85%B3%E4%BA%8E%E4%BA%BA%E6%80%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%95%85%E4%BA%8B/","categories":[]},{"title":"夏天要来","date":"2021-06-14T17:55:44.000Z","path":"2021/06/15/夏天要来/","text":"夏天要来，我去年就知道了。 但是夏天来晚了，我今年才知道。 所以你看，并不是什么都是准确的。 但是隔壁临街的轩丽发艺剪个头发是139块，我去过，但不打算再去了。 这个才是准确的。","raw":"---\ntitle: 夏天要来\ndate: 2021-06-15 01:55:44\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n夏天要来，我去年就知道了。\n\n但是夏天来晚了，我今年才知道。\n\n所以你看，并不是什么都是准确的。\n\n但是隔壁临街的轩丽发艺剪个头发是139块，我去过，但不打算再去了。\n\n这个才是准确的。\n\n","updated":"2021-06-14T19:14:52.187Z","permalink":"http://yoursite.com/2021/06/15/%E5%A4%8F%E5%A4%A9%E8%A6%81%E6%9D%A5/","categories":[]},{"title":"自律和热爱","date":"2021-06-09T01:32:26.000Z","path":"2021/06/09/自律和热爱/","text":"身边被认为优秀的人，好似都有一个持续做一件事的状态，并可阶段性收获结果。 普通人会因为各方面因素或者其他情况未获得收获，即开始羡慕，会暗暗下一个目标，然后开始自律打卡坚持。 很少人会认认真真去思考一件事：一直能做一件事，是源自于自律还是源自于热爱？自律这件事本事是利大于弊还是弊大于利？如果不是出于热爱而想自律，是否会陷入间歇性努力，而持续性堕落的恶性循环？ 我觉得优秀的人，并不是靠着自律，每天做同一件事情，而更多是因为热爱这件事本身。 如果没有热爱，只想着自律本身，自律就变成了为了自律而自律，显得廉价，自律的动力很诡异的地方在于它是来源于持续性堕落的带来的焦虑感。 堕落的时候，让向上的人产生焦虑，想要模仿他人的努力，自律约束自己强推去执行一些事情，认为自己只要坚持也可以有同等收获，于是自律缓解了这部分焦虑，焦虑进而让你放松警惕，进而又开始新的一轮堕落。 可是热爱是小众的，不可能博爱一切，不可能对每件事都有如此的激情和动力。 有没有培养热爱的方法呢？ 好像 WOOP 思维可以做到：找到自己最真实具体的愿望（Wish），找到达成愿望后可获得的最好结果（Outcome），可以疯狂幻想，多思考可能会遇到的障碍问题（Obstacle），然后用具体的计划来执行（Plan），如果遇到了障碍，可让你有跨过障碍的执行可能性。 自律和热爱表现的如此一致，以至于都可能分不清什么时候是处于自律，什么时候会处于热爱，这是为什么呢？ 我想大概归为：自律是违背人性的，而热爱是人性本身。","raw":"---\ntitle: 自律和热爱\ndate: 2021-06-09 09:32:26\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n身边被认为优秀的人，好似都有一个持续做一件事的状态，并可阶段性收获结果。\n\n普通人会因为各方面因素或者其他情况未获得收获，即开始羡慕，会暗暗下一个目标，然后开始自律打卡坚持。\n\n很少人会认认真真去思考一件事：一直能做一件事，是源自于自律还是源自于热爱？自律这件事本事是利大于弊还是弊大于利？如果不是出于热爱而想自律，是否会陷入间歇性努力，而持续性堕落的恶性循环？\n\n<!--more-->\n\n我觉得优秀的人，并不是靠着自律，每天做同一件事情，而更多是因为热爱这件事本身。\n\n如果没有热爱，只想着自律本身，自律就变成了为了自律而自律，显得廉价，自律的动力很诡异的地方在于它是来源于持续性堕落的带来的焦虑感。\n\n堕落的时候，让向上的人产生焦虑，想要模仿他人的努力，自律约束自己强推去执行一些事情，认为自己只要坚持也可以有同等收获，于是自律缓解了这部分焦虑，焦虑进而让你放松警惕，进而又开始新的一轮堕落。\n\n可是热爱是小众的，不可能博爱一切，不可能对每件事都有如此的激情和动力。\n\n有没有培养热爱的方法呢？\n\n好像 WOOP 思维可以做到：找到自己最真实具体的愿望（Wish），找到达成愿望后可获得的最好结果（Outcome），可以疯狂幻想，多思考可能会遇到的障碍问题（Obstacle），然后用具体的计划来执行（Plan），如果遇到了障碍，可让你有跨过障碍的执行可能性。\n\n自律和热爱表现的如此一致，以至于都可能分不清什么时候是处于自律，什么时候会处于热爱，这是为什么呢？\n\n我想大概归为：自律是违背人性的，而热爱是人性本身。\n\n\n\n\n","updated":"2021-06-14T18:49:43.420Z","permalink":"http://yoursite.com/2021/06/09/%E8%87%AA%E5%BE%8B%E5%92%8C%E7%83%AD%E7%88%B1/","categories":[]},{"title":"零碎的理解","date":"2021-06-08T00:59:33.000Z","path":"2021/06/08/零碎的理解/","text":"有结果的往往是电影，无疾而终的多为人生。","raw":"---\ntitle: 零碎的理解\ndate: 2021-06-08 08:59:33\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n有结果的往往是电影，无疾而终的多为人生。\n\n\n\n\n\n\n","updated":"2021-06-09T01:33:27.255Z","permalink":"http://yoursite.com/2021/06/08/%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%90%86%E8%A7%A3/","categories":[]},{"title":"胡言乱语","date":"2021-06-06T12:01:58.000Z","path":"2021/06/06/胡言乱语/","text":"1，全身的细胞更新一个周期大概需要 7 年，黄桃罐头的保质期有 15 个月，红酒打开后 3 天内需要喝完，似乎一切都有期限，但是这些都很无趣。人们大多会喜欢一切没有规律可循的事情，可是爱这件事是可以长久不变的，即便如此爱也始终抵不过你的一句否定。 2，想把世上美好的东西全捧给你，初春沾着水珠的四瓣幸运草，漫天飞舞带着彩虹的蒲公英，无籽西瓜最甜的瓜瓤，初冬第一片六边形的雪花，抬头一望无垠深邃广袤的星河，这些都不及牵着你的手，度过余生。 3，在北京的每个日子都很普通，好像每天都有很大的风。没见到你的时候，天空不会很好看，无糖可乐也没什么味道，阳光不温不冷的盖在身上。 4，你就做你自己吧，奇怪一点也没关系，和别人不一样也没关系，只要你愿意我永远站在你这边。 5，也许爱不该只有嘴来说，用实际行动来证明，不然从满心欢喜到绝望是会耗尽人所有美好的热情。 6，在吗？不忙，你说，我在听。 7，我差不多过了想要一个东西就去买，喜欢一个人就去追的年纪，哪怕最后那个东西没有用，那个人没有和我在一起也没关系，人生苦短。 8，我向你表白，只是单纯想告诉你我的心意，你不需要有心理负担，如果你能接受，那一定是件让彼此都开心的事情；如果你拒绝了我，我也会欣然接受，毕竟每个人都有自己选择的权利。 9，我想爱具体的人，而不是抽像的人，如果不能爱具体的人，那还是不懂爱情，那是还没成熟长大。 10，明天再喜欢吧，今天喜欢了一天，太困了，晚安。","raw":"---\ntitle: 胡言乱语\ndate: 2021-06-06 20:01:58\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n1，全身的细胞更新一个周期大概需要 7 年，黄桃罐头的保质期有 15 个月，红酒打开后 3 天内需要喝完，似乎一切都有期限，但是这些都很无趣。人们大多会喜欢一切没有规律可循的事情，可是爱这件事是可以长久不变的，即便如此爱也始终抵不过你的一句否定。\n\n2，想把世上美好的东西全捧给你，初春沾着水珠的四瓣幸运草，漫天飞舞带着彩虹的蒲公英，无籽西瓜最甜的瓜瓤，初冬第一片六边形的雪花，抬头一望无垠深邃广袤的星河，这些都不及牵着你的手，度过余生。\n\n3，在北京的每个日子都很普通，好像每天都有很大的风。没见到你的时候，天空不会很好看，无糖可乐也没什么味道，阳光不温不冷的盖在身上。\n\n<!--more-->\n\n4，你就做你自己吧，奇怪一点也没关系，和别人不一样也没关系，只要你愿意我永远站在你这边。\n\n5，也许爱不该只有嘴来说，用实际行动来证明，不然从满心欢喜到绝望是会耗尽人所有美好的热情。\n\n6，在吗？不忙，你说，我在听。\n\n7，我差不多过了想要一个东西就去买，喜欢一个人就去追的年纪，哪怕最后那个东西没有用，那个人没有和我在一起也没关系，人生苦短。\n\n8，我向你表白，只是单纯想告诉你我的心意，你不需要有心理负担，如果你能接受，那一定是件让彼此都开心的事情；如果你拒绝了我，我也会欣然接受，毕竟每个人都有自己选择的权利。\n\n9，我想爱具体的人，而不是抽像的人，如果不能爱具体的人，那还是不懂爱情，那是还没成熟长大。\n\n10，明天再喜欢吧，今天喜欢了一天，太困了，晚安。\n\n","updated":"2021-06-06T13:05:04.800Z","permalink":"http://yoursite.com/2021/06/06/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/","categories":[]},{"title":"不能用力过猛","date":"2020-01-15T10:38:21.000Z","path":"2020/01/15/不能用力过猛/","text":"今天下了2020年的第二场雪。第一场雪在一周前。同样我的腿也伤了足足12天。 我的膝盖摔伤后，结痂裂开数次今天终于有所好转，今天也是第一次早上骑电驴膝盖不再有撕裂的疼痛感。 12天好漫长，疼痛感让我每时每刻都在感受时间的流逝。有人调侃我说上班太拼了，以至于把腿都摔伤了。 我太拼了吗？我扪心自问好像没有。 我一直觉得，能否做成一件事，耐心最重要，它远比热情细致专注都来的重要。只要有足够的耐心，事情终究还是会成，或早或晚。保持足够的耐心，像一头凶猛的猎豹，伺机而动，等待机会。 在守候的过程中，耐心最大的敌人就是用力过猛。人的意志精神与体力体能最大的挑战都是过度。但凡过度，都会造成不可逆的损伤。当目标聚焦于结果和全局分解的目标后，就比较清晰的明确当前自身所处的阶段，然后对所处的状态便不在过喜过悲，患得患失。同时也会有更多的耐心去继续战斗。 2018年1月份开始尝试做产品，从现阶段看来，做产品给我带来最大的好处是看事情的角度发生的变化，生活和工作也变得不再为某些东西的不顺心不如意而焦躁。那份心安理得并不是我不在乎，而是我很清楚光在乎是没用的，在乎去争取也是不一定有结果的。这跟早些年的佛系不一样，那会儿更多的佛系是放弃。而现在的佛系，是度己，放过自己。时间与资源条件的不允许，那就稍等片刻。这个片刻可以是一天，可以是一年，也可以是十年，最后熬死所有的阻碍。 所以现在最大的难点是在于目标的抉择，目标抉择看来显得特别重要。它关乎于为之一生战斗的方向。 我从不是安分的人，我想世间大体的东西都是相通的，重点在于技巧。有了技巧之后的耐心和热爱，持久的投入战斗。 人是需要有喜爱的，在解决生存之后，一定要解决喜爱。我从不奢望生存的同时可以喜爱，我觉得这本身就是一种小概率的奢侈。我现在在为生存战斗。什么时候可以喜爱呢，我好期待。唯一害怕的就是不够长命可以活到我的喜爱，生存好难。 那个我期望得到的人生呀，等等我呀，愿意以一生的耐心和热情，满怀欣喜的诚意来为你奋斗呀。","raw":"---\ntitle: 不能用力过猛\ndate: 2020-01-15 18:38:21\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n   今天下了2020年的第二场雪。第一场雪在一周前。同样我的腿也伤了足足12天。\n   \n   我的膝盖摔伤后，结痂裂开数次今天终于有所好转，今天也是第一次早上骑电驴膝盖不再有撕裂的疼痛感。\n   \n   12天好漫长，疼痛感让我每时每刻都在感受时间的流逝。有人调侃我说上班太拼了，以至于把腿都摔伤了。\n   \n   我太拼了吗？我扪心自问好像没有。\n   \n   <!--more-->\n   \n   我一直觉得，能否做成一件事，耐心最重要，它远比热情细致专注都来的重要。只要有足够的耐心，事情终究还是会成，或早或晚。保持足够的耐心，像一头凶猛的猎豹，伺机而动，等待机会。\n   \n   在守候的过程中，耐心最大的敌人就是用力过猛。人的意志精神与体力体能最大的挑战都是过度。但凡过度，都会造成不可逆的损伤。当目标聚焦于结果和全局分解的目标后，就比较清晰的明确当前自身所处的阶段，然后对所处的状态便不在过喜过悲，患得患失。同时也会有更多的耐心去继续战斗。\n   \n   2018年1月份开始尝试做产品，从现阶段看来，做产品给我带来最大的好处是看事情的角度发生的变化，生活和工作也变得不再为某些东西的不顺心不如意而焦躁。那份心安理得并不是我不在乎，而是我很清楚光在乎是没用的，在乎去争取也是不一定有结果的。这跟早些年的佛系不一样，那会儿更多的佛系是放弃。而现在的佛系，是度己，放过自己。时间与资源条件的不允许，那就稍等片刻。这个片刻可以是一天，可以是一年，也可以是十年，最后熬死所有的阻碍。\n   \n   所以现在最大的难点是在于目标的抉择，目标抉择看来显得特别重要。它关乎于为之一生战斗的方向。\n   \n   我从不是安分的人，我想世间大体的东西都是相通的，重点在于技巧。有了技巧之后的耐心和热爱，持久的投入战斗。\n   \n   人是需要有喜爱的，在解决生存之后，一定要解决喜爱。我从不奢望生存的同时可以喜爱，我觉得这本身就是一种小概率的奢侈。我现在在为生存战斗。什么时候可以喜爱呢，我好期待。唯一害怕的就是不够长命可以活到我的喜爱，生存好难。\n   \n   那个我期望得到的人生呀，等等我呀，愿意以一生的耐心和热情，满怀欣喜的诚意来为你奋斗呀。\n   \n\n","updated":"2021-06-05T17:40:46.185Z","permalink":"http://yoursite.com/2020/01/15/%E4%B8%8D%E8%83%BD%E7%94%A8%E5%8A%9B%E8%BF%87%E7%8C%9B/","categories":[]},{"title":"淘汰缓存算法LRU","date":"2019-07-13T02:40:56.000Z","path":"2019/07/13/淘汰缓存算法LRU/","text":"LRU 算法一 原理如果数据最近被访问过，那么将来被访问的几率也更高。 LRU (Least Recently Used) 是一个置换算法，可以用来多种场景，例如操作系统的内存页面置换，简单来说，就是让最近被访问的对象的访问优先级提高，最少使用的对象能够被淘汰，尽可能的为可能被访问的对象服务，加快访问的速度和效率, 与之相对的有 MRU (Most Recently Used) 。 与 LRU 算法相近的是 LFU（Least Frequently Used）最近最少使用算法。LFU 是指如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。LFU 和 LRU 算法的不同之处，LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数的。 二 实现常见方法是利用链表保存数据。 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。 三 分析【命中率】 当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。 【复杂度】 实现简单。 【代价】 命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。 LRU-K 算法一 原理LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。 二 实现相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下： 数据第一次被访问，加入到访问历史列表； 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰； 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序； 缓存数据队列中被再次访问后，重新排序； 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。 LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。 三 分析【命中率】 LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。 【复杂度】 LRU-K队列是一个优先级队列，算法复杂度和代价比较高。 【代价】 由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。 LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。 Two queues（2Q）一 原理Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。 二 实现当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下： 新访问的数据插入到FIFO队列； 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰； 如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部； 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部； LRU队列淘汰末尾的数据。 注：上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。 三 分析【命中率】 2Q算法的命中率要高于LRU。 【复杂度】 需要两个队列，但两个队列本身都比较简单。 【代价】 FIFO和LRU的代价之和。 2Q算法和LRU-2算法命中率类似，内存消耗也比较接近，但对于最后缓存的数据来说，2Q会减少一次从原始存储读取数据或者计算数据的操作。 Multi Queue（MQ）一 原理MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据。 二 实现MQ算法将缓存划分为多个LRU队列，每个队列对应不同的访问优先级。访问优先级是根据访问次数计算出来的，例如 详细的算法结构图如下，Q0，Q1….Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列。 算法详细描述如下： 新插入的数据放入Q0； 每个队列按照LRU管理数据； 当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列删除，加入到高一级队列的头部； 为了防止高优先级数据永远不被淘汰，当数据在指定的时间里访问没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部； 需要淘汰数据时，从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部； 如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列的头部； Q-history按照LRU淘汰数据的索引。 三 分析【命中率】 MQ降低了“缓存污染”带来的问题，命中率比LRU要高。 【复杂度】 MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。 【代价】 MQ需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU要高。 注：虽然MQ的队列看起来数量比较多，但由于所有队列之和受限于缓存容量的大小，因此这里多个队列长度之和和一个LRU队列是一样的，因此队列扫描性能也相近。 LRU类算法对比由于不同的访问模型导致命中率变化较大，此处对比仅基于理论定性分析，不做定量分析。 对比 命中率 LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU 复杂度 LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU 代价 LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU 实际应用中需要根据业务的需求和对数据的访问情况进行选择，并不是命中率越高越好。例如：虽然LRU看起来命中率会低一些，且存在”缓存污染“的问题，但由于其简单和代价小，实际应用中反而应用更多。 拓展基于双链表的 LRU 实现: 传统意义的 LRU 算法是为每一个 Cache 对象设置一个计数器，每次 Cache 命中则给计数器+1，而 Cache 用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。 它的弊端很明显，如果 Cache 的数量少，问题不会很大， 但是如果 Cache 的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计算器，其性能与资源消耗是巨大的。效率也就非常的慢了。 它的原理：将 Cache 的所有位置都用双连表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的 Cache 直接加到链表头中。 这样，在多次进行 Cache 操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的 Cache 。 当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。","raw":"---\ntitle: 淘汰缓存算法LRU\ndate: 2019-07-13 10:40:56\ncategories:\ntoc: ture\ntags:\n     - LRU\n---\n\n\n\n# LRU 算法\n\n## 一 原理\n\n如果数据最近被访问过，那么将来被访问的几率也更高。\n\nLRU (Least Recently Used) 是一个置换算法，可以用来多种场景，例如操作系统的内存页面置换，简单来说，就是让最近被访问的对象的访问优先级提高，最少使用的对象能够被淘汰，尽可能的为可能被访问的对象服务，加快访问的速度和效率, 与之相对的有 MRU (Most Recently Used) 。\n\n与 LRU 算法相近的是 LFU（Least Frequently Used）最近最少使用算法。LFU 是指如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。LFU 和 LRU 算法的不同之处，LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数的。\n\n<!--more-->\n\n## 二 实现\n\n常见方法是利用链表保存数据。\n\n1. 新数据插入到链表头部；\n2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；\n3. 当链表满的时候，将链表尾部的数据丢弃。\n\n## 三 分析\n\n【命中率】\n\n当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。\n\n【复杂度】\n\n实现简单。\n\n【代价】\n\n命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。\n\n# LRU-K 算法\n\n## 一 原理\nLRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。\n\n## 二 实现\n相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：\n\n1. 数据第一次被访问，加入到访问历史列表；\n\n2. 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；\n\n3. 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；\n\n4. 缓存数据队列中被再次访问后，重新排序；\n\n5. 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。\n\nLRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。\n\n## 三 分析\n【命中率】\n\nLRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。\n\n【复杂度】\n\nLRU-K队列是一个优先级队列，算法复杂度和代价比较高。\n\n【代价】\n\n由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。\n\nLRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。\n\n\n# Two queues（2Q）\n\n## 一 原理\nTwo queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。\n\n## 二 实现\n当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：\n\n\n1. 新访问的数据插入到FIFO队列；\n\n2. 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；\n\n3. 如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；\n\n4. 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；\n\n5. LRU队列淘汰末尾的数据。\n\n \n\n注：上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。\n\n## 三 分析\n【命中率】\n\n2Q算法的命中率要高于LRU。\n\n【复杂度】\n\n需要两个队列，但两个队列本身都比较简单。\n\n【代价】\n\nFIFO和LRU的代价之和。\n\n2Q算法和LRU-2算法命中率类似，内存消耗也比较接近，但对于最后缓存的数据来说，2Q会减少一次从原始存储读取数据或者计算数据的操作。\n\n\n# Multi Queue（MQ）\n\n## 一 原理\n\nMQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据。\n\n## 二 实现\nMQ算法将缓存划分为多个LRU队列，每个队列对应不同的访问优先级。访问优先级是根据访问次数计算出来的，例如\n\n详细的算法结构图如下，Q0，Q1....Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列。\n\n算法详细描述如下：\n\n1. 新插入的数据放入Q0；\n\n2. 每个队列按照LRU管理数据；\n\n3. 当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列删除，加入到高一级队列的头部；\n\n4. 为了防止高优先级数据永远不被淘汰，当数据在指定的时间里访问没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；\n\n5. 需要淘汰数据时，从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部；\n\n6. 如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列的头部；\n\n7. Q-history按照LRU淘汰数据的索引。\n\n## 三 分析\n【命中率】\n\nMQ降低了“缓存污染”带来的问题，命中率比LRU要高。\n\n【复杂度】\n\nMQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。\n\n【代价】\n\nMQ需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU要高。\n\n注：虽然MQ的队列看起来数量比较多，但由于所有队列之和受限于缓存容量的大小，因此这里多个队列长度之和和一个LRU队列是一样的，因此队列扫描性能也相近。\n\n# LRU类算法对比\n\n由于不同的访问模型导致命中率变化较大，此处对比仅基于理论定性分析，不做定量分析。\n\n对比\n\n命中率\n\nLRU-2 > MQ(2) > 2Q > LRU\n\n复杂度\n\nLRU-2 > MQ(2) > 2Q > LRU\n\n代价\n\nLRU-2  > MQ(2) > 2Q > LRU\n\n实际应用中需要根据业务的需求和对数据的访问情况进行选择，并不是命中率越高越好。例如：虽然LRU看起来命中率会低一些，且存在”缓存污染“的问题，但由于其简单和代价小，实际应用中反而应用更多。\n\n\n# 拓展\n\n基于双链表的 LRU 实现:\n\n　　传统意义的 LRU 算法是为每一个 Cache 对象设置一个计数器，每次 Cache 命中则给计数器+1，而 Cache 用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。\n\n   它的弊端很明显，如果 Cache 的数量少，问题不会很大， 但是如果 Cache 的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计算器，其性能与资源消耗是巨大的。效率也就非常的慢了。\n   \n   它的原理：将 Cache 的所有位置都用双连表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的 Cache 直接加到链表头中。\n   \n   这样，在多次进行 Cache 操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的 Cache 。\n   \n   当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。\n\n","updated":"2021-06-05T17:41:22.840Z","permalink":"http://yoursite.com/2019/07/13/%E6%B7%98%E6%B1%B0%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95LRU/","categories":[]},{"title":"《从点子到产品》读书笔记","date":"2018-08-31T03:30:46.000Z","path":"2018/08/31/《从点子到产品》读书笔记/","text":"第一部分 产品价值和用户痛点第1章 点子与方案Talk is cheap，Show me the code。 — Linus Torvalds 成长建议 无法证明的创意时分文不值的。 我们在讨论点子的时候并没有意义。单纯有一句话的功能也没有意义。我们要把点子细化成方案，有健全的产品模型和商业模式，并在时空中有延展性、在团队能力上能够匹配，这样的点子才有价值。 要点反思 点子落地之前，务必先“纸上谈兵”一回。 说服身边最理性的人和最吹毛求疵的人认可你的想法。 证明你的团队可靠，跟证明方案本身的可靠同样重要。 第2章 找到产品核心价值Less is more。— Ludwig Mies Van der Rohe 成长建议 发现产品的核心价值，就是发现如何解决用户问题的过程。好的产品能够解决用户的实际问题而不是故意粘住用户。 时刻铭记，我们在做产品时设计的功能不是为了投资人、不是为了老板、不是为了理想，而是为了用户。为用户创造真正的价值，才是有意义的功能；而能为行业甚至全社会创造价值的产品，才是真的可以长青的产品。 要点反思 解决不了问题的产品，只能靠补贴和红包留住用户。一旦遇到更大的红包，用户说走就走。 问题解决得够彻底，下次用户会主动来找你。 第3章 MVP与痛点Do things don’t scale.— Paul Graham MVP(Minimum Viable Product)最小可用产品。MVP是埃里克·莱斯所著&lt;精益创业&gt;中提到的概念，它的目的是验证两件事：一是产品满足了用户需求；二是产品能够创造商业价值。初创团队的产品经理应该探讨产品模型和商业模式对应。MVP就是验证它们的手段。是在低成本的前提下将核心价值体现出来的最好方法。 第一，产品模型的合理不能确保功能也会受到用户认可，快速投入到市场中进行验证是最妥当的方法。互联网产品的迭代速度快、耗费资源少，也就提供了低成本试错的机会，让我们能够用这样的方法来检验产品功能。 第二，产品的核心功能就可以解决用户问题，所以从理论上说，就未必要等到产品非常复杂、完善之后，才能吸引用户。只要能解决问题，越快把产品提供给用户，就能越快获得这些用户。 在我们做出了MVP之后，要考虑的就是使用MVP来发现用户的痛点了。其中PMF（Product/Market Fit），也就是产品和市场的匹配点。PMF理论认为，产品的增长曲线会在找到契合的这个点之后，快速增长。在这之前，一直都是较低范围的波动状态。 产品经理在整个过程中，未必是按部就班只管设计、实践，还要做好判断：现在的产品处于什么阶段？它的运转是否良好？产品是否被用户承认？ 一个MVP对产品的要求是：达到可用与最小成本的平衡。但是最小可用不代表过于简化甚至残缺。有时候过于简化，把产品功能做得太过简陋，甚至到了残缺的程度，残缺的产品会影响到用户的正常使用方式，也就无法达到检验的效果了。 设计MVP 在设计MVP时，推荐参考的方法如下： 奥卡姆剃刀法 把预期完整的方案简单罗列出来，然后从最不重要的部分一点一点砍掉其中的功能。直到在砍下去正常功能就无法使用为止。 用户访谈 提供几个复杂程度不同的方案，做成便于理解的演示作品。比如ppt、demo或者图片。召集一些目标用户来评价。他们认为会接受的最低限度的版本就是最小可用版本。 去掉可人工处理的功能 把可以人工处理的功能丢掉，暂时用人力来完成，是降低开发成本、实现MVP的好方法。 确保只有一个功能 务必确保在产品里只有一个功能，不管第二个功能看起来有多炫酷。在MVP中，只实现最重要的那个功能，其他的功能之后再说。当然除非产品里这两个功能耦合在一起，分离就不产生价值了。在创投圈有句话很流行：“好的产品是一句话能讲清楚的。” MVP方法 设计好了MVP，运用的方法有很多。通常意义的MVP，就是可用的产品，投放到市场中让用户亲自体验，然后收集反馈，持续优化。互联网创业者们有很多有意思的手段，以更低的成本达到了MVP的效果。 广告 Dropbox的MVP方法经常被大家提起，广为流传。在他们团队想做云盘的点子后，在根本没有实现时，就做了一条3分钟的广告，描述了他们的产品内容，并留下了产品的注册方式。一夜之间，75000位用户注册了他们的产品。 广告形式实现MVP其实类似于用户访谈的形式，不过更具有说服力。拉着用户问他爱不爱用这个产品，他未必说心里话。但是发布一则广告，看有多少陌生人对产品产生了兴趣，就能证明这个产品会有多少人买账。 假MVP 做一个视觉效果没问题的产品，但是功能都是（或者部分是）假的。 线下实现 前面提到，能人工实现的部分功能可以考虑砍掉。那么如果线下也可以完全用别的办法实现，同样可以不考虑开发线上产品。 众筹 众筹在国内多用于硬件领域。把对产品功能的设想预售，用户只要愿意付钱买单，那么东西自然卖得出去。这是可以同时检验功能和商业价值的方法。 实现MVP 选择平台 考虑性价比最高的平台，切记每个平台做一套。 选择技术实现方案 考虑最小的技术成本。 关于外包 能不用就不用。或者非核心功能外包。 找到痛点 痛点其实就是产品经理要找的核心价值的体现。 根据痛点，我们不仅可以确定用户是认可的，还可以了解到用户为什么喜欢、在什么场景下会用到。所以发现了痛点之后，才是深挖需求、快速迭代的时机。 通过分析数据发现痛点 用户数据 1，使用频次2，日活跃用户、周活跃用户和月活跃用户3，用户留存（对电商和服务产品来说也可以用复购率来衡量用户留存，至少要在10～20%，用户留存要做长效的统计，比如第一天的用户第二天留存还不错，但是第五天都流失了，这就意味着留存价值很低；而每天的用户总有一部分会一直留存下来，就意味着留存的效果很好。） 商业数据 付费转化率。LTV/CAC&gt;3，即用户终生价值/用户获取成本&gt;3。所谓用户终生价值，指的是用户在使用产品的整个时间周期中与产品互动所产生的全部总计收益；而用户获取成本，指的是获取同样的用户，要花费的总成本。这是一种很常见的用户获取成本衡量的方法。整体的用户终生价值要大于用户获取成本的3倍，这样成本才算是可接受的，或者说这样的用户值得我们去获取。如果不考虑用户的终身价值，产品就会陷入徒有流量却总赚不到钱的两难境地。 发现痛点跟运营有特别紧密的联系，因为本质上，就是要观察产品是不是到了临界点，也要知道产品受到欢迎或者不被喜欢的原因。这时要跟运营的同事很好地合作，用数据来做出判断。 通过用户反馈发现痛点 常见的信息获取方法包括用户在线反馈和定向访谈。 对于用户在线反馈，建议在产品上增加比较醒目的反馈入口，推荐大家加入讨论。 除了官方渠道之外，要多观察哪里可能会有人讨论自己的产品。常见的是应用商店的评论区、贴吧、知乎、豆瓣、微博。多跟他们接触，而且针对他们提到的观点交流，会有很多的收获。 MVP不是不做产品模型的借口 使用MVP是基于一个前提，核心的产品功能是需要检验的。 产品既不能只走理论派远离用户，不能只信奉好的产品都应该是设计出来的。 产品也不能只走实践派一切来源于用户，用户说什么对就代表着什么是对的。 MVP看似实践派的方法，但实际上更像是二者的结合。 要设计出一个足够好的可用产品，至少要在产品功能上做分析，要确定她的产品模型、核心功能。但并不意味着有足够自信就可以一蹴而就。大部分产品经理都没有像乔布斯那样强大的产品感，也没有他那样好的设计能力，许多时候要证明我们的产品有价值，有两个因素必不可少的：在理论上成立，在实践中证明。 就像雷军所说的：不要用战术的勤奋来掩盖战略的懒惰。 成长建议 产品模型和对核心功能的设计像是指导思想，而MVP是实践的方法论。要敢于尽快迈出第一步，验证自己想法的对错。 MVP很难一击必中，要在检验的过程中判断产品功能有没有解决问题。如果及时发现问题，快速转向，也许生机就在别处。 要点反思 大部分在等待功能完善、交互完美、界面出色才能一炮而红的产品，往往都哦没等到那一天。 产品初期做设计要多做减法。 初期把整体流程跑通时不用特别在意是不是用“互联网方式”。 第二部分 需求分析和功能设计第4章 深挖需求If I had to ask customers what they want, they will tell me: a faster horse. — Henry Ford 用 Want（需要） 和 Needs（需求） 来区分表面需要，还是需要背后真正诉求。前者是“希望在产品中看到的功能”而后者是“确定具体问题，留待产品解决的问题”。 要以场景和人性本质两个维度来讨论如何深挖需求。 基于场景深挖需求 我们讨论场景时讨论的本质是什么呢？我们讨论的会是很形象的一些描述。这里包含了人物、时间、地点、环境及情节。 在考虑和分析需求时，带入实际场景，便能更准确的判断哪些需求是伪需求、哪些是弱需求。 从人性本质深挖需求 既然是人在用我们的产品，那么人的七情六欲、贪嗔痴、善恶是非观，就都跟产品有各种纠葛。 人性是人的本性、人的情感和理智，是我们要发掘出来的需求的根本源头。它们的存在创造了需求的场景。如果我们能够把握好用户在人性上的弱点，或者说在人性上存在的缺憾，那么产品就能一击即中。 多在产品上关于人性的讨论，可以更好的抓住需求的核心，而不是停留在需求的表层。从人性的角度去看问题，是更高的一种视角，能够知道表层需求的背后，反映出的人性需求。 逐利心理 如果产品模型本身就能带来红利，那么就可以满足用户逐利的需求。 两性吸引力 用合法合规的方式满足正常人都会有的色欲，也是很多产品在做的尝试。其实从广义上来说，色欲就是正常的两性关系的前置条件。 懒惰 在很多情况下，互联网服务的确提高了效率，降低了成本。对于用户来说，会体验到越来越多方便和快捷，也满足了更多用户比较懒、不爱动、不爱思考的天性。 虚荣心 游戏类的产品在人性的把控上都是顶尖的。 共情需求 共情，英文是Empathy，也可以翻译成同理心。原本指设身处地思考，并且感同身受的一种能力。在这里表达一种人性上的需求，即我们希望体会他们的生活和感受的需求。 大家在看直播的时候，往往不是想获得具体的知识、价值，也不是想要得到什么快感和刺激，更多的就是想在别人的直播里体验另一种生活。 社交货币 人是社会动物，社交也是很基础的属性。单纯的沟通是基础，有效地建立起社群，或者说满足某些用户的归属感是更高一层的要求。还有一种满足社交方面的需求，比较难解释，可以用《疯传》里提到的一个概念来阐述，即社交货币。在社交中都要拿出一些独特的，能代表自己品味、形象，以及社交价值的证明。这些都是社交货币。在互联网产品中的社交货币又是什么呢？答案就是产品传递出去的“价值观”。这种脱离产品本身功能上的效果，上升到了在对产品传递价值观的认同。 安全感 在使用任何产品的时候，我们都会特别在意安全问题。有的互联网产品就是直接解决用户的安全需求，或者把安全作为核心的亮点来吸引用户的。 成长建议 我们运用“第一原理思维”而不是“比较思维”去思考问题是非常重要的。我们在生活中倾向于比较—别人已经做过了或者正在做的这件事，我们也去做。这样的结果是只能产生细小的迭代发展。 思考需求也是如此，我们需要理解需求的本质到底是什么，然后去满足这个本质，而不是用形式上的花样和心理上的充实感作为衡量需求的标准。只有解决了问题的本质，产品的价值才能最大化。 要点反思 区分用户表达的究竟是诉求，还是具体的方案 不断假想自己是用户，以及真正到用户场景下体验都是发掘需求本质的好方法。 第5章 用户研究Know thyself. 常见的用户研究分类方法就是依据定性/定量和行为/观点这样的二维矩阵划分。","raw":"---\ntitle: 《从点子到产品》读书笔记\ndate: 2018-08-31 11:30:46\ncategories:\ntoc: ture\ntags:\n     - Notes\n\n---\n\n# 第一部分 产品价值和用户痛点\n\n## 第1章 点子与方案\n\nTalk is cheap，Show me the code。\n\n--- Linus Torvalds\n\n**成长建议**\n\n无法证明的创意时分文不值的。\n\n我们在讨论点子的时候并没有意义。单纯有一句话的功能也没有意义。我们要把点子细化成方案，有健全的产品模型和商业模式，并在时空中有延展性、在团队能力上能够匹配，这样的点子才有价值。\n\n**要点反思**\n\n- 点子落地之前，务必先“纸上谈兵”一回。\n- 说服身边最理性的人和最吹毛求疵的人认可你的想法。\n- 证明你的团队可靠，跟证明方案本身的可靠同样重要。\n\n<!--more-->\n\n## 第2章 找到产品核心价值\n\nLess is more。\n--- Ludwig Mies Van der Rohe\n\n**成长建议**\n\n发现产品的核心价值，就是发现如何解决用户问题的过程。好的产品能够解决用户的实际问题而不是故意粘住用户。\n\n时刻铭记，我们在做产品时设计的功能不是为了投资人、不是为了老板、不是为了理想，而是为了用户。为用户创造真正的价值，才是有意义的功能；而能为行业甚至全社会创造价值的产品，才是真的可以长青的产品。\n\n**要点反思**\n\n- 解决不了问题的产品，只能靠补贴和红包留住用户。一旦遇到更大的红包，用户说走就走。\n- 问题解决得够彻底，下次用户会主动来找你。\n\n## 第3章 MVP与痛点\n\nDo things don't scale.\n--- Paul Graham\n\nMVP(Minimum Viable Product)最小可用产品。\nMVP是埃里克·莱斯所著<精益创业>中提到的概念，它的目的是验证两件事：一是产品满足了用户需求；二是产品能够创造商业价值。\n初创团队的产品经理应该探讨产品模型和商业模式对应。MVP就是验证它们的手段。是在低成本的前提下将核心价值体现出来的最好方法。\n\n第一，产品模型的合理不能确保功能也会受到用户认可，快速投入到市场中进行验证是最妥当的方法。互联网产品的迭代速度快、耗费资源少，也就提供了低成本试错的机会，让我们能够用这样的方法来检验产品功能。\n\n第二，产品的核心功能就可以解决用户问题，所以从理论上说，就未必要等到产品非常复杂、完善之后，才能吸引用户。只要能解决问题，越快把产品提供给用户，就能越快获得这些用户。\n\n在我们做出了MVP之后，要考虑的就是使用MVP来发现用户的痛点了。其中PMF（Product/Market Fit），也就是产品和市场的匹配点。PMF理论认为，产品的增长曲线会在找到契合的这个点之后，快速增长。在这之前，一直都是较低范围的波动状态。\n\n产品经理在整个过程中，未必是按部就班只管设计、实践，还要做好判断：现在的产品处于什么阶段？它的运转是否良好？产品是否被用户承认？\n\n一个MVP对产品的要求是：达到可用与最小成本的平衡。但是最小可用不代表过于简化甚至残缺。有时候过于简化，把产品功能做得太过简陋，甚至到了残缺的程度，残缺的产品会影响到用户的正常使用方式，也就无法达到检验的效果了。\n\n**设计MVP**\n\n在设计MVP时，推荐参考的方法如下：\n\n- 奥卡姆剃刀法\n\n把预期完整的方案简单罗列出来，然后从最不重要的部分一点一点砍掉其中的功能。直到在砍下去正常功能就无法使用为止。\n\n- 用户访谈\n\n提供几个复杂程度不同的方案，做成便于理解的演示作品。比如ppt、demo或者图片。召集一些目标用户来评价。他们认为会接受的最低限度的版本就是最小可用版本。\n\n- 去掉可人工处理的功能\n\n把可以人工处理的功能丢掉，暂时用人力来完成，是降低开发成本、实现MVP的好方法。\n\n- 确保只有一个功能\n\n务必确保在产品里只有一个功能，不管第二个功能看起来有多炫酷。在MVP中，只实现最重要的那个功能，其他的功能之后再说。当然除非产品里这两个功能耦合在一起，分离就不产生价值了。在创投圈有句话很流行：“好的产品是一句话能讲清楚的。”\n\n**MVP方法**\n\n设计好了MVP，运用的方法有很多。通常意义的MVP，就是可用的产品，投放到市场中让用户亲自体验，然后收集反馈，持续优化。互联网创业者们有很多有意思的手段，以更低的成本达到了MVP的效果。\n\n- 广告\n\nDropbox的MVP方法经常被大家提起，广为流传。在他们团队想做云盘的点子后，在根本没有实现时，就做了一条3分钟的广告，描述了他们的产品内容，并留下了产品的注册方式。一夜之间，75000位用户注册了他们的产品。\n\n广告形式实现MVP其实类似于用户访谈的形式，不过更具有说服力。拉着用户问他爱不爱用这个产品，他未必说心里话。但是发布一则广告，看有多少陌生人对产品产生了兴趣，就能证明这个产品会有多少人买账。\n\n- 假MVP\n\n做一个视觉效果没问题的产品，但是功能都是（或者部分是）假的。\n\n- 线下实现\n\n前面提到，能人工实现的部分功能可以考虑砍掉。那么如果线下也可以完全用别的办法实现，同样可以不考虑开发线上产品。\n\n- 众筹\n\n众筹在国内多用于硬件领域。把对产品功能的设想预售，用户只要愿意付钱买单，那么东西自然卖得出去。这是可以同时检验功能和商业价值的方法。\n\n**实现MVP**\n\n- 选择平台\n\n考虑性价比最高的平台，切记每个平台做一套。\n\n- 选择技术实现方案\n\n考虑最小的技术成本。\n\n- 关于外包\n\n能不用就不用。或者非核心功能外包。\n\n**找到痛点**\n\n痛点其实就是产品经理要找的核心价值的体现。\n\n根据痛点，我们不仅可以确定用户是认可的，还可以了解到用户为什么喜欢、在什么场景下会用到。所以发现了痛点之后，才是深挖需求、快速迭代的时机。\n\n通过分析数据发现痛点\n\n- 用户数据\n\n1，使用频次\n2，日活跃用户、周活跃用户和月活跃用户\n3，用户留存\n（对电商和服务产品来说也可以用复购率来衡量用户留存，至少要在10～20%，用户留存要做长效的统计，比如第一天的用户第二天留存还不错，但是第五天都流失了，这就意味着留存价值很低；而每天的用户总有一部分会一直留存下来，就意味着留存的效果很好。）\n\n- 商业数据\n\n付费转化率。\nLTV/CAC>3，即用户终生价值/用户获取成本>3。所谓用户终生价值，指的是用户在使用产品的整个时间周期中与产品互动所产生的全部总计收益；而用户获取成本，指的是获取同样的用户，要花费的总成本。这是一种很常见的用户获取成本衡量的方法。整体的用户终生价值要大于用户获取成本的3倍，这样成本才算是可接受的，或者说这样的用户值得我们去获取。如果不考虑用户的终身价值，产品就会陷入徒有流量却总赚不到钱的两难境地。\n\n发现痛点跟运营有特别紧密的联系，因为本质上，就是要观察产品是不是到了临界点，也要知道产品受到欢迎或者不被喜欢的原因。这时要跟运营的同事很好地合作，用数据来做出判断。\n\n- 通过用户反馈发现痛点\n\n常见的信息获取方法包括用户在线反馈和定向访谈。\n\n对于用户在线反馈，建议在产品上增加比较醒目的反馈入口，推荐大家加入讨论。\n\n除了官方渠道之外，要多观察哪里可能会有人讨论自己的产品。常见的是应用商店的评论区、贴吧、知乎、豆瓣、微博。多跟他们接触，而且针对他们提到的观点交流，会有很多的收获。\n\n**MVP不是不做产品模型的借口**\n\n使用MVP是基于一个前提，核心的产品功能是需要检验的。\n\n产品既不能只走理论派远离用户，不能只信奉好的产品都应该是设计出来的。\n\n产品也不能只走实践派一切来源于用户，用户说什么对就代表着什么是对的。\n\nMVP看似实践派的方法，但实际上更像是二者的结合。\n\n要设计出一个足够好的可用产品，至少要在产品功能上做分析，要确定她的产品模型、核心功能。但并不意味着有足够自信就可以一蹴而就。大部分产品经理都没有像乔布斯那样强大的产品感，也没有他那样好的设计能力，许多时候要证明我们的产品有价值，有两个因素必不可少的：在理论上成立，在实践中证明。\n\n就像雷军所说的：不要用战术的勤奋来掩盖战略的懒惰。\n\n**成长建议**\n\n产品模型和对核心功能的设计像是指导思想，而MVP是实践的方法论。要敢于尽快迈出第一步，验证自己想法的对错。\n\nMVP很难一击必中，要在检验的过程中判断产品功能有没有解决问题。如果及时发现问题，快速转向，也许生机就在别处。\n\n\n**要点反思**\n\n- 大部分在等待功能完善、交互完美、界面出色才能一炮而红的产品，往往都哦没等到那一天。\n\n- 产品初期做设计要多做减法。\n\n- 初期把整体流程跑通时不用特别在意是不是用“互联网方式”。\n\n\n# 第二部分 需求分析和功能设计\n\n## 第4章 深挖需求\n\nIf I had to ask customers what they want, they will tell me: a faster horse.\n\n--- Henry Ford\n\n用 Want（需要） 和 Needs（需求） 来区分表面需要，还是需要背后真正诉求。前者是“希望在产品中看到的功能”而后者是“确定具体问题，留待产品解决的问题”。\n\n要以场景和人性本质两个维度来讨论如何深挖需求。\n\n**基于场景深挖需求**\n\n我们讨论场景时讨论的本质是什么呢？我们讨论的会是很形象的一些描述。这里包含了人物、时间、地点、环境及情节。\n\n在考虑和分析需求时，带入实际场景，便能更准确的判断哪些需求是伪需求、哪些是弱需求。\n\n**从人性本质深挖需求**\n\n既然是人在用我们的产品，那么人的七情六欲、贪嗔痴、善恶是非观，就都跟产品有各种纠葛。\n\n人性是人的本性、人的情感和理智，是我们要发掘出来的需求的根本源头。它们的存在创造了需求的场景。如果我们能够把握好用户在人性上的弱点，或者说在人性上存在的缺憾，那么产品就能一击即中。\n\n多在产品上关于人性的讨论，可以更好的抓住需求的核心，而不是停留在需求的表层。从人性的角度去看问题，是更高的一种视角，能够知道表层需求的背后，反映出的人性需求。\n\n**逐利心理**\n\n如果产品模型本身就能带来红利，那么就可以满足用户逐利的需求。\n\n**两性吸引力**\n\n用合法合规的方式满足正常人都会有的色欲，也是很多产品在做的尝试。其实从广义上来说，色欲就是正常的两性关系的前置条件。\n\n**懒惰**\n\n在很多情况下，互联网服务的确提高了效率，降低了成本。对于用户来说，会体验到越来越多方便和快捷，也满足了更多用户比较懒、不爱动、不爱思考的天性。\n\n**虚荣心**\n\n游戏类的产品在人性的把控上都是顶尖的。\n\n**共情需求**\n\n共情，英文是Empathy，也可以翻译成同理心。原本指设身处地思考，并且感同身受的一种能力。在这里表达一种人性上的需求，即我们希望体会他们的生活和感受的需求。\n\n大家在看直播的时候，往往不是想获得具体的知识、价值，也不是想要得到什么快感和刺激，更多的就是想在别人的直播里体验另一种生活。\n\n**社交货币**\n\n人是社会动物，社交也是很基础的属性。\n单纯的沟通是基础，有效地建立起社群，或者说满足某些用户的归属感是更高一层的要求。\n还有一种满足社交方面的需求，比较难解释，可以用《疯传》里提到的一个概念来阐述，即社交货币。在社交中都要拿出一些独特的，能代表自己品味、形象，以及社交价值的证明。这些都是社交货币。\n在互联网产品中的社交货币又是什么呢？答案就是产品传递出去的“价值观”。这种脱离产品本身功能上的效果，上升到了在对产品传递价值观的认同。\n\n**安全感**\n\n在使用任何产品的时候，我们都会特别在意安全问题。有的互联网产品就是直接解决用户的安全需求，或者把安全作为核心的亮点来吸引用户的。\n\n**成长建议**\n\n我们运用“第一原理思维”而不是“比较思维”去思考问题是非常重要的。我们在生活中倾向于比较---别人已经做过了或者正在做的这件事，我们也去做。这样的结果是只能产生细小的迭代发展。\n\n思考需求也是如此，我们需要理解需求的本质到底是什么，然后去满足这个本质，而不是用形式上的花样和心理上的充实感作为衡量需求的标准。只有解决了问题的本质，产品的价值才能最大化。\n\n**要点反思**\n\n- 区分用户表达的究竟是诉求，还是具体的方案\n- 不断假想自己是用户，以及真正到用户场景下体验都是发掘需求本质的好方法。\n\n## 第5章 用户研究\n\nKnow thyself.\n\n常见的用户研究分类方法就是依据定性/定量和行为/观点这样的二维矩阵划分。\n\n\n\n","updated":"2021-06-05T17:42:01.059Z","permalink":"http://yoursite.com/2018/08/31/%E3%80%8A%E4%BB%8E%E7%82%B9%E5%AD%90%E5%88%B0%E4%BA%A7%E5%93%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","categories":[]},{"title":"几种常见的POST请求提交数据方式对前端开发的影响","date":"2018-07-18T12:42:28.000Z","path":"2018/07/18/几种常见的POST请求提交数据方式对前端开发的影响/","text":"HTTP协议中,规定的HTTP请求方法大致有: GET/POST/PUT/PATCH/DELETE/COPY/HEAD/OPTIONS/LINK/UNLINK/PURGE/LOCK/UNLOCK/PROPFIND/VIEW 其中我们最常用的有 GET/POST/PUT/PATCH/DELETE 这五种,而本文选取其中最典型的 POST 请求提交数据的方法进行探讨分析. 1.HTTP请求报文解剖首先HTTP协议建立在 TCP/IP 协议之上,且以 ASCII 码传输信息内容. HTTP 的规范将 HTTP 请求分为三个部分:状态行、请求头、消息主体.举例如下: HTTP请求报文分析:①是请求方法,GET和POST是最常见的HTTP方法.大多数浏览器只支持GET和POST,Spring 3.0提供了一个HiddenHttpMethodFilter,允许通过“_method”的表单参数指定这些特殊的HTTP方法（实际上还是通过POST提交表单）.服务端配置了HiddenHttpMethodFilter后,Spring会根据_method参数指定的值模拟出相应的HTTP方法,这样,就可以使用这些HTTP方法对处理方法进行映射了.②为请求对应的URL地址,它和报文头的Host属性组成完整的请求URL.③是协议名称及版本号.④是HTTP的报文头,报文头包含若干个属性,格式为“属性名:属性值”,服务端据此获取客户端的信息.⑤是报文体,它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串,它承载多个请求参数的数据.不但报文体可以传递请求参数,请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数. 1.1 常见的HTTP请求报文头属性1.1.1 Accept请求报文可通过一个“Accept”报文头属性告诉服务端,客户端接受什么类型的响应. Accept:text/plain 1.1.2 Cookie客户端的Cookie是通过这个报文头属性传给服务端.Cookie包含一些版本信息内容等,进而服务器可以识别请求是哪个版本的客户端发送来的请求等其他作用. Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23BE13C4C 1.1.3 Referer请求是从哪个URL过来的. 1.1.4 Cache-Control缓存控制,一个请求希望响应返回的内容在客户端要被缓存多久,或不希望被缓存可以通过这个报文头达到目的. Cache-Control: no-cache 以上是个人觉得比较常见和重要的报文头属性,还有其他内容暂不做介绍. 报文头属性参数以及数值,都是客户端对服务端发起的,服务端只能读. 2.HTTP响应报文解剖HTTP 响应也分为三个部分:响应行、响应头、响应体.举例如下: HTTP响应报文分析:①报文协议及版本；②状态码及状态描述；③响应报文头,也是由多个属性组成；④响应报文体,即客户端想要获取的请求内容. 2.1 响应状态码和请求报文相比,响应报文多了一个“响应状态码”,它以“清晰明确”的语言告诉客户端本次请求的处理结果. HTTP的响应状态码由5段组成： - 1xx 消息,一般是告诉客户端,请求已经收到了,正在处理,别急... - 2xx 处理成功,一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息. - 3xx 重定向到其它地方.它让客户端再发起一个请求以完成整个处理. - 4xx 处理发生错误,责任在客户端,如客户端的请求一个不存在的资源,客户端未被授权,禁止访问等. - 5xx 处理发生错误,责任在服务端,如服务端抛出异常,路由出错,HTTP版本不支持等. 常见的几个状态码如下: 200 OK303 See Other / 304 Not Modified404 Not Found500 Internal Server Error 2.2 常见的HTTP响应报文头属性2.2.1 Cache-Control响应输出到客户端后,服务端通过该报文头属告诉客户端如何控制响应内容的缓存. Cache-Control: max-age=3600 2.2.2 ETag一个代表响应服务端资源（如页面）版本的报文头属性,如果某个服务端资源发生变化了,这个ETag就会相应发生变化.它是Cache-Control的有益补充,可以让客户端“更智能”地处理什么时候要从服务端取资源,什么时候可以直接从缓存中返回响应. ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot; 2.2.3 Location在JSP中让页面Redirect到一个某个A页面中,其实是让客户端再发一个请求到A页面,这个需要Redirect到的A页面的URL,其实就是通过响应报文头的Location属性告知客户端的,如下的报文头属性,将使客户端redirect到iteye的首页中: Location: http://www.iteye.com 2.2.4 Set-Cookie服务端可以设置客户端的Cookie,其原理就是通过这个响应报文头属性实现的： Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 以上是个人觉得比较常见和重要的报文头属性,还有其他内容暂不做介绍. 3.关于HTTP请求的具体操作(构建请求体Body)通过前面1和2的粗浅分析,可以知道在客户端和服务端数据通信过程中,能否正常通顺的请求到客户端想要的数据,对于客户端来说是客户端最关心的事情. HTTP协议规定了POST请求所提交的数据必须要放到消息主体中,但协议并没有规定数据必须使用什么编码方式.所以在开发过程中,开发者完全可以自己决定消息体内容格式,最后只要HTTP请求发出去的内容满足HTTP的格式就行了.所以你们经常会看到有很多五花八门的HTTP格式.虽然很随意不过大多数开发者还会遵守一些默认的规定:服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码,再对主体进行解析[注意:请求头和响应头都有Content-Type属性,它们分别都是用来约束各自的主体消息的,所以不要弄混].如果按照这种设定就意味着: POST 提交数据方案也同样包含了 Content-Type 和消息主体编码方式两部分内容.这二部分内容在一起其实就是构造整个请求体的标准和具体内容. POSTMAN上给了四种常见的请求体类型(body类型): form-data/x-www-form-urlencoded/row/binary 3.1 multipart/form-data (form-data)使用表单上传文件时,必须让 表单的 enctype 等于 multipart/form-data.在客户端和服务端通信过程中,如果需要上传文件(服务端不借助于第三方平台管理静态资源的时候,自己维护的时候),或者混合上传给服务端数据的时候,这种请求就很常见. POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;text&quot; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 可以粗浅的分析下这个内容的结构:首先生成了一个 boundary 用于分割不同的字段,为了避免与正文内容重复, boundary 很长很复杂.然后 Content-Type 里指明了数据是以 multipart/form-data 来编码,本次请求的 boundary 是什么内容.消息主体里按照字段个数又分为多个结构类似的部分,每部分都是以 –boundary 开始,紧接着是内容描述信息,然后是回车,最后是字段具体内容（文本或二进制）.如果传输的是文件,还要包含文件名和文件类型信息.消息主体最后以 –boundary– 标示结束. 所以以 –boundary 作为分割线分部分上传多种不同的内容的混合上传模式,最后再以 –boundary– 来结尾. 注意: 1.Content-Type:multipart/form-data 2.格式内容必须要 以 –boundary 标示开始 以 –boundary– 标示结束. 3.a.如果要上传KEY-VALUE: Content-Disposition: form-data; name=&quot;KEY&quot; VALUE 这里的KEY就是键值对的KEY,换行之后(\\r\\n),再写VALUE. b.如果上传图片或文件: Content-Disposition: form-data; name=&quot;KEY&quot;; filename=&quot;wfiegpwakg.jpg&quot; Content-Type: image/jpeg c.其他上传文件与图片类似,不做赘述. 4.最后要以Data二进制流的形式上传. 这里有一个处理KEY-VALUE的代码范例,这里显得很不简洁,远没有设置参数的方法简单.如果单纯的只有普通数据提交,建议不要用 multipart/form-data 这种方式. NSString *boundary = [NSString stringWithFormat:@&quot;Boundary+%08X%08X&quot;, arc4random(), arc4random()]; NSMutableData *body = [NSMutableData data]; // 表单数据 NSMutableDictionary *param = [@&#123;@&quot;email&quot;:self-&gt;_email,@&quot;type&quot;:self-&gt;_type,@&quot;clientType&quot;:@&quot;1&quot;&#125; mutableCopy]; [param enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSMutableString *fieldStr = [NSMutableString string]; [fieldStr appendString:[NSString stringWithFormat:@&quot;–%@\\r\\n&quot;, boundary]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;%@\\&quot;\\r\\n\\r\\n&quot;, key]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;%@&quot;, obj]]; [body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:[@&quot;\\r\\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; &#125;]; // 结束部分 NSString *bottomStr = [NSString stringWithFormat:@&quot;-–%@–-&quot;, boundary]; /**拼装成格式： -–Boundary+72D4CD655314C423–- */ [body appendData:[bottomStr dataUsingEncoding:NSUTF8StringEncoding]]; //[formData appendPartWithHeaders:@&#123;@&quot;Content-Type&quot;:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,boundary]&#125; body:body]; //最后是用request来直接设置httpbody和content-type还是用AFMultipartFormData来设置,要看框架和具体实现,怎么方便怎么来.但是可以肯定的是,这里的httpBody肯定不能用params参数(字典的形式/或者序列化后的字典JSON字符串)来提交了.只能用方法给HttpBody复制Data. //补充:为何iOS开发或者安卓开发中可以直接给HttpBody添加Params来传值,是因为框架底层都对Params进行了处理,让它成为Data,是给框架使用者提供了方便. 3.2 application/x-www-form-urlencoded (x-www-form-urlencoded)绝大部分浏览器的原生form表单提交形式就是这种形式,如果不设置 enctype 属性,那么最终就会以 application/x-www-form-urlencoded 方式提交数据. 1.Content-Type: application/x-www-form-urlencoded2.提交的数据按照 key1=value1&amp;key2=value2 的方式进行编码, key 和 value 都进行了 URL 转码,可以理解为一个string,但是是有&amp;链接并且转码后的.3.不支持文件类型数据的提交,只支持键值对的形式提交. POST http://www.example.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 3.3 application/json (row的一种类型)这种就是最常见的POST请求提交的JSON数据. 1.Content-Type: application/json;charset=utf-82.JSON序列化后的string数据 POST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8 &#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125; 3.4 application/text/xml (row的一种类型)这种就是最常见的POST请求提交的text/xml文本格式数据. 1.Content-Type: text/xml2.text/xml标签格式的数据(由于text/xml标签格式的数据书写麻烦,且JSON序列化的简单易用,导致这种方法逐渐被摒弃) POST http://www.example.com HTTP/1.1 Content-Type: text/xml &lt;?xml version=&quot;1.0&quot;?&gt; &lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt; &lt;/methodCall&gt; 3.5 其他内容 (row的其他类型 + binary类型)1.上述的3.3和3.4的Content-type同属于row类型,row就是相当于给你一个文本框,你可以在里面写约定的固定格式的内容,然后把约定好的固定格式的内容提交,常见的如下几种: TextText(text/plain)JSON(application/json) —–&gt; [对应上述3.3]Javascript(application/javascript)XML(application/xml)XML(text/xml) —–&gt; [对应上述3.4]HTML(text/html) 其他几个内容大体上和3.3以及3.4相同,具体肯定也略有差异,在此不做赘述. 2.关于binary类型,其实相当于Content-Type:application/octet-stream,可以上传二进制数据,通常用来上传文件,由于没有键值,所以一次只能上传一个文件.它的特性决定了它使用不够普及,到目前为止我还没用过这种类型的上传方式. 4.综述这篇文章的意义在于,以后跟服务端对接口的时候,直接问body体构建类型是form-data/x-www-form-urlencoded/row/binary这四种中的哪一种类型,既显得专业,又降低了交流成本. 从上面的内容可以看出,目前最通用话的应该是3.3这种类型,因为好处理,其他类型都在格式上有强烈的要求和限制,稍不注意就会犯拼写的格式错误,而提交不了数据,访问不了服务器接口.此外JSON的序列化和反序列化的普及,又方便了这里的数据通信,各大网络请求框架不论客户端网页端都毫无疑问都支持JSON序列化,从接口的通用性来说,大多数人还是会选择3.3这种类型. 其次就是3.2这种类型.此外3.2这种类型和GET请求有着很大的相似性,现在大部分的网络请求框架的处理表现形式会给我们在这点的区分上有很大的迷惑性,下面我会讲它们的具体差异. 3.2这种类型有点像GET请求在URL加?加key=value&amp;key=value,但是有着本质上的区别,因为GET请求的?key=value&amp;key=value是追加在URL后面的,而3.2是要放到Body体里的,对于GET请求而言,它没有真正意义上的Body体,通用的网络框架对于GET请求需要追加的参数虽然外表也用Params来接收外部的变量,但是内部处理还是追加在URL后的,所以3.2这种情况和GET请求有着本质上的差别,虽然外在形式可能很接近.","raw":"---\ntitle: 几种常见的POST请求提交数据方式对前端开发的影响\ndate: 2018-07-18 20:42:28\ncategories:\ntoc: true\ntags:\n     - POST请求\n     - POSTMAN\n     - form-data\n     - x-www-form-urlencoded\n     - row\n     - binary\n---\n\nHTTP协议中,规定的HTTP请求方法大致有: \n\nGET/POST/PUT/PATCH/DELETE/\nCOPY/HEAD/OPTIONS/LINK/UNLINK/PURGE/\nLOCK/UNLOCK/PROPFIND/VIEW \n\n其中我们最常用的有 GET/POST/PUT/PATCH/DELETE 这五种,而本文选取其中最典型的 POST 请求提交数据的方法进行探讨分析.\n\n<!--more-->\n\n## 1.HTTP请求报文解剖\n\n首先HTTP协议建立在 TCP/IP 协议之上,且以 ASCII 码传输信息内容.\n\nHTTP 的规范将 HTTP 请求分为三个部分:状态行、请求头、消息主体.举例如下:\n\n> HTTP请求报文分析:\n> ①是请求方法,GET和POST是最常见的HTTP方法.大多数浏览器只支持GET和POST,Spring 3.0提供了一个HiddenHttpMethodFilter,允许通过“_method”的表单参数指定这些特殊的HTTP方法（实际上还是通过POST提交表单）.服务端配置了HiddenHttpMethodFilter后,Spring会根据_method参数指定的值模拟出相应的HTTP方法,这样,就可以使用这些HTTP方法对处理方法进行映射了. \n> ②为请求对应的URL地址,它和报文头的Host属性组成完整的请求URL.\n> ③是协议名称及版本号.\n> ④是HTTP的报文头,报文头包含若干个属性,格式为“属性名:属性值”,服务端据此获取客户端的信息. \n> ⑤是报文体,它将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串,它承载多个请求参数的数据.不但报文体可以传递请求参数,请求URL也可以通过类似于“/chapter15/user.html? param1=value1&param2=value2”的方式传递请求参数. \n\n\n### 1.1 常见的HTTP请求报文头属性 \n\n#### 1.1.1 Accept\n\n请求报文可通过一个“Accept”报文头属性告诉服务端,客户端接受什么类型的响应.\n\n    Accept:text/plain  \n\n#### 1.1.2 Cookie\n\n客户端的Cookie是通过这个报文头属性传给服务端.Cookie包含一些版本信息内容等,进而服务器可以识别请求是哪个版本的客户端发送来的请求等其他作用.\n\n    Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23BE13C4C  \n             \n\n#### 1.1.3 Referer       \n\n请求是从哪个URL过来的.\n\n#### 1.1.4 Cache-Control\n\n缓存控制,一个请求希望响应返回的内容在客户端要被缓存多久,或不希望被缓存可以通过这个报文头达到目的.\n\n    Cache-Control: no-cache\n        \n\n以上是个人觉得比较常见和重要的报文头属性,还有其他内容暂不做介绍.\n\n报文头属性参数以及数值,都是客户端对服务端发起的,服务端只能读.\n\n\n## 2.HTTP响应报文解剖\n\nHTTP 响应也分为三个部分:响应行、响应头、响应体.举例如下:\n\n> HTTP响应报文分析:\n> ①报文协议及版本； \n> ②状态码及状态描述； \n> ③响应报文头,也是由多个属性组成； \n> ④响应报文体,即客户端想要获取的请求内容. \n\n### 2.1 响应状态码 \n\n和请求报文相比,响应报文多了一个“响应状态码”,它以“清晰明确”的语言告诉客户端本次请求的处理结果.\n\nHTTP的响应状态码由5段组成：\n\n    - 1xx 消息,一般是告诉客户端,请求已经收到了,正在处理,别急...\n    - 2xx 处理成功,一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.\n    - 3xx 重定向到其它地方.它让客户端再发起一个请求以完成整个处理.\n    - 4xx 处理发生错误,责任在客户端,如客户端的请求一个不存在的资源,客户端未被授权,禁止访问等.\n    - 5xx 处理发生错误,责任在服务端,如服务端抛出异常,路由出错,HTTP版本不支持等.\n\n\n常见的几个状态码如下:\n\n200 OK  \n303 See Other / 304 Not Modified\n404 Not Found \n500 Internal Server Error\n\n\n### 2.2 常见的HTTP响应报文头属性 \n\n#### 2.2.1 Cache-Control \n\n响应输出到客户端后,服务端通过该报文头属告诉客户端如何控制响应内容的缓存.\n\n    Cache-Control: max-age=3600  \n    \n#### 2.2.2 ETag \n\n一个代表响应服务端资源（如页面）版本的报文头属性,如果某个服务端资源发生变化了,这个ETag就会相应发生变化.它是Cache-Control的有益补充,可以让客户端“更智能”地处理什么时候要从服务端取资源,什么时候可以直接从缓存中返回响应. \n\n    ETag: \"737060cd8c284d8af7ad3082f209582d\"  \n    \n\n#### 2.2.3 Location\n\n在JSP中让页面Redirect到一个某个A页面中,其实是让客户端再发一个请求到A页面,这个需要Redirect到的A页面的URL,其实就是通过响应报文头的Location属性告知客户端的,如下的报文头属性,将使客户端redirect到iteye的首页中:\n\n    Location: http://www.iteye.com  \n    \n#### 2.2.4 Set-Cookie\n\n服务端可以设置客户端的Cookie,其原理就是通过这个响应报文头属性实现的： \n\n    Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 \n    \n以上是个人觉得比较常见和重要的报文头属性,还有其他内容暂不做介绍.\n\n## 3.关于HTTP请求的具体操作(构建请求体Body)\n\n通过前面1和2的粗浅分析,可以知道在客户端和服务端数据通信过程中,能否正常通顺的请求到客户端想要的数据,对于客户端来说是客户端最关心的事情.\n\nHTTP协议规定了POST请求所提交的数据必须要放到消息主体中,但协议并没有规定数据必须使用什么编码方式.所以在开发过程中,开发者完全可以自己决定消息体内容格式,最后只要HTTP请求发出去的内容满足HTTP的格式就行了.所以你们经常会看到有很多五花八门的HTTP格式.虽然很随意不过大多数开发者还会遵守一些默认的规定:**服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码,再对主体进行解析[注意:请求头和响应头都有Content-Type属性,它们分别都是用来约束各自的主体消息的,所以不要弄混].**如果按照这种设定就意味着: POST 提交数据方案也同样包含了 Content-Type 和消息主体编码方式两部分内容.这二部分内容在一起其实就是构造整个请求体的标准和具体内容.\n\nPOSTMAN上给了四种常见的请求体类型(body类型):\n\nform-data/x-www-form-urlencoded/row/binary\n\n\n### 3.1 multipart/form-data (form-data)\n\n使用表单上传文件时,必须让 <form> 表单的 enctype 等于 multipart/form-data.在客户端和服务端通信过程中,如果需要上传文件(服务端不借助于第三方平台管理静态资源的时候,自己维护的时候),或者混合上传给服务端数据的时候,这种请求就很常见.\n\n    POST http://www.example.com HTTP/1.1\n    Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n    \n    ------WebKitFormBoundaryrGKCBY7qhFd3TrwA\n    Content-Disposition: form-data; name=\"text\"\n    \n    title\n    ------WebKitFormBoundaryrGKCBY7qhFd3TrwA\n    Content-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"\n    Content-Type: image/png\n    \n    PNG ... content of chrome.png ...\n    ------WebKitFormBoundaryrGKCBY7qhFd3TrwA--\n    \n    \n可以粗浅的分析下这个内容的结构:首先生成了一个 boundary 用于分割不同的字段,为了避免与正文内容重复, boundary 很长很复杂.然后 Content-Type 里指明了数据是以 multipart/form-data 来编码,本次请求的 boundary 是什么内容.消息主体里按照字段个数又分为多个结构类似的部分,每部分都是以 --boundary 开始,紧接着是内容描述信息,然后是回车,最后是字段具体内容（文本或二进制）.如果传输的是文件,还要包含文件名和文件类型信息.消息主体最后以 --boundary-- 标示结束.\n\n所以以 --boundary 作为分割线分部分上传多种不同的内容的混合上传模式,最后再以 --boundary-- 来结尾.\n\n\n注意:\n\n1.Content-Type:multipart/form-data\n\n2.格式内容必须要 以 --boundary 标示开始 以 --boundary-- 标示结束.\n\n3.a.如果要上传KEY-VALUE:\n\n      Content-Disposition: form-data; name=\"KEY\"\n      \n      VALUE\n  \n  > 这里的KEY就是键值对的KEY,换行之后(\\r\\n),再写VALUE.\n  \n  b.如果上传图片或文件:\n  \n      Content-Disposition: form-data; name=\"KEY\"; filename=\"wfiegpwakg.jpg\"\n      Content-Type: image/jpeg\n      \n  c.其他上传文件与图片类似,不做赘述.    \n  \n4.最后要以Data二进制流的形式上传.\n\n这里有一个处理KEY-VALUE的代码范例,这里显得很不简洁,远没有设置参数的方法简单.如果单纯的只有普通数据提交,建议不要用 multipart/form-data 这种方式.\n\n        NSString *boundary = [NSString stringWithFormat:@\"Boundary+%08X%08X\", arc4random(), arc4random()];\n        NSMutableData *body = [NSMutableData data];\n            // 表单数据\n            NSMutableDictionary *param = [@{@\"email\":self->_email,@\"type\":self->_type,@\"clientType\":@\"1\"} mutableCopy];\n\n        [param enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {\n            NSMutableString *fieldStr = [NSMutableString string];\n            [fieldStr appendString:[NSString stringWithFormat:@\"–%@\\r\\n\", boundary]];\n            [fieldStr appendString:[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", key]];\n            [fieldStr appendString:[NSString stringWithFormat:@\"%@\", obj]];\n            [body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]];\n            [body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];\n        }];\n        // 结束部分\n        NSString *bottomStr = [NSString stringWithFormat:@\"-–%@–-\", boundary];\n        /**拼装成格式：\n         -–Boundary+72D4CD655314C423–-\n         */\n        [body appendData:[bottomStr dataUsingEncoding:NSUTF8StringEncoding]];\n\n        //[formData appendPartWithHeaders:@{@\"Content-Type\":[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\",boundary]} body:body];\n        //最后是用request来直接设置httpbody和content-type还是用AFMultipartFormData来设置,要看框架和具体实现,怎么方便怎么来.但是可以肯定的是,这里的httpBody肯定不能用params参数(字典的形式/或者序列化后的字典JSON字符串)来提交了.只能用方法给HttpBody复制Data.\n        \n        //补充:为何iOS开发或者安卓开发中可以直接给HttpBody添加Params来传值,是因为框架底层都对Params进行了处理,让它成为Data,是给框架使用者提供了方便.\n\n\n### 3.2 application/x-www-form-urlencoded (x-www-form-urlencoded)\n\n绝大部分浏览器的原生form表单提交形式就是这种形式,如果不设置 enctype 属性,那么最终就会以 application/x-www-form-urlencoded 方式提交数据.\n\n1.Content-Type: application/x-www-form-urlencoded\n2.提交的数据按照 key1=value1&key2=value2 的方式进行编码, key 和 value 都进行了 URL 转码,可以理解为一个string,但是是有&链接并且转码后的.\n3.不支持文件类型数据的提交,只支持键值对的形式提交.\n\n    POST http://www.example.com HTTP/1.1\n    Content-Type: application/x-www-form-urlencoded;charset=utf-8\n    \n    title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3\n\n### 3.3 application/json (row的一种类型)\n\n这种就是最常见的POST请求提交的JSON数据.\n\n1.Content-Type: application/json;charset=utf-8\n2.JSON序列化后的string数据\n\n    POST http://www.example.com HTTP/1.1 \n    Content-Type: application/json;charset=utf-8\n\n    {\"title\":\"test\",\"sub\":[1,2,3]}\n\n### 3.4 application/text/xml (row的一种类型)\n\n这种就是最常见的POST请求提交的text/xml文本格式数据.\n\n1.Content-Type: text/xml\n2.text/xml标签格式的数据 \n(由于text/xml标签格式的数据书写麻烦,且JSON序列化的简单易用,导致这种方法逐渐被摒弃)\n\n\n    POST http://www.example.com HTTP/1.1 \n    Content-Type: text/xml\n    \n    <?xml version=\"1.0\"?>\n    <methodCall>\n        <methodName>examples.getStateName</methodName>\n        <params>\n            <param>\n                <value><i4>41</i4></value>\n            </param>\n        </params>\n    </methodCall>\n\n\n### 3.5 其他内容 (row的其他类型 + binary类型)\n\n1.上述的3.3和3.4的Content-type同属于row类型,row就是相当于给你一个文本框,你可以在里面写约定的固定格式的内容,然后把约定好的固定格式的内容提交,常见的如下几种:\n\nText\nText(text/plain)\nJSON(application/json)      ----->  [对应上述3.3]\nJavascript(application/javascript)\nXML(application/xml)\nXML(text/xml)               ----->  [对应上述3.4]\nHTML(text/html)\n\n其他几个内容大体上和3.3以及3.4相同,具体肯定也略有差异,在此不做赘述.\n\n2.关于binary类型,其实相当于Content-Type:application/octet-stream,可以上传二进制数据,通常用来上传文件,由于没有键值,所以一次只能上传一个文件.它的特性决定了它使用不够普及,到目前为止我还没用过这种类型的上传方式.\n\n\n## 4.综述\n\n这篇文章的意义在于,以后跟服务端对接口的时候,直接问body体构建类型是form-data/x-www-form-urlencoded/row/binary这四种中的哪一种类型,既显得专业,又降低了交流成本.\n\n从上面的内容可以看出,目前最通用话的应该是3.3这种类型,因为好处理,其他类型都在格式上有强烈的要求和限制,稍不注意就会犯拼写的格式错误,而提交不了数据,访问不了服务器接口.此外JSON的序列化和反序列化的普及,又方便了这里的数据通信,各大网络请求框架不论客户端网页端都毫无疑问都支持JSON序列化,从接口的通用性来说,大多数人还是会选择3.3这种类型.\n\n\n其次就是3.2这种类型.此外3.2这种类型和GET请求有着很大的相似性,现在大部分的网络请求框架的处理表现形式会给我们在这点的区分上有很大的迷惑性,下面我会讲它们的具体差异.\n\n3.2这种类型有点像GET请求在URL加?加key=value&key=value,但是有着本质上的区别,因为GET请求的?key=value&key=value是追加在URL后面的,而3.2是要放到Body体里的,对于GET请求而言,它没有真正意义上的Body体,通用的网络框架对于GET请求需要追加的参数虽然外表也用Params来接收外部的变量,但是内部处理还是追加在URL后的,所以3.2这种情况和GET请求有着本质上的差别,虽然外在形式可能很接近.\n\n\n\n","updated":"2021-06-05T17:42:29.664Z","permalink":"http://yoursite.com/2018/07/18/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84POST%E8%AF%B7%E6%B1%82%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F%E5%AF%B9%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%BD%B1%E5%93%8D/","categories":[]},{"title":"产品入门基本方法论","date":"2018-03-30T01:55:42.000Z","path":"2018/03/30/产品入门基本方法论/","text":"不要从结果去导向目的 不要由自己臆想做产品 产品不能直观表达是没思考够 谈产品时，聊产品，不聊技术 维度过多是思考不全，抽象不够或标准不对 一定要理解他人，要理解社会，要理解世界","raw":"---\ntitle: 产品入门基本方法论\ndate: 2018-03-30 09:55:42\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n\n- 不要从结果去导向目的\n\n- 不要由自己臆想做产品\n\n- 产品不能直观表达是没思考够\n\n- 谈产品时，聊产品，不聊技术\n\n- 维度过多是思考不全，抽象不够或标准不对\n\n- 一定要理解他人，要理解社会，要理解世界\n\n\n\n","updated":"2021-06-05T19:10:05.559Z","permalink":"http://yoursite.com/2018/03/30/%E4%BA%A7%E5%93%81%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E8%AE%BA/","categories":[]},{"title":"对于malloc、alloc、calloc、realloc的区别浅显的理解","date":"2018-03-07T04:41:15.000Z","path":"2018/03/07/对于malloc、alloc、calloc、realloc的区别浅显的理解/","text":"总述: 内存区域可分为栈,堆,静态存储区和常量存储区,对于常见的局部变量,函数形参,临时变量都是在栈上获得内存的,它们的获取方式都是通过编译器直接执行. 而利用指针来管理内存的时候,可以更加自由的像汇编一样处理内存的地址, C 标准函数库提供了很多函数来实现对堆上内存的管理,从开辟内存空间到释放内存空间都有相应的函数,这些函数都包含在头文件 stdlib.h 中,其中有几个特别重要的函数需要做区分和了解,它们分别是: malloc、alloc、calloc、realloc 以及 free,而对 malloc 和 free 的具体内容分析请移步C语言 malloc 和 free.这些函数之间的细微差别在于对内存的管理的细节和操作不同. 从函数名的字面上理解:这几个函数都带 alloc 也就是 allocate ,分配的意思. calloc() 是”分配内存给多个对象”, malloc() 是”分配内存给一个对象”, realloc() 是”重新分配内存”. 泛泛理解calloc()void *calloc(size_t nobj, size_t size); 分配足够的内存给nobj个大小为size的对象组成的数组,并返回指向所分配区域的第一个字节的指针;若内存不够,则返回NULL.该空间的初始化大小为0字节. 举例: char *p = (char *) calloc(100,sizeof(char)); malloc()void *malloc(size_t size); 分配足够的内存给大小为size的对象,并返回指向所分配区域的第一个字节的指针;若内存不够,则返回NULL.不对分配的空间进行初始化. 举例: char *p = (char *)malloc(sizeof(char)); realloc()void *realloc(void *p, size_t size); 将p所指向的对象的大小改为size个字节.如果新分配的内存比原内存大,那么原内存的内容保持不变,增加的空间不进行初始化.如果新分配的内存比原内存小,那么新内存保持原内存的内容,增加的空间不进行初始化.返回指向新分配空间的指针;若内存不够,则返回NULL,原p指向的内存区不变. 举列: char *p = (char *)malloc(sizeof(char)); p = (char *)realloc(p, 256); alloc()alloc 的调用序列与 malloc 相同,与 malloc 不同的是 alloc 在当前的函数的栈帧上分配存储空间,而不是在堆中.这样做的好处是:函数返回时,自动释放它所使用的栈帧,所以不必再为释放空间而费心.也就是说不必要担心操作它的释放问题.同样这样处理的其缺点也很明显:某些系统在函数已被调用后不能增加栈帧长度,于是也就不能支持 alloc 函数.尽管如此,很多软件包还是使用 alloc 函数,也有很多系统支持它. 注意事项: 通过 malloc 函数得到的堆内存必须是要由 memset 函数来初始化的. malloc函数分配得到的内存空间是未初始化的,因此,一般在使用该内存空间时,要调用另一个函数 memset 来将其初始化为全0, memset 函数的声明如下: void memset (void p,int c,int n); 举例: int * p = NULL; p=(int *)malloc(sizeof(int)); if(p==NULL) printf(“Can’t get memory!\\n”); memset(p,0,siezeof(int)); 使用 malloc 函数分匹配空间堆空间在程序结束之前必须释放. 从堆上获得的内存空间在程序结束以后,系统不会将其自动释放,需要程序员来自己管理.一个程序结束时,必须保证所有从堆上获得的内存空间已被安全释放,否则,会导致内存泄露. 可以用 free 函数来释放. calloc函数的分配的内存也需要自行释放. calloc 函数的功能与 malloc 函数的功能相似,都是从堆分配内存,它与 malloc 函数的一个显著不同时是, calloc 函数得到的内存空间是经过初始化的,其内容全为0. calloc 函数适合为数组申请空间,可以将 size 设置为数组元素的空间长度,将 n 设置为数组的容量. 如果要使用 realloc 函数分配的内存,必须使用 memset 函数对其内存初始化. realloc 函数的功能比 malloc 函数和 calloc 函数的功能更强大,可以实现内存分配和内存释放的功能. realloc 可以对给定的指针所指的空间进行扩大或者缩小,无论是扩张或是缩小,原有内存的中内容将保持不变.其中对于缩小来说,则被缩小的那一部分的内容会丢失. realloc 并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反 realloc 返回的指针很可能指向一个新的地址. 举例: p = (int *) realloc(p, sizeof(int) *15); //必须将realloc返回的值,重新赋给P int* p = (int *) realloc(0,sizeof(int) * 10); //分配一个全新的内存空间,因为当传一个空指针(0)给realloc时,此时的realloc的作用完全等同于malloc. 完全等同于:int* p = (int *)malloc(sizeof(int) * 10);","raw":"---\ntitle: 对于malloc、alloc、calloc、realloc的区别浅显的理解\ndate: 2018-03-07 12:41:15\ncategories:\ntoc: ture\ntags:\n     - C\n     - malloc()\n     - alloc()\n     - calloc()\n     - realloc()\n---\n\n\n## 总述:\n \n> 内存区域可分为栈,堆,静态存储区和常量存储区,对于常见的局部变量,函数形参,临时变量都是在栈上获得内存的,它们的获取方式都是通过编译器直接执行.\n\n> 而利用指针来管理内存的时候,可以更加自由的像汇编一样处理内存的地址, C 标准函数库提供了很多函数来实现对堆上内存的管理,从开辟内存空间到释放内存空间都有相应的函数,这些函数都包含在头文件 stdlib.h 中,其中有几个特别重要的函数需要做区分和了解,它们分别是: malloc、alloc、calloc、realloc 以及 free,而对 malloc 和 free 的具体内容分析请移步[C语言 malloc 和 free](http://www.yanceymichael.com/2018/02/03/C%E8%AF%AD%E8%A8%80-malloc-%E5%92%8C-free/).这些函数之间的细微差别在于对内存的管理的细节和操作不同.\n\n> 从函数名的字面上理解:这几个函数都带 alloc 也就是 allocate ,分配的意思. calloc() 是\"分配内存给多个对象\", malloc() 是\"分配内存给一个对象\", realloc() 是\"重新分配内存\".\n\n<!--more-->\n\n## 泛泛理解\n\n### calloc()\n\n    void *calloc(size_t nobj, size_t size);\n\n分配足够的内存给nobj个大小为size的对象组成的数组,并返回指向所分配区域的第一个字节的指针;\n若内存不够,则返回NULL.该空间的初始化大小为0字节.\n\n举例:\n\n    char *p = (char *) calloc(100,sizeof(char));\n\n### malloc()\n\n    void *malloc(size_t size);\n\n分配足够的内存给大小为size的对象,并返回指向所分配区域的第一个字节的指针;\n若内存不够,则返回NULL.不对分配的空间进行初始化.\n\n举例:\n\n    char *p = (char *)malloc(sizeof(char));\n\n### realloc()\n    \n    void *realloc(void *p, size_t size);\n\n将p所指向的对象的大小改为size个字节.\n如果新分配的内存比原内存大,那么原内存的内容保持不变,增加的空间不进行初始化.\n如果新分配的内存比原内存小,那么新内存保持原内存的内容,增加的空间不进行初始化.\n返回指向新分配空间的指针;若内存不够,则返回NULL,原p指向的内存区不变.\n\n举列:\n\n    char *p = (char *)malloc(sizeof(char));\n    p = (char *)realloc(p, 256);\n\n\n### alloc()\n\nalloc 的调用序列与 malloc 相同,与 malloc 不同的是 alloc 在当前的函数的栈帧上分配存储空间,而不是在堆中.这样做的好处是:函数返回时,自动释放它所使用的栈帧,所以不必再为释放空间而费心.也就是说不必要担心操作它的释放问题.同样这样处理的其缺点也很明显:某些系统在函数已被调用后不能增加栈帧长度,于是也就不能支持 alloc 函数.尽管如此,很多软件包还是使用 alloc 函数,也有很多系统支持它.    \n        \n## 注意事项:\n- 通过 malloc 函数得到的堆内存必须是要由 memset 函数来初始化的.\n\n    malloc函数分配得到的内存空间是未初始化的,因此,一般在使用该内存空间时,要调用另一个函数 memset 来将其初始化为全0, memset 函数的声明如下: void * memset (void *p,int c,int n);\n   \n    \n    举例: \n    \n    \n        int * p = NULL;\n        \n        p=(int *)malloc(sizeof(int));\n        \n        if(p==NULL)\n        \n        printf(“Can’t get memory!\\n”);\n        \n        memset(p,0,siezeof(int));\n    \n    \n- 使用 malloc 函数分匹配空间堆空间在程序结束之前必须释放.\n\n    从堆上获得的内存空间在程序结束以后,系统不会将其自动释放,需要程序员来自己管理.一个程序结束时,必须保证所有从堆上获得的内存空间已被安全释放,否则,会导致内存泄露.\n    可以用 free 函数来释放.\n    \n- calloc函数的分配的内存也需要自行释放.\n\n    calloc 函数的功能与 malloc 函数的功能相似,都是从堆分配内存,它与 malloc 函数的一个显著不同时是, calloc 函数得到的内存空间是经过初始化的,其内容全为0. calloc 函数适合为数组申请空间,可以将 size 设置为数组元素的空间长度,将 n 设置为数组的容量.\n    \n- 如果要使用 realloc 函数分配的内存,必须使用 memset 函数对其内存初始化.\n\n    realloc 函数的功能比 malloc 函数和 calloc 函数的功能更强大,可以实现内存分配和内存释放的功能. realloc 可以对给定的指针所指的空间进行扩大或者缩小,无论是扩张或是缩小,原有内存的中内容将保持不变.其中对于缩小来说,则被缩小的那一部分的内容会丢失. realloc 并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反 realloc 返回的指针很可能指向一个新的地址.\n    \n    举例:\n    \n        p = (int *) realloc(p, sizeof(int) *15); \n        //必须将realloc返回的值,重新赋给P\n        \n        int* p = (int *) realloc(0,sizeof(int) * 10); \n        //分配一个全新的内存空间,因为当传一个空指针(0)给realloc时,此时的realloc的作用完全等同于malloc. 完全等同于:int* p = (int *)malloc(sizeof(int) * 10);\n        \n        \n\n        \n\n\n\n\n","updated":"2018-03-19T02:24:17.519Z","permalink":"http://yoursite.com/2018/03/07/%E5%AF%B9%E4%BA%8Emalloc%E3%80%81alloc%E3%80%81calloc%E3%80%81realloc%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%85%E6%98%BE%E7%9A%84%E7%90%86%E8%A7%A3/","categories":[]},{"title":"C语言 malloc 和 free","date":"2018-02-03T07:01:44.000Z","path":"2018/02/03/C语言-malloc-和-free/","text":"malloc()和free()的基本概念以及基本用法malloc()malloc() 的函数原型原型： extern void *malloc(unsigned int num_bytes)。 头文件： #include &lt;malloc.h&gt; 或 #include &lt;alloc.h&gt; (注意：alloc.h 与 malloc.h 的内容是完全一致的。)。 功能：分配长度为 num_bytes 字节的内存块。 当内存不再使用时，应使用free()函数将内存块释放。 举例： #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; int main() &#123; char *p; p = (char *)malloc(100); if(p) printf(&quot;Memory Allocated at: %x/n&quot;,p); else printf(&quot;Not Enough Memory!/n&quot;); free(p); return 0; &#125; malloc() 的函数声明(函数原型)void *malloc(int size); malloc 向系统申请分配指定 size 个字节的内存空间。返回类型是 void 类型。void 表示未确定类型的指针，如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。这个在 MSDN 上可以找到相关的解释，具体内容如下： malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small. malloc 与 new 的不同点从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。 int *p; p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int); 或： int* parr; parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100; 而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。 int* p; p = (int *) malloc (sizeof(int)); 第一、malloc 函数返回的是 void 类型，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，报错：“不能将 void 赋值给 int 类型变量”。所以必须通过 (int ) 来将强制转换。 第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成： int* p = (int *) malloc (1); 代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。 malloc 也可以达到 new [] 的效果，申请出一段连续的内存，方法无非是指定你所需要内存大小。 比如想分配100个int类型的空间： int* p = (int *) malloc ( sizeof(int) * 100 ); //分配可以放得下100个整数的内存空间。 另外有一点不能直接看出的区别是，malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。 除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。 malloc(0) 搞事情在C语法中, malloc(0)无疑是对的，并且也一定是分配了对应的内存空间，但是有一点可能理解有点困难，那就是分配了内存空间为0的内存大小，内存空间大小是0的时候由于无法存储内容，导致无法被使用，对于malloc而言也就是返回了一个让你无法使用的指针； 在操作系统的层面，由于操作系统在内存管理的时候会将内存分成2部分：棧内存和堆内存，棧和堆除了数据结构上的区别之外，对于棧而言，棧有自己的机器指令而堆没有，而malloc分配的是堆内存，由于堆没有自己的机器指令，所以要由系统自己写算法来管理这部分内存，而最常见的管理是用链表来管理，在每片被分配的内存前加一个表头，里面存储了被分配的内存的起始位置和大小，而malloc函数返回的指针就是表头里的起始指针，这个地址由一系列的算法获得，通常而言不会分配0空间大小，一旦内存分配成功就会返回一个有效的指针，对于分配0空间来说，算法已经算出可用内存的起始地址，但是你占用0空间，所以对那个指针操作就是错误的，操作系统一般不知道其终止地址，因为有占用大小就可以推出终止地址，还有就是即使分配0空间也要释放它，其实是释放的链表结点。还有，返回的指针是可用地址的起始地址，可用大小是固定的，在VC6下是56字节，这个大小可能就是链表的大小。既然malloc另外分配内存来维护该内存块（算法链表占用大小），也就是说分配来用于维护该内存块的内存的大小也是有限的，那么到底是多少呢？ #include int main() &#123; char *ptr; ptr = malloc(0*sizeof(char)); if (NULL == ptr) printf(&quot;got a NULL pointer\\n&quot;); else &#123; printf(&quot;got a Valid pointer\\n&quot;); // 有10个a，另外有一个字节用于保存&apos;&apos;\\0&apos; strcpy(ptr,&quot;aaaaaaaaaa&quot;); //printf(&quot;the value at %X is:%c\\n&quot;,ptr,*ptr); printf(&quot;the string at %x is :%s\\n&quot;,ptr, ptr); // free(ptr); &#125; return 0; &#125; 此时没有把 free（ptr）编译进来，同样会发生异常，程序输出很多个10个a,如果把 free(ptr); 编译进来，就会发生运行错误！ malloc() 的总结malloc()函数其实就在内存中找一片指定大小的空间，然后将这个空间的首地址范围给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看 malloc() 函数中参数 size 的具体内容。我们这里 malloc 分配的内存空间在逻辑上连续的，而在物理上可以连续也可以不连续。对于我们程序员来说，我们关注的是逻辑上的连续，因为操作系统会帮我们安排内存分配，所以我们使用起来就可以当做是连续的。 那么在理解了malloc的基本内容之后，对于malloc、alloc、calloc、realloc的区别浅显的理解，请移步：对于malloc、alloc、calloc、realloc的区别浅显的理解. free()malloc, alloc, free 是 c 定义的一组内存管理的 API 函数，free 可以释放 calloc, malloc, realloc 动态分配的空间，当你调用 malloc、alloc 分配内存时，不仅仅是从堆里面分配得到了可用内存，实际上内存管理子系统还会维护了内存列表（你定义的普通指针不会出现这个列表中）。 free() 的函数原型而对于使用 new, GlobalAlloc 之类的方式分配的内存可不可以使用 free 呢。我的回答是，尽量不要，大部分情况都会带来风险，这里面涉及 new, malloc, GlobalAlloc, HeapAlloc, LocalAlloc，VirtualAlloc 等函数的区别。 那么对于自己定义的普通指针呢，首先要说一下，你要释放的不是你定义的指针，而是你定义的指针指向的空间。至于你定义的普通指针是不是可以通过 free 释放，这个要看情况。如果你定义的指针指向动态分配的地址空间，则可以使用 free 释放指针指向的这段空间；否则，就不能使用 free 释放指针指向的空间。 下面举个例子： current = head while (current != null ) &#123; free(current); current = current-&gt;next; &#125; printf(“Bye!\\n”); head 是一个指向一个链表头元素的指针，这段代码的作用是释放这个链表 malloc 的内存。current 既然已经 free 了，怎么还可以使用 current = current-&gt;next 呢，而且并没有报错！ 上面示例代码的错误原因： 1.free只是释放了malloc所申请的内存，并没有改变指针的值。 2.由于指针所指向的内存空间已经被释放，所以其他代码有机会改写其中的内容，相当于该指针从此指向了自己无法控制的区域，也成为野指针（野指针指指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为NULL避免）。 3.为了避免错误，所以最好在free之后，使指针指向NULL。","raw":"---\ntitle: C语言 malloc 和 free\ndate: 2018-02-03 15:01:44\ncategories:\ntoc: false\ntags:\n     - C\n     - malloc()\n     - free()\n---\n\n## malloc()和free()的基本概念以及基本用法\n\n### malloc()\n\n#### malloc() 的函数原型\n\n原型： extern void *malloc(unsigned int num_bytes)。\n\n头文件： #include <malloc.h> 或 #include <alloc.h> (注意：alloc.h 与 malloc.h 的内容是完全一致的。)。\n\n功能：分配长度为 num_bytes 字节的内存块。\n\n当内存不再使用时，应使用free()函数将内存块释放。\n\n举例：\n\n    #include<stdio.h>  \n    #include<malloc.h>  \n    int main()  \n    {  \n        char *p;  \n        p = (char *)malloc(100);  \n        if(p)  \n            printf(\"Memory Allocated at: %x/n\",p);  \n        else  \n            printf(\"Not Enough Memory!/n\");  \n        free(p);  \n        return 0;  \n    } \n    \n<!--more-->\n    \n#### malloc() 的函数声明(函数原型)\n\nvoid *malloc(int size);\n\nmalloc 向系统申请分配指定 size 个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的指针，如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。这个在 MSDN 上可以找到相关的解释，具体内容如下：\n\nmalloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small.\n\n#### malloc 与 new 的不同点\n\n从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。\n\n    int *p;\n    \n    p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);\n    \n    或：\n    \n    int* parr;\n    \n    parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;\n    　　\n    　　\n而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。\n\n    int* p;\n    \n    p = (int *) malloc (sizeof(int));\n\n第一、malloc 函数返回的是 void * 类型，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。\n\n第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成：\n\n    int* p = (int *) malloc (1);\n\n代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。\n\nmalloc 也可以达到 new [] 的效果，申请出一段连续的内存，方法无非是指定你所需要内存大小。\n\n比如想分配100个int类型的空间：\n\n    int* p = (int *) malloc ( sizeof(int) * 100 ); //分配可以放得下100个整数的内存空间。\n\n\n另外有一点不能直接看出的区别是，malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。\n\n除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。\n\n#### malloc(0) 搞事情\n\n在C语法中, malloc(0)无疑是对的，并且也一定是分配了对应的内存空间，但是有一点可能理解有点困难，那就是分配了内存空间为0的内存大小，内存空间大小是0的时候由于无法存储内容，导致无法被使用，对于malloc而言也就是返回了一个让你无法使用的指针；\n\n在操作系统的层面，由于操作系统在内存管理的时候会将内存分成2部分：棧内存和堆内存，棧和堆除了数据结构上的区别之外，对于棧而言，棧有自己的机器指令而堆没有，而malloc分配的是堆内存，由于堆没有自己的机器指令，所以要由系统自己写算法来管理这部分内存，而最常见的管理是用链表来管理，在每片被分配的内存前加一个表头，里面存储了被分配的内存的起始位置和大小，而malloc函数返回的指针就是表头里的起始指针，这个地址由一系列的算法获得，通常而言不会分配0空间大小，一旦内存分配成功就会返回一个有效的指针，对于分配0空间来说，算法已经算出可用内存的起始地址，但是你占用0空间，所以对那个指针操作就是错误的，操作系统一般不知道其终止地址，因为有占用大小就可以推出终止地址，还有就是即使分配0空间也要释放它，其实是释放的链表结点。还有，返回的指针是可用地址的起始地址，可用大小是固定的，在VC6下是56字节，这个大小可能就是链表的大小。既然malloc另外分配内存来维护该内存块（算法链表占用大小），也就是说分配来用于维护该内存块的内存的大小也是有限的，那么到底是多少呢？\n\n\n    #include \n    \n    int main()\n    {\n        char *ptr;\n        ptr = malloc(0*sizeof(char));\n \n        if (NULL == ptr)\n        printf(\"got a NULL pointer\\n\");\n        else \n        {\n            printf(\"got a Valid pointer\\n\");\n            // 有10个a，另外有一个字节用于保存''\\0'\n            strcpy(ptr,\"aaaaaaaaaa\"); \n            //printf(\"the value at %X is:%c\\n\",ptr,*ptr);\n            printf(\"the string at %x is :%s\\n\",ptr, ptr);\n            // free(ptr);\n        }\n        return 0;\n    }\n\n\n此时没有把 free（ptr）编译进来，同样会发生异常，程序输出很多个10个a,如果把 free(ptr); 编译进来，就会发生运行错误！\n\n\n#### malloc() 的总结\n\nmalloc()函数其实就在内存中找一片指定大小的空间，然后将这个空间的首地址范围给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看 malloc() 函数中参数 size 的具体内容。我们这里 malloc 分配的内存空间在逻辑上连续的，而在物理上可以连续也可以不连续。对于我们程序员来说，我们关注的是逻辑上的连续，因为操作系统会帮我们安排内存分配，所以我们使用起来就可以当做是连续的。\n\n那么在理解了malloc的基本内容之后，对于malloc、alloc、calloc、realloc的区别浅显的理解，请移步：[对于malloc、alloc、calloc、realloc的区别浅显的理解](http://www.yanceymichael.com/2018/03/07/%E5%AF%B9%E4%BA%8Emalloc%E3%80%81alloc%E3%80%81calloc%E3%80%81realloc%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%85%E6%98%BE%E7%9A%84%E7%90%86%E8%A7%A3/).\n\n\n### free() \n\nmalloc, alloc, free 是 c 定义的一组内存管理的 API 函数，free 可以释放 calloc, malloc, realloc 动态分配的空间，当你调用 malloc、alloc 分配内存时，不仅仅是从堆里面分配得到了可用内存，实际上内存管理子系统还会维护了内存列表（你定义的普通指针不会出现这个列表中）。\n\n#### free() 的函数原型\n\n而对于使用 new, GlobalAlloc 之类的方式分配的内存可不可以使用 free 呢。我的回答是，尽量不要，大部分情况都会带来风险，这里面涉及 new, malloc, GlobalAlloc, HeapAlloc, LocalAlloc，VirtualAlloc 等函数的区别。\n\n那么对于自己定义的普通指针呢，首先要说一下，你要释放的不是你定义的指针，而是你定义的指针指向的空间。至于你定义的普通指针是不是可以通过 free 释放，这个要看情况。如果你定义的指针指向动态分配的地址空间，则可以使用 free 释放指针指向的这段空间；否则，就不能使用 free 释放指针指向的空间。\n\n下面举个例子：\n\n    current = head\n    while (current != null )\n    {\n    free(current);\n    current = current->next;\n    }\n    printf(“Bye!\\n”);   \n\nhead 是一个指向一个链表头元素的指针，这段代码的作用是释放这个链表 malloc 的内存。\ncurrent 既然已经 free 了，怎么还可以使用 current = current->next 呢，而且并没有报错！\n\n上面示例代码的错误原因：\n\n1.free只是释放了malloc所申请的内存，并没有改变指针的值。\n\n2.由于指针所指向的内存空间已经被释放，所以其他代码有机会改写其中的内容，相当于该指针从此指向了自己无法控制的区域，也成为野指针（野指针指指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为NULL避免）。\n\n3.为了避免错误，所以最好在free之后，使指针指向NULL。\n\n","updated":"2021-06-05T17:43:14.869Z","permalink":"http://yoursite.com/2018/02/03/C%E8%AF%AD%E8%A8%80-malloc-%E5%92%8C-free/","categories":[]},{"title":"iOS自动布局高级用法以及代码约束纪要","date":"2018-02-03T03:48:05.000Z","path":"2018/02/03/iOS自动布局高级用法以及代码约束纪要/","text":"现阶段对于自动布局来说,有一些很成熟的第三方框架,其中较为优秀的是 OC 有: SnapKit/Masonry 框架等. Swift 有: SnapKit/SnapKit 框架等.其本质上都是对 Apple 的 autolayout 的二次封装.提到 autolayout 就不得不提 autoresizing. 对于 autoresizing 需要注意的是 storyboard 中设置的约束和手码中设置的约束是相反的. autoresizing 所体现的 autoresizingMasks 属性的枚举都是 flexible 可“伸缩”的, autoresizingMasks 的枚举一共有7个值:无/宽可伸缩/高可伸缩/左间距可伸缩/右间距可伸缩/上间距可伸缩/下间距可伸缩,对应的分别是: UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5 每个枚举值都是位移枚举，可以在一行代码中传多个值。 有一个较为核心的思想提炼出来的一个公式,任何两个控件间的约束都可以通过这个公式算出: obj1.property1 =（obj2.property2 * multiplier）+ constant value multiplier 和 constant 就是向量系数和偏移量. 还有为了避免和系统生成的自动伸缩的约束不冲突一般加上这句代码: view.translatesAutoresizingMaskIntoConstraints = NO; translatesAutoresizingMaskIntoConstraints 属性系统默认这个属性是 YES. 约束改变添加动画注意事项: 由于约束的改变是瞬时操作,这和改变frame的动画的改变存在明显的差异,这里要把更新约束的代码放到动画的block里是无效的.从而必须要把约束写在外面,然后block里包裹 layoutIfNeed. 错误: [UIView animateWithDuration:2.0 animations:^&#123; NSLayoutConstraint *width = [_constaints firstObject]; width.constant = 200; &#125;]; 正确: [UIView animateWithDuration:2.0 animations:^&#123; [self.view layoutIfNeeded]; &#125;];","raw":"---\ntitle: iOS自动布局高级用法以及代码约束纪要\ndate: 2018-02-03 11:48:05\ncategories:\ntoc: false\ntags:\n     - OC\n     - autolayout\n     - autoresizing\n     - 约束改变添加动画注意事项\n---\n\n现阶段对于自动布局来说,有一些很成熟的第三方框架,其中较为优秀的是 OC 有: **SnapKit/Masonry** 框架等. Swift 有: **SnapKit/SnapKit** 框架等.其本质上都是对 Apple 的 **autolayout** 的二次封装.提到 **autolayout** 就不得不提 **autoresizing**.\n\n对于 **autoresizing** 需要注意的是 storyboard 中设置的约束和手码中设置的约束是相反的.\n\n**autoresizing** 所体现的 **autoresizingMasks** 属性的枚举都是 flexible 可“伸缩”的, **autoresizingMasks** 的枚举一共有7个值:无/宽可伸缩/高可伸缩/左间距可伸缩/右间距可伸缩/上间距可伸缩/下间距可伸缩,对应的分别是:\n\n     UIViewAutoresizingNone                 = 0,\n\n     UIViewAutoresizingFlexibleWidth        = 1 << 1,\n\n     UIViewAutoresizingFlexibleHeight       = 1 << 4,\n\n     UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n\n     UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n\n     UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n\n     UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n     \n\n每个枚举值都是位移枚举，可以在一行代码中传多个值。\n\n有一个较为核心的思想提炼出来的一个公式,任何两个控件间的约束都可以通过这个公式算出:\n\n    obj1.property1 =（obj2.property2 * multiplier）+ constant value\n\n**multiplier** 和 **constant** 就是向量系数和偏移量.\n\n还有为了避免和系统生成的自动伸缩的约束不冲突一般加上这句代码:\n\n    view.translatesAutoresizingMaskIntoConstraints = NO;\n\n\ntranslatesAutoresizingMaskIntoConstraints 属性系统默认这个属性是 YES.\n\n**约束改变添加动画注意事项:**\n\n由于约束的改变是瞬时操作,这和改变frame的动画的改变存在明显的差异,这里要把更新约束的代码放到动画的block里是无效的.从而必须要把约束写在外面,然后block里包裹 layoutIfNeed.\n\n错误:\n\n    [UIView animateWithDuration:2.0 animations:^{\n        NSLayoutConstraint *width = [_constaints firstObject];\n        width.constant = 200;\n    }];\n    \n      \n**正确:**\n\n    [UIView animateWithDuration:2.0 animations:^{\n        [self.view layoutIfNeeded];\n    }];\n\n\n\n","updated":"2018-04-20T07:17:28.528Z","permalink":"http://yoursite.com/2018/02/03/iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%BA%A6%E6%9D%9F%E7%BA%AA%E8%A6%81/","categories":[]},{"title":"关于运行时的损耗和内存管理在几种语言中的差异纪要","date":"2018-01-31T04:33:03.000Z","path":"2018/01/31/关于运行时的损耗和内存管理在几种语言中的差异纪要/","text":"OC 和 Swift 运行时的损耗主要来自于内存管理中对对象的计数,一个对象会不停地进行 retain 和 release, runtime 必须一直 observe 每一个对象的 retain count,当 retain count 达到 0 的时候就释放这个对象.而 C 就没有这个问题,因为 C 没有对象,不需要对对象进行生命周期的内存维护,没有运行时的损耗. 目前主流的内存管理方式分三种: 手动: C 语言的 malloc 库,特点就是无运行时损耗,但不好控制释放内存的时机.关于 C 语言 malloc 和 free 初步了解,移步:C语言 malloc 和 free. 半自动: Objective-C 和 Swift 的 MRC/ARC,有运行时损耗,但基本上可以让程序员不用去考虑内存管理的问题. 自动的: Java/Go 的 GC.基本上同上,但需要在某个时间点去停止所有线程,释放内存的时机不可控. Objective-C 的 MRC 还需要手动去写 retain/release,在进化到 ARC 之后,除了需要在类成员变量声明的时候,显式地声明是 weak/strong/retain/copy 就可以了, retain/release 的插入交给编译器即可, ARC 其实已经是实际上的自动化内存管理模式了. 而 Swift 在把指针抽象为引用类型,加入 Mutable/Immutable 的概念之后,就只需要偶尔写写 weak 就行了,唯一需要对于内存管理费心的就是 retain cycle 的问题,但也比之前省心很多了.而且随着 Swift 工具链的发展,这些问题都可以在编译期或者 Debug 时就暴露出来. 半自动的内存管理,实际上还有一种,就是 Rust 的 OwnerShip ,这种方式其实是 MRC/ARC 的一种延续,但 MRC/ARC 内存释放的时机还是需要在运行时才能知道,而 Rust 可以在编译期就解析出什么时候可以释放掉内存,从而省略掉 retain/release 的存在,也没必要专门跑一个 runtime 去监测对象的引用计数.从而达到比 ARC 更高的运行效率.仔细思考一下这种自动化的内存管理模式,其实都是在把指针分类,加上 context(上下文),抽象出来,暴露给编译器更多与关于指针的信息,而不是单纯的一个内存地址,从而让编译器可以分析释放对象的时机. Rust 也不例外,既然要达到比 ARC 更高的运行效率,那就必然要提供给编译器更多的指针信息,以此提供给编译器更多的优化空间,因此在指针声明和传递时都需要显式地声明所有权,代码量也会相应地增多,对于程序员的要求也会更高. 虽然写起来比 ARC 更麻烦一点,但也比 C 那种原始的方式简单很多,提供给了 Rust, Swift 这些”现代编程语言”编写底层程序的可能性.","raw":"---\ntitle: 关于运行时的损耗和内存管理在几种语言中的差异纪要\ndate: 2018-01-31 12:33:03\ncategories:\ntoc: false\ntags:\n     - 内存管理\n---\n\nOC 和 Swift 运行时的损耗主要来自于内存管理中对对象的计数,一个对象会不停地进行 retain 和 release, runtime 必须一直 observe 每一个对象的 retain count,当 retain count 达到 0 的时候就释放这个对象.而 C 就没有这个问题,因为 C 没有对象,不需要对对象进行生命周期的内存维护,没有运行时的损耗.\n\n目前主流的内存管理方式分三种:\n\n手动: C 语言的 malloc 库,特点就是无运行时损耗,但不好控制释放内存的时机.关于 C 语言 malloc 和 free 初步了解,移步:[C语言 malloc 和 free](http://www.yanceymichael.com/2018/02/03/C%E8%AF%AD%E8%A8%80-malloc-%E5%92%8C-free/).\n\n半自动: Objective-C 和 Swift 的 MRC/ARC,有运行时损耗,但基本上可以让程序员不用去考虑内存管理的问题.\n\n自动的: Java/Go 的 GC.基本上同上,但需要在某个时间点去停止所有线程,释放内存的时机不可控.\n\nObjective-C 的 MRC 还需要手动去写 retain/release,在进化到 ARC 之后,除了需要在类成员变量声明的时候,显式地声明是 weak/strong/retain/copy 就可以了, retain/release 的插入交给编译器即可, ARC 其实已经是实际上的自动化内存管理模式了.\n\n而 Swift 在把指针抽象为引用类型,加入 Mutable/Immutable 的概念之后,就只需要偶尔写写 weak 就行了,唯一需要对于内存管理费心的就是 retain cycle 的问题,但也比之前省心很多了.而且随着 Swift 工具链的发展,这些问题都可以在编译期或者 Debug 时就暴露出来.\n\n<!--more-->\n\n半自动的内存管理,实际上还有一种,就是 Rust 的 OwnerShip ,这种方式其实是 MRC/ARC 的一种延续,但 MRC/ARC 内存释放的时机还是需要在运行时才能知道,而 Rust 可以在编译期就解析出什么时候可以释放掉内存,从而省略掉 retain/release 的存在,也没必要专门跑一个 runtime 去监测对象的引用计数.从而达到比 ARC 更高的运行效率.仔细思考一下这种自动化的内存管理模式,其实都是在把指针分类,加上 context(上下文),抽象出来,暴露给编译器更多与关于指针的信息,而不是单纯的一个内存地址,从而让编译器可以分析释放对象的时机.\n\nRust 也不例外,既然要达到比 ARC 更高的运行效率,那就必然要提供给编译器更多的指针信息,以此提供给编译器更多的优化空间,因此在指针声明和传递时都需要显式地声明所有权,代码量也会相应地增多,对于程序员的要求也会更高.\n\n虽然写起来比 ARC 更麻烦一点,但也比 C 那种原始的方式简单很多,提供给了 Rust, Swift 这些”现代编程语言”编写底层程序的可能性.\n\n\n","updated":"2018-02-04T02:43:29.860Z","permalink":"http://yoursite.com/2018/01/31/%E5%85%B3%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%8D%9F%E8%80%97%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9C%A8%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82%E7%BA%AA%E8%A6%81/","categories":[]},{"title":"SDWebImage如何支持https协议","date":"2018-01-18T07:03:00.000Z","path":"2018/01/18/SDWebImage如何支持https协议/","text":"大量的App现在都用优秀的图片处理框架 SDWebImage 来展示图片内容，由于现在 Apple 对 app 的安全管控开始越来越严格。 Apple 的做法是从管控开发者的角度来提升用户的安全度，普及 https 的措施一定会逐渐全面覆盖。 实际开发当中，我们的网络请求模块，除非 App 内部有下载资源的模块，不然我们很少会将自己的 App 内部的图片做特殊处理，在实际开发过程中，网络模块和 SDWebImage 联合起来才算一个完整的网络架构模块，而 SDWebImage 本身是有校验证书方法的，只不过内部没有具体的操作，也没有详细写，每个开发者可以根据具体业务需要根据实际情况来处理，所以对 SDWebImage 框架在哪里修改，在哪里改写来成功完成 https 的请求，就变成了一个事儿。 其实只要理解了SDWebImage框架的底层，以及几个关键类的作用，这个问题便不是问题： 对于 SDWebImage 框架下的 SDWebImageDownloaderOperation 这个类中的这个方法重写： - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler; 个人建议不要修改原框架的原文件，无破坏性无入侵式修改的话，对 SDWebImageDownloaderOperation 这个类写一个分类，然后重写上述方法，以下是具体重写内容。 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; else &#123; //改写方法 然后插入证书验证代码 do &#123; SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust]; NSCAssert(serverTrust != nil, @&quot;serverTrust is nil&quot;); if(nil == serverTrust) break; /* failed */ /** * 导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称 */ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;oss-ifeixiu-com&quot; ofType:@&quot;cer&quot;]; //自签名证书 NSData *caCert = [NSData dataWithContentsOfFile:cerPath]; NSCAssert(caCert != nil, @&quot;caCert is nil&quot;); if(nil == caCert) break; /* failed */ SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert); NSCAssert(caRef != nil, @&quot;caRef is nil&quot;); if(nil == caRef) break; /* failed */ //可以添加多张证书 NSArray *caArray = @[(__bridge id)(caRef)]; NSCAssert(caArray != nil, @&quot;caArray is nil&quot;); if(nil == caArray) break; /* failed */ //将读取的证书设置为服务端帧数的根证书 OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray); NSCAssert(errSecSuccess == status, @&quot;SecTrustSetAnchorCertificates failed&quot;); if(!(errSecSuccess == status)) break; /* failed */ SecTrustResultType result = - 1; //通过本地导入的证书来验证服务器的证书是否可信 status = SecTrustEvaluate(serverTrust, &amp;result); if(!(errSecSuccess == status)) break; /* failed */ debug_NSLog(@&quot;stutas:%d&quot;,(int)status); debug_NSLog(@&quot;Result: %d&quot;, result); BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed); if (allowConnect) &#123; debug_NSLog(@&quot;success&quot;); &#125;else &#123; debug_NSLog(@&quot;error&quot;); &#125; /* kSecTrustResultUnspecified and kSecTrustResultProceed are success */ if(!allowConnect) &#123; break; /* failed */ &#125; #if 0 /* Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success */ /* since the user will likely tap-through to see the dancing bunnies */ if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError) break; /* failed to trust cert (good in this case) */ #endif // The only good exit point debug_NSLog(@&quot;信任该证书&quot;); credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; disposition = NSURLSessionAuthChallengeUseCredential; &#125; while(0); &#125; &#125; else &#123; if (challenge.previousFailureCount == 0) &#123; if (self.credential) &#123; credential = self.credential; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125; &#125;","raw":"---\ntitle: SDWebImage如何支持https协议\ndate: 2018-01-18 15:03:00\ncategories:\ntoc: true\ntags:\n     - OC\n     - SDWebImage\n     - https\n---\n\n大量的App现在都用优秀的图片处理框架 SDWebImage 来展示图片内容，由于现在 Apple 对 app 的安全管控开始越来越严格。 Apple 的做法是从管控开发者的角度来提升用户的安全度，普及 https 的措施一定会逐渐全面覆盖。\n\n实际开发当中，我们的网络请求模块，除非 App 内部有下载资源的模块，不然我们很少会将自己的 App 内部的图片做特殊处理，在实际开发过程中，网络模块和 SDWebImage 联合起来才算一个完整的网络架构模块，而 SDWebImage 本身是有校验证书方法的，只不过内部没有具体的操作，也没有详细写，每个开发者可以根据具体业务需要根据实际情况来处理，所以对 SDWebImage 框架在哪里修改，在哪里改写来成功完成 https 的请求，就变成了一个事儿。\n\n其实只要理解了SDWebImage框架的底层，以及几个关键类的作用，这个问题便不是问题：\n\n对于 SDWebImage 框架下的 SDWebImageDownloaderOperation 这个类中的这个方法重写：\n\n    - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler;\n\n<!--more-->\n\n个人建议不要修改原框架的原文件，无破坏性无入侵式修改的话，对  SDWebImageDownloaderOperation 这个类写一个分类，然后重写上述方法，以下是具体重写内容。\n\n\n    - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler\n    {\n       NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;\n       __block NSURLCredential *credential = nil;\n       \n       if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {\n           if (!(self.options & SDWebImageDownloaderAllowInvalidSSLCertificates)) {\n               disposition = NSURLSessionAuthChallengePerformDefaultHandling;\n           } else {\n               //改写方法 然后插入证书验证代码\n               do\n               {\n                   SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];\n                   NSCAssert(serverTrust != nil, @\"serverTrust is nil\");\n                   if(nil == serverTrust)                break;\n                   /* failed */\n                   /**\n                    *  导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称\n                    */\n                   NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"oss-ifeixiu-com\" ofType:@\"cer\"];\n                   //自签名证书\n                   NSData *caCert = [NSData dataWithContentsOfFile:cerPath];\n                   \n                   NSCAssert(caCert != nil, @\"caCert is nil\");\n                   \n                   if(nil == caCert)                break;\n                   /* failed */\n                   SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert);\n                   NSCAssert(caRef != nil, @\"caRef is nil\");\n                   if(nil == caRef)                 break;\n                   /* failed */\n                   //可以添加多张证书\n                   NSArray *caArray = @[(__bridge id)(caRef)];\n                   NSCAssert(caArray != nil, @\"caArray is nil\");\n                   if(nil == caArray)                break;\n                   /* failed */\n                   //将读取的证书设置为服务端帧数的根证书\n                   OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);\n                   NSCAssert(errSecSuccess == status, @\"SecTrustSetAnchorCertificates failed\");\n                   if(!(errSecSuccess == status))                break;\n                   /* failed */\n                   SecTrustResultType result = - 1;\n                   //通过本地导入的证书来验证服务器的证书是否可信\n                   status = SecTrustEvaluate(serverTrust, &result);\n                   if(!(errSecSuccess == status))                break;\n                   /* failed */\n                   debug_NSLog(@\"stutas:%d\",(int)status);\n                   debug_NSLog(@\"Result: %d\", result);\n                   BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed);\n                   if (allowConnect) {\n                       debug_NSLog(@\"success\");\n                   }else {\n                       debug_NSLog(@\"error\");\n                   }\n                   \n                   /* kSecTrustResultUnspecified and kSecTrustResultProceed are success */\n                   if(!allowConnect)            {\n                       break;\n                       /* failed */\n                   }\n       #if 0\n                   /*\n                    Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success\n                    */\n                   \n                   /*   since the user will likely tap-through to see the dancing bunnies */\n                   if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError)                break;\n                   /* failed to trust cert (good in this case) */\n       #endif\n                   // The only good exit point\n                   debug_NSLog(@\"信任该证书\");\n                   credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];\n                   disposition = NSURLSessionAuthChallengeUseCredential;\n               }\n               while(0);\n           }\n       } else {\n           if (challenge.previousFailureCount == 0) {\n               if (self.credential) {\n                   credential = self.credential;\n                   disposition = NSURLSessionAuthChallengeUseCredential;\n               } else {\n                   disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;\n               }\n           } else {\n               disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;\n           }\n       }\n       \n       if (completionHandler) {\n           completionHandler(disposition, credential);\n       }\n    }\n\n\n    \n\n\n\n","updated":"2021-06-05T17:44:00.400Z","permalink":"http://yoursite.com/2018/01/18/SDWebImage%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https%E5%8D%8F%E8%AE%AE/","categories":[]},{"title":"全新的生活和逐渐的喜爱","date":"2018-01-03T05:35:00.000Z","path":"2018/01/03/全新的生活和逐渐的喜爱/","text":"17年2月,从上海回来,从有想法离开到回到合肥用了仅仅5天的时间. 我上海的几个兄弟,都没有来得及道别,可能是我不想犹豫. 我觉得我的17年可以用收获来概括:收获了爱情,30斤的体重,一起共事的团队. 心怀感激. 从3月初到现在的1月初的10个月里,飞修团队从零散几个人到目前的30多人,感受到了一种成长的喜悦. 这10个月里只做了一丢丢不值一提的工作,心里即便不想再多写业务代码,但是还是对iOS端放心不下,也许是我自己的毛病,总觉得别人写的东西看不惯,当然这里并没有说欢哥代码写的不好,仅仅只是自己性格的原因,但是也足够的信任. 转型大数据和数据挖掘,是新的起点,也是对自己新的要求.此路很长,要学的东西很多. 乐一说新年的1月,老乡鸡有个新的需求要做,我也想试试从一个产品的角度,做一下产品.可能心太大,但是还是想试试. 12月31日,过了我人生第二十五个生日,不巧的是我往后一天,就一下变成了二十六岁,很可怕的是二十六岁离三十岁那么近,还有好多事情没有做,做过的事情也做得不够好. 17年遵守承诺,下半年年底带姑娘出去玩了两次,去了健身房虽然断断续续,但是已经累计跑了差不多1000公里的距离:1000公里里有暨大的操场,深圳的大街,上海的郊区,合肥的大蜀山,合肥的健身房. 这些点滴的收获慢慢有种莫名的骄傲,却依然对不起现在的体重,2018年要加油. 17年的年底松了一口气,我和姑娘在武汉光谷广场跨年的时候,我发现武汉并没有比合肥好很多,也没合肥舒服,这意味着我开始习惯合肥的生活,所以我觉得我的全新的生活才刚刚开始,也有了逐渐的喜爱,即便每天都要吐槽个够,但这都不重要. 18年要准备买房了,希望能完成这人生第一大任务. 18年要更懂得生活,要更收敛得住脾气. 18年要好好锻炼,适当的体重. 18年代码更精益求精.","raw":"---\ntitle: 全新的生活和逐渐的喜爱\ndate: 2018-01-03 13:35:00\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n\n17年2月,从上海回来,从有想法离开到回到合肥用了仅仅5天的时间.\n\n我上海的几个兄弟,都没有来得及道别,可能是我不想犹豫.\n\n我觉得我的17年可以用收获来概括:收获了爱情,30斤的体重,一起共事的团队.\n\n心怀感激.\n\n从3月初到现在的1月初的10个月里,飞修团队从零散几个人到目前的30多人,感受到了一种成长的喜悦.\n\n这10个月里只做了一丢丢不值一提的工作,心里即便不想再多写业务代码,但是还是对iOS端放心不下,也许是我自己的毛病,总觉得别人写的东西看不惯,当然这里并没有说欢哥代码写的不好,仅仅只是自己性格的原因,但是也足够的信任.\n\n转型大数据和数据挖掘,是新的起点,也是对自己新的要求.此路很长,要学的东西很多.\n\n乐一说新年的1月,老乡鸡有个新的需求要做,我也想试试从一个产品的角度,做一下产品.可能心太大,但是还是想试试.\n\n<!--more-->\n\n12月31日,过了我人生第二十五个生日,不巧的是我往后一天,就一下变成了二十六岁,很可怕的是二十六岁离三十岁那么近,还有好多事情没有做,做过的事情也做得不够好.\n\n17年遵守承诺,下半年年底带姑娘出去玩了两次,去了健身房虽然断断续续,但是已经累计跑了差不多1000公里的距离:1000公里里有暨大的操场,深圳的大街,上海的郊区,合肥的大蜀山,合肥的健身房.\n\n这些点滴的收获慢慢有种莫名的骄傲,却依然对不起现在的体重,2018年要加油.\n\n17年的年底松了一口气,我和姑娘在武汉光谷广场跨年的时候,我发现武汉并没有比合肥好很多,也没合肥舒服,这意味着我开始习惯合肥的生活,所以我觉得我的全新的生活才刚刚开始,也有了逐渐的喜爱,即便每天都要吐槽个够,但这都不重要.\n\n18年要准备买房了,希望能完成这人生第一大任务.\n\n18年要更懂得生活,要更收敛得住脾气.\n\n18年要好好锻炼,适当的体重.\n\n18年代码更精益求精.\n\n","updated":"2021-06-05T17:47:48.795Z","permalink":"http://yoursite.com/2018/01/03/%E5%85%A8%E6%96%B0%E7%9A%84%E7%94%9F%E6%B4%BB%E5%92%8C%E9%80%90%E6%B8%90%E7%9A%84%E5%96%9C%E7%88%B1/","categories":[]},{"title":"Python07","date":"2017-12-26T03:59:25.000Z","path":"2017/12/26/Python07/","text":"模块import sys 导入sys模块,用变量sys指向该模块,利用sys这个变量,就可以访问sys模块的所有功能.sys模块有一个argv变量,用list存储了命令行的所有参数.argv至少有一个元素,因为第一个参数永远是该.py文件的名称. 作用域在Python中函数和变量的访问限制可以用来实现.一般情况下函数和变量名是公开的（public）,可以被直接引用.类似xxx这样的变量是特殊变量,可以被直接引用,但是有特殊用途.比如 \\_author__和__name__是特殊变量,但是我们一般不这样去定义变量.一般情况下我们定义的变量是:类似_xxx和__xxx这样的函数或变量就是非公开的（private）,不应该被直接引用.值得注意的是private函数和变量“不应该”被直接引用,而不是“不能”被直接引用,是因为Python并没有一种方法可以完全限制访问private函数或变量,但是,从编程习惯上不应该引用private函数或变量.这种意义上来看Python和很多其他语言一样,也是注重开源的. 举例: def _private_1(name): return &apos;Hello, %s&apos; % name def _private_2(name): return &apos;Hi, %s&apos; % name def greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 外部不需要引用的函数全部定义成private,只有外部需要引用的函数才定义为public.","raw":"---\ntitle: Python07\ndate: 2017-12-26 11:59:25\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 模块\n---\n\n# 模块\n\n    import sys\n    \n导入sys模块,用变量sys指向该模块,利用sys这个变量,就可以访问sys模块的所有功能.\nsys模块有一个argv变量,用list存储了命令行的所有参数.argv至少有一个元素,因为第一个参数永远是该.py文件的名称.\n\n## 作用域\n\n在Python中函数和变量的访问限制可以用_来实现.\n一般情况下函数和变量名是公开的（public）,可以被直接引用.\n类似__xxx__这样的变量是特殊变量,可以被直接引用,但是有特殊用途.比如 \\_\\_author\\_\\_和\\_\\_name\\_\\_是特殊变量,但是我们一般不这样去定义变量.\n一般情况下我们定义的变量是:类似_xxx和__xxx这样的函数或变量就是非公开的（private）,不应该被直接引用.\n值得注意的是private函数和变量“不应该”被直接引用,而不是“不能”被直接引用,是因为Python并没有一种方法可以完全限制访问private函数或变量,但是,从编程习惯上不应该引用private函数或变量.这种意义上来看Python和很多其他语言一样,也是注重开源的.\n\n举例:\n\n    def _private_1(name):\n        return 'Hello, %s' % name\n    \n    def _private_2(name):\n        return 'Hi, %s' % name\n    \n    def greeting(name):\n        if len(name) > 3:\n            return _private_1(name)\n        else:\n            return _private_2(name)\n            \n外部不需要引用的函数全部定义成private,只有外部需要引用的函数才定义为public.\n\n    \n\n\n","updated":"2018-04-20T07:21:33.926Z","permalink":"http://yoursite.com/2017/12/26/Python07/","categories":[]},{"title":"Python06","date":"2017-12-19T04:44:09.000Z","path":"2017/12/19/Python06/","text":"高阶函数定义:把函数作为参数传入,这样的函数称为高阶函数,函数式编程就是指这种高度抽象的编程范式.理解:个人以为这种思想和逻辑思路,在C语言上早就有,C中的指向函数指针的指针这种思想概念是可以的,而OC中却没有强化这种概念,OC的Block已经强大到足够完成这种纬度的调用和处理业务的场景复杂度,JavaScript这种脚本语言和Python解释型语言反而愈加强化这种观念,将函数(本质上是指针)作为参数使用传递. 变量可以指向函数&gt;&gt;&gt; x = abs(-10) &gt;&gt;&gt; x 10 abs是函数,abs(-10)是函数的调用,上面是将abs(-10)的结果赋值给x; &gt;&gt;&gt; f = abs &gt;&gt;&gt; f &lt;built-in function abs&gt; 上面是将abs函数整体赋值给f,也就是函数本身赋值给变量,即:变量可以指向函数. 当一个变量指向了一个函数,那么可以通过该变量来调用这个函数; &gt;&gt;&gt; f = abs &gt;&gt;&gt; f(-10) 10 直接调用abs()函数和调用变量f()完全相同; 函数名也是变量那么函数名是什么呢?函数名其实就是指向函数的变量!对于abs()这个函数,完全可以把函数名abs看成变量,它指向一个可以计算绝对值的函数! 传入函数既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数. def add(x, y, f): return f(x) + f(y) 当调用add(-5, 6, abs)时,推导计算过程为 x = -5 y = 6 f = abs f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11 return 11 编写高阶函数,就是让函数的参数能够接收别的函数. map/reducemap重点了解map()和reduce()两个函数; 对于map()而言:接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回; 举例:将函数f(x) = x ^ 2 ,要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上. &gt;&gt;&gt; def f(x): ... return x * x ... &gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f,即函数对象本身.由于结果r是一个Iterator,Iterator是惰性序列,因此通过list()函数让它把整个序列都计算出来并返回一个list. 当然上面的过程和需求的作用结果,我们用循环遍历也可以做,比如讲循环遍历挨个平方,也能得到类似的结果,但是你需要看真个循环你才知道这个循环的作用是用来干嘛的,而map()的意义在于,它作为高阶函数,把具体的运算规则抽象化; 例如:要把list [1, 2, 3, 4, 5, 6, 7, 8, 9]所有元素转成字符 &gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] 用map()去执行的话,相当的简洁明. reducereduce把一个函数作用在一个序列[x1, x2, x3, …]上,这个函数必须接收两个参数,reduce把结果继续和序列的下一个元素做累积计算,其效果就是: reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 求和运算可以直接用Python内建函数sum(),没必要动用reduce.假如需要把 [1,3,5,7,9]变换成整数13579,reduce就可以施展拳脚了. &gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; def fn(x, y): ... return x * 10 + y ... &gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9]) 13579 filterfilter()和map()类似,filter()也接收一个函数和一个序列.和map()不同的是,filter()把传入的函数依次作用于每个元素,然后根据返回值是True还是False决定保留还是丢弃该元素. 举例:删掉list里的偶数,保留基数 def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] filter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list. 经典案例分析:用filter求素数(质数又称素数,一个大于1的自然数,除了1和它自身外,不能被其他自然数整除的数叫做质数;否则称为合数.) 最常见的统计素数的方法是埃氏筛法,原理如下: 首先,列出从2开始的所有自然数,构造一个序列:2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取序列的第一个数2,它一定是素数,然后用2把序列的2的倍数筛掉:3, 4(X), 5, 6(X), 7, 8(X), 9, 10(X), 11, 12(X), 13, 14(X), 15, 16(X), 17, 18(X), 19, 20(X), …取新序列的第一个数3,它一定是素数,然后用3把序列的3的倍数筛掉:5, 6(X), 7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), …取新序列的第一个数5,然后用5把序列的5的倍数筛掉:7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), … 不断筛下去,就可以得到所有的素数. def _int_iter(): n = 1 while True: n = n + 1 yield n def _not_divisible(n): return lambda x:x % n &gt; 0 def primes(): it = _int_iter() while True: n = next(it) yield n it = filter(_not_divisible(n), it) sorted排序不管是常见的冒泡还是快排,核心的思想都是比较两个元素的大小;有个问题是:当我们比较数字大小的时候,可以直接快速的比较,但是对于比较字符串或者dict的时候,便没有了数学意义上的大小意义,因此可以把过程抽象出来. 举例:对List排序 &gt;&gt;&gt; sorted([36, 5, -12, 9, -21]) [-21, -12, 5, 9, 36] sorted()可以接收一个key函数来实现自定义的排序,比如按绝对值大小排序: &gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36] 从这里可以看出,sorted()排序的关键在于实现一个映射函数. 返回函数函数作为返回值高阶函数不仅可以把函数作为参数,同时也可以把函数作为结果返回. 下面是个求和函数 def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 如果不需要立即求和,后续根据需求再求和,可以不返回求和结果,而是返回求和的函数: def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum (这两个是python中的可变参数.*args表示任何多个无名参数,它是一个tuple;**kwargs表示关键字参数,它是一个dict.并且同时使用*args和**kwargs时,必须*args参数列要在**\\kwargs前.) &gt;&gt;&gt; f = lazy_sum(1,3,5,7,9) &gt;&gt;&gt; f &lt;function sum at 0x1010f9d70&gt; &gt;&gt;&gt; f() 25 在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数sum时,相关参数和变量都保存在返回的函数中,这种称为“闭包（Closure）”. 闭包返回闭包时牢记一点:返回函数不要引用任何循环变量,或者后续会发生变化的变量.如果一定要引用循环变量怎么办?方法是再创建一个函数,用该函数的参数绑定循环变量当前的值,无论该循环变量后续如何更改,已绑定到函数参数的值不变. def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 一个函数可以返回一个计算结果,也可以返回一个函数.返回一个函数时,函数并未执行,返回函数中不要引用任何可能会变化的变量. 匿名函数传入函数时,有些时候,不需要显式地定义函数,直接传入匿名函数更方便.Python中对匿名函数有一些有限的支持. &gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [1, 4, 9, 16, 25, 36, 49, 64, 81] 上面的lambda x: x * x的本质是 def f(x): return x * x 关键字lambda [‘læmdə] (是λ的英文)表示匿名函数,冒号前面的x表示函数参数.匿名函数有个限制,就是只能有一个表达式,不用写return,返回值就是该表达式的结果. 用匿名函数有个好处,因为函数没有名字,不必担心函数名冲突.此外,匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,再利用变量来调用该函数: &gt;&gt;&gt; f = lambda x: x * x &gt;&gt;&gt; f &lt;function &lt;lambda&gt; at 0x101c6ef28&gt; &gt;&gt;&gt; f(5) 25 同样,也可以把匿名函数作为返回值返回: def build(x, y): return lambda: x * x + y * y 装饰器举例: &gt;&gt;&gt; def now(): ... print(&apos;2015-3-25&apos;) ... &gt;&gt;&gt; f = now &gt;&gt;&gt; f() 2015-3-25 函数对象有一个name属性,可以拿到函数的名字: &gt;&gt;&gt; now.__name__ &apos;now&apos; &gt;&gt;&gt; f.__name__ &apos;now&apos; 要增强now()函数的功能,比如在函数调用前后自动打印日志,但又不希望修改now()函数的定义,这种在代码运行期间动态增加功能的方式,称之为“装饰器”（Decorator）.本质上,decorator就是一个返回函数的高阶函数. def log(func): def wrapper(*args, **kw): print(&apos;call %s():&apos; % func.__name__) return func(*args, **kw) return wrapper log接受一个函数,且返回一个函数,Python中提供了一个@语法,可以把修饰器放置在函数定义的地方,从而来影响函数的执行效果和结果. @log def now(): print(&apos;2015-3-25&apos;) 这样你在调用now的时候,不仅会执行原本的now函数,同时会执行log函数,把@log放到now()函数的定义处,相当于执行了语句: now = log(now) 由于log()是一个decorator,返回一个函数,所以原来的now()函数仍然存在,只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数.wrapper()函数的参数定义是(*args, **kw),因此，wrapper()函数可以接受任意参数的调用.在wrapper()函数内,首先打印日志，再紧接着调用原始函数. def log(text): def decorator(func): def wrapper(*args, **kw): print(&apos;%s %s():&apos; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 如果decorator本身需要传入参数,那就需要编写一个返回decorator的高阶函数.调用如下: @log(&apos;execute&apos;) def now(): print(&apos;2015-3-25&apos;) 执行效果如下: &gt;&gt;&gt; now() execute now(): 2015-3-25 本质上调用了如下代码: &gt;&gt;&gt; now = log(&apos;execute&apos;)(now) 首先执行log(‘execute’),返回的是decorator函数,再调用返回的函数,参数是now函数,返回值最终是wrapper函数 偏函数当函数的参数个数太多,需要简化时,使用functools.partial可以创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单.","raw":"---\ntitle: Python06\ndate: 2017-12-19 12:44:09\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 函数式编程\n---\n\n\n# 高阶函数\n\n定义:把函数作为参数传入,这样的函数称为高阶函数,函数式编程就是指这种高度抽象的编程范式.\n理解:个人以为这种思想和逻辑思路,在C语言上早就有,C中的指向函数指针的指针这种思想概念是可以的,而OC中却没有强化这种概念,OC的Block已经强大到足够完成这种纬度的调用和处理业务的场景复杂度,JavaScript这种脚本语言和Python解释型语言反而愈加强化这种观念,将函数(本质上是指针)作为参数使用传递.\n\n\n## 变量可以指向函数\n\n    >>> x = abs(-10)\n    >>> x\n    10\n    \nabs是函数,abs(-10)是函数的调用,上面是将abs(-10)的结果赋值给x;\n\n    >>> f = abs\n    >>> f\n    <built-in function abs>\n    \n上面是将abs函数整体赋值给f,也就是函数本身赋值给变量,即:变量可以指向函数.\n\n当一个变量指向了一个函数,那么可以通过该变量来调用这个函数;\n\n    >>> f = abs\n    >>> f(-10)\n    10\n\n直接调用abs()函数和调用变量f()完全相同;\n\n## 函数名也是变量\n\n那么函数名是什么呢?函数名其实就是指向函数的变量!对于abs()这个函数,完全可以把函数名abs看成变量,它指向一个可以计算绝对值的函数!\n\n## 传入函数\n\n既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数.\n\n    def add(x, y, f):\n        return f(x) + f(y)\n\n当调用add(-5, 6, abs)时,推导计算过程为\n\n    x = -5\n    y = 6\n    f = abs\n    f(x) + f(y) ==> abs(-5) + abs(6) ==> 11\n    return 11\n    \n编写高阶函数,就是让函数的参数能够接收别的函数.\n\n\n<!--more-->\n\n\n## map/reduce\n\n### map\n\n重点了解map()和reduce()两个函数;\n\n对于map()而言:接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回;\n\n举例:将函数f(x) = x ^ 2 ,要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上.\n\n    >>> def f(x):\n    ...     return x * x\n    ...\n    >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> list(r)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nmap()传入的第一个参数是f,即函数对象本身.由于结果r是一个Iterator,Iterator是惰性序列,因此通过list()函数让它把整个序列都计算出来并返回一个list.\n\n当然上面的过程和需求的作用结果,我们用循环遍历也可以做,比如讲循环遍历挨个平方,也能得到类似的结果,但是你需要看真个循环你才知道这个循环的作用是用来干嘛的,而map()的意义在于,它作为高阶函数,把具体的运算规则抽象化;\n\n例如:要把list [1, 2, 3, 4, 5, 6, 7, 8, 9]所有元素转成字符\n\n    >>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    \n用map()去执行的话,相当的简洁明.\n\n### reduce\n\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上,这个函数必须接收两个参数,reduce把结果继续和序列的下一个元素做累积计算,其效果就是:\n\n    reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n\n求和运算可以直接用Python内建函数sum(),没必要动用reduce.\n假如需要把 [1,3,5,7,9]变换成整数13579,reduce就可以施展拳脚了.\n\n    >>> from functools import reduce\n    >>> def fn(x, y):\n    ...     return x * 10 + y\n    ...\n    >>> reduce(fn, [1, 3, 5, 7, 9])\n    13579\n\n### filter\n\nfilter()和map()类似,filter()也接收一个函数和一个序列.和map()不同的是,filter()把传入的函数依次作用于每个元素,然后根据返回值是True还是False决定保留还是丢弃该元素.\n\n举例:删掉list里的偶数,保留基数\n\n    def is_odd(n):\n    return n % 2 == 1\n    \n    list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n    # 结果: [1, 5, 9, 15]\n\nfilter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list.\n\n经典案例分析:用filter求素数\n(质数又称素数,一个大于1的自然数,除了1和它自身外,不能被其他自然数整除的数叫做质数;否则称为合数.)\n\n最常见的统计素数的方法是埃氏筛法,原理如下:\n\n首先,列出从2开始的所有自然数,构造一个序列:\n2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...\n取序列的第一个数2,它一定是素数,然后用2把序列的2的倍数筛掉:\n3, 4(X), 5, 6(X), 7, 8(X), 9, 10(X), 11, 12(X), 13, 14(X), 15, 16(X), 17, 18(X), 19, 20(X), ...\n取新序列的第一个数3,它一定是素数,然后用3把序列的3的倍数筛掉:\n5, 6(X), 7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), ...\n取新序列的第一个数5,然后用5把序列的5的倍数筛掉:\n7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), ...\n\n不断筛下去,就可以得到所有的素数.\n\n    def _int_iter():\n        n = 1\n        while True:\n            n = n + 1\n            yield n\n     \n    def  _not_divisible(n):\n        return lambda x:x % n > 0\n     \n    def primes():\n        it = _int_iter()\n        while True:\n            n = next(it)\n            yield n\n            it = filter(_not_divisible(n), it)\n\n### sorted\n\n排序不管是常见的冒泡还是快排,核心的思想都是比较两个元素的大小;有个问题是:当我们比较数字大小的时候,可以直接快速的比较,但是对于比较字符串或者dict的时候,便没有了数学意义上的大小意义,因此可以把过程抽象出来.\n\n举例:对List排序\n\n    >>> sorted([36, 5, -12, 9, -21])\n    [-21, -12, 5, 9, 36]\n    \nsorted()可以接收一个key函数来实现自定义的排序,比如按绝对值大小排序: \n\n    >>> sorted([36, 5, -12, 9, -21], key=abs)\n    [5, 9, -12, -21, 36]\n\n从这里可以看出,sorted()排序的关键在于实现一个映射函数.\n\n# 返回函数\n\n## 函数作为返回值\n\n高阶函数不仅可以把函数作为参数,同时也可以把函数作为结果返回.\n\n下面是个求和函数\n\n    def calc_sum(*args):\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n\n如果不需要立即求和,后续根据需求再求和,可以不返回求和结果,而是返回求和的函数:\n\n    def lazy_sum(*args):\n        def sum():\n            ax = 0\n            for n in args:\n                ax = ax + n\n            return ax\n        return sum\n\n(这两个是python中的可变参数.\\*args表示任何多个无名参数,它是一个tuple;\\*\\*kwargs表示关键字参数,它是一个dict.并且同时使用\\*args和\\*\\*kwargs时,必须\\*args参数列要在\\**\\kwargs前.)\n\n    >>> f = lazy_sum(1,3,5,7,9)\n    >>> f\n    <function sum at 0x1010f9d70>\n    >>> f()\n    25\n   \n在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数sum时,相关参数和变量都保存在返回的函数中,这种称为“闭包（Closure）”.\n \n## 闭包\n\n返回闭包时牢记一点:返回函数不要引用任何循环变量,或者后续会发生变化的变量.\n如果一定要引用循环变量怎么办?方法是再创建一个函数,用该函数的参数绑定循环变量当前的值,无论该循环变量后续如何更改,已绑定到函数参数的值不变.\n\n    def count():\n        def f(j):\n            def g():\n                return j*j\n            return g\n        fs = []\n        for i in range(1, 4):\n            fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()\n        return fs\n \n一个函数可以返回一个计算结果,也可以返回一个函数.\n返回一个函数时,函数并未执行,返回函数中不要引用任何可能会变化的变量.\n\n# 匿名函数\n\n传入函数时,有些时候,不需要显式地定义函数,直接传入匿名函数更方便.\nPython中对匿名函数有一些有限的支持.\n\n    >>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    [1, 4, 9, 16, 25, 36, 49, 64, 81]\n    \n上面的lambda x: x * x的本质是\n\n    def f(x):\n        return x * x\n        \n关键字lambda \\['læmdə] (是λ的英文)表示匿名函数,冒号前面的x表示函数参数.\n匿名函数有个限制,就是只能有一个表达式,不用写return,返回值就是该表达式的结果.\n\n用匿名函数有个好处,因为函数没有名字,不必担心函数名冲突.此外,匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,再利用变量来调用该函数:\n\n    >>> f = lambda x: x * x\n    >>> f\n    <function <lambda> at 0x101c6ef28>\n    >>> f(5)\n    25\n    \n同样,也可以把匿名函数作为返回值返回:\n\n    def build(x, y):\n        return lambda: x * x + y * y\n        \n# 装饰器\n\n举例:\n\n    >>> def now():\n    ...     print('2015-3-25')\n    ...\n    >>> f = now\n    >>> f()\n    2015-3-25\n    \n函数对象有一个__name__属性,可以拿到函数的名字:\n\n    >>> now.__name__\n    'now'\n    >>> f.__name__\n    'now'\n    \n要增强now()函数的功能,比如在函数调用前后自动打印日志,但又不希望修改now()函数的定义,这种在代码运行期间动态增加功能的方式,称之为“装饰器”（Decorator）.本质上,decorator就是一个返回函数的高阶函数.\n\n    def log(func):\n        def wrapper(*args, **kw):\n            print('call %s():' % func.__name__)\n            return func(*args, **kw)\n        return wrapper\n\nlog接受一个函数,且返回一个函数,Python中提供了一个@语法,可以把修饰器放置在函数定义的地方,从而来影响函数的执行效果和结果.\n\n    @log\n    def now():\n        print('2015-3-25')\n        \n这样你在调用now的时候,不仅会执行原本的now函数,同时会执行log函数,把@log放到now()函数的定义处,相当于执行了语句:\n\n    now = log(now)\n\n由于log()是一个decorator,返回一个函数,所以原来的now()函数仍然存在,只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数.\nwrapper()函数的参数定义是(\\*args, \\*\\*kw),因此，wrapper()函数可以接受任意参数的调用.在wrapper()函数内,首先打印日志，再紧接着调用原始函数. \n\n    def log(text):\n        def decorator(func):\n            def wrapper(*args, **kw):\n                print('%s %s():' % (text, func.__name__))\n                return func(*args, **kw)\n            return wrapper\n        return decorator\n        \n如果decorator本身需要传入参数,那就需要编写一个返回decorator的高阶函数.\n调用如下:\n\n    @log('execute')\n    def now():\n        print('2015-3-25')\n     \n执行效果如下:     \n   \n    >>> now()\n    execute now():\n    2015-3-25\n    \n本质上调用了如下代码:\n\n    >>> now = log('execute')(now)\n    \n首先执行log('execute'),返回的是decorator函数,再调用返回的函数,参数是now函数,返回值最终是wrapper函数\n\n# 偏函数\n\n当函数的参数个数太多,需要简化时,使用functools.partial可以创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单.\n\n\n\n\n\n\n\n","updated":"2018-04-20T07:21:17.320Z","permalink":"http://yoursite.com/2017/12/19/Python06/","categories":[]},{"title":"Python05","date":"2017-12-16T05:45:53.000Z","path":"2017/12/16/Python05/","text":"切片在很多编程语言中,针对字符串提供了很多各种截取函数（例如,substring）,其实目的就是对字符串切片.Python没有针对字符串的截取函数,只需要切片一个操作就可以完成,非常简单. Python针对所有需要截取的操作,统一都用切片操作来处理,比如对list,tuple元素的截取,对string的字符截取,都可以用切片操作来完成. [1,2,3,4,5] [0:5] (0, 1, 2, 3, 4, 5)[:3] &apos;string&apos;[1:3] 迭代对于给定一个list或tuple,可以通过for循环来遍历这个list或tuple,这种遍历在被称为迭代（Iteration）.而Python OC Swift等语言支持 for … in 循环遍历, Java 是 for X : X 这种类型,其实本质上都一样,只是语言规则形式上的区别,而 C 语言中的迭代要溯源于for循环的下标循环 for (i=0; i&lt;list.length; i++) &#123; // 处理操作 &#125; 在Python中,对于list和tuple这种带下标顺序的数据结构类型无疑是可以迭代的,Python同样支持无下标的一些数据结构比如Python中的dict, 其实意味着dict对于Python而言是一个可迭代的对象,OC和Swift以及Java其实对字典亦或是Map的操作处理都具有类似的迭代功能; 而对于字符串处理的其他语言可能实现迭代较为繁琐,需要先转化一下在进行迭代操作,而Python有直接操作的兼容性,其实本质上都是做了转化处理;相反的Python反而想做下标循环遍历要比C/OC/Swift/Java等要困难; 小结但是Python的思想是想告诉使用者,但凡遇到了一串,一堆的东西的时候,首先它都是可以当成一个容器的结构去处理的;Python对这些的处理总有一种化繁为简的操作,处理都使用同样的接口和同样的API来处理不同的数据结构;迭代的思想如此,切片的思想也是如此; 在Python中,任何可迭代对象都可以作用于for循环,包括自定义的数据类型,只要符合迭代条件,就可以使用for循环. Tips:如何判断一个对象是可迭代对象?方法是通过collections模块的Iterable类型判断: &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 列表生成式Python内置的非常简单却强大的可以用来创建list的生成式;例如:要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; &gt;&gt;&gt; list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 例如:要生成[1x1, 2x2, 3x3, …, 10x10]; 方法一:(用循环,但是比较繁琐) &gt;&gt;&gt; L = [] &gt;&gt;&gt; for x in range(1, 11): ... L.append(x * x) ... &gt;&gt;&gt; L [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 方法二: &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表生成式时,把要生成的元素x * x放到前面,后面跟for循环,就可以把list创建出来.此外,for循环后面还可以加上if判断,这样我们就可以筛选出仅偶数的平方,比如 &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 还可以使用两层循环,可以生成全排列: &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 列表生成式也可以使用两个变量来生成list: &gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125; &gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()] [&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写: &gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;apple&apos;] &gt;&gt;&gt; [s.lower() for s in L] [&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 使用内建的isinstance函数可以判断一个变量是不是字符串: &gt;&gt;&gt; x = &apos;abc&apos; &gt;&gt;&gt; y = 123 &gt;&gt;&gt; isinstance(x, str) True &gt;&gt;&gt; isinstance(y, str) False 小结Python的语法对矩阵的表示太友好了. 生成器通过列表生成式,可以直接创建一个列表.但是,受到内存限制,列表容量肯定是有限.假如创建一个包含100万个元素的列表,不仅占用很大的存储空间,如果我们仅仅需要访问前面几个元素,那后面绝大多数元素占用的空间都白白浪费了. 如果列表元素可以按照某种算法推算出来,那我们是否可以在循环的过程中不断推算出后续的元素呢?这样就不必创建完整的list,从而节省大量的空间. 在Python中,这种一边循环一边计算的机制,称为生成器:generator. 创建生成器方法方法一:有个简单的方法,把一个列表生成式的[]改成(),就创建了一个生成器 &gt;&gt;&gt; L = [x * x for x in range(10)] &gt;&gt;&gt; L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; g 其中L是一个列表,而g是一个生成器;一般情况下,我们可以直接打印出List,而生成器要用何方法打印呢?可以用next()函数; &gt;&gt;&gt; next(g) 0 &gt;&gt;&gt; next(g) 1 &gt;&gt;&gt; next(g) 4 &gt;&gt;&gt; next(g) 9 &gt;&gt;&gt; next(g) 16 &gt;&gt;&gt; next(g) 25 &gt;&gt;&gt; next(g) 36 &gt;&gt;&gt; next(g) 49 &gt;&gt;&gt; next(g) 64 &gt;&gt;&gt; next(g) 81 &gt;&gt;&gt; next(g) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration 为何每次都只打印一个值的原因是:generator保存的是算法,每次调用next(g),就计算出g的下一个元素的值,直到计算到最后一个元素,没有更多的元素时,抛出StopIteration的错误.所以是符合我们之前对generator的定义和最初要求的. 当然逐个打印出来的方法显得略笨,同样可以用for循环来操作打印 &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81 对于generator来说,如果推算的算法比较复杂,用类似列表生成式的for循环无法实现的时候,还可以用函数来实现. 这里有个典型的例子:斐波拉契数列函数如下 def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b #这一句相当于下面的注释的三句代码 #t = (b, a + b) # t是一个tuple #a = t[0] #b = t[1] n = n + 1 return &apos;done&apos; fib函数实际上是定义了斐波拉契数列的推算规则,可以从第一个元素开始,推算出后续任意的元素,这其实非常类似generator的思想,且达到了generator的意义; 对于另一种生成器的创建方法就是:改写函数,当一个函数中含有关键字yield的时候,那么这个函数就不是一个普通函数,值得注意的是generator和函数的区别:函数是顺序执行,遇到return语句或者最后一行函数语句就返回.而generator函数,在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行. def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b #这一句相当于下面的注释的三句代码 #t = (b, a + b) # t是一个tuple #a = t[0] #b = t[1] n = n + 1 return &apos;done&apos; 用for循环调用generator时,如果拿不到generator的return语句的返回值,且又想要拿到返回值,那就需要捕获StopIteration错误,返回值包含在StopIteration的value中; &gt;&gt;&gt; g = fib(6) &gt;&gt;&gt; while True: ... try: ... x = next(g) ... print(&apos;g:&apos;, x) ... except StopIteration as e: ... print(&apos;Generator return value:&apos;, e.value) ... break ... g: 1 g: 1 g: 2 g: 3 g: 5 g: 8 Generator return value: done 小结在Python中,可以简单地把列表生成式改成generator,也可以通过函数实现复杂逻辑的generator.要理解generator的工作原理,它是在for循环的过程中不断计算出下一个元素,并在适当的条件结束for循环.对于函数改成的generator来说,遇到return语句或者执行到函数体最后一行语句,就是结束generator的指令,for循环随之结束. 迭代器直接作用于for循环的数据类型有以下几种：一类是集合数据类型,如list、tuple、dict、set、str等;一类是generator,包括生成器和带yield的generator function.这些可以直接作用于for循环的对象统称为可迭代对象:Iterable. &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance([], Iterable) True &gt;&gt;&gt; isinstance(&#123;&#125;, Iterable) True &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) True &gt;&gt;&gt; isinstance((x for x in range(10)), Iterable) True &gt;&gt;&gt; isinstance(100, Iterable) False 生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出StopIteration错误表示无法继续返回下一个值了.可以被next()函数调用并不断返回下一个值的对象称为迭代器:Iterator.可以使用isinstance()判断一个对象是否是Iterator对象. &gt;&gt;&gt; from collections import Iterator &gt;&gt;&gt; isinstance((x for x in range(10)), Iterator) True &gt;&gt;&gt; isinstance([], Iterator) False &gt;&gt;&gt; isinstance(&#123;&#125;, Iterator) False &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator) False 生成器都是Iterator对象,但list、dict、str虽然是Iterable(可迭代的),却不是Iterator(迭代器). 但是要把list、dict、str等Iterable变成Iterator可以使用iter()函数: &gt;&gt;&gt; isinstance(iter([]), Iterator) True &gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator) True 因为Python的Iterator对象表示的是一个数据流,Iterator对象可以被next()函数调用并不断返回下一个数据,直到没有数据时抛出StopIteration错误.可以把这个数据流看做是一个有序序列,但我们却不能提前知道序列的长度,只能不断通过next()函数实现按需计算下一个数据,所以Iterator的计算是惰性的,只有在需要返回下一个数据时它才会计算.Iterator甚至可以表示一个无限大的数据流,例如全体自然数.而使用list是永远不可能存储全体自然数的. 小结凡是可作用于for循环的对象都是Iterable类型;凡是可作用于next()函数的对象都是Iterator类型,它们表示一个惰性计算的序列;集合数据类型如list、dict、str等是Iterable但不是Iterator,不过可以通过iter()函数获得一个Iterator对象.Python的for循环本质上就是通过不断调用next()函数实现的,例如: for x in [1, 2, 3, 4, 5]: pass 等价于： # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break","raw":"---\ntitle: Python05\ndate: 2017-12-16 13:45:53\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 高级特性\n---\n\n## 切片\n在很多编程语言中,针对字符串提供了很多各种截取函数（例如,substring）,其实目的就是对字符串切片.Python没有针对字符串的截取函数,只需要切片一个操作就可以完成,非常简单.\n\nPython针对所有需要截取的操作,统一都用切片操作来处理,比如对list,tuple元素的截取,对string的字符截取,都可以用切片操作来完成.\n\n     [1,2,3,4,5] [0:5]\n     (0, 1, 2, 3, 4, 5)[:3]\n     'string'[1:3]\n     \n<!--more-->\n\n## 迭代\n对于给定一个list或tuple,可以通过for循环来遍历这个list或tuple,这种遍历在被称为迭代（Iteration）.\n而Python OC Swift等语言支持 for ... in 循环遍历, Java 是 for  X : X 这种类型,其实本质上都一样,只是语言规则形式上的区别,而 C 语言中的迭代要溯源于for循环的下标循环\n \n     for (i=0; i<list.length; i++) \n     {\n         // 处理操作\n     }\n     \n在Python中,对于list和tuple这种带下标顺序的数据结构类型无疑是可以迭代的,Python同样支持无下标的一些数据结构比如Python中的dict, 其实意味着dict对于Python而言是一个可迭代的对象,OC和Swift以及Java其实对字典亦或是Map的操作处理都具有类似的迭代功能;\n\n而对于字符串处理的其他语言可能实现迭代较为繁琐,需要先转化一下在进行迭代操作,而Python有直接操作的兼容性,其实本质上都是做了转化处理;相反的Python反而想做下标循环遍历要比C/OC/Swift/Java等要困难;\n\n### 小结\n但是Python的思想是想告诉使用者,但凡遇到了一串,一堆的东西的时候,首先它都是可以当成一个容器的结构去处理的;\nPython对这些的处理总有一种化繁为简的操作,处理都使用同样的接口和同样的API来处理不同的数据结构;\n迭代的思想如此,切片的思想也是如此;   \n\n在Python中,任何可迭代对象都可以作用于for循环,包括自定义的数据类型,只要符合迭代条件,就可以使用for循环.\n\nTips:如何判断一个对象是可迭代对象?方法是通过collections模块的Iterable类型判断:\n     \n    >>> from collections import Iterable\n    >>> isinstance('abc', Iterable) # str是否可迭代\n    True\n    >>> isinstance([1,2,3], Iterable) # list是否可迭代\n    True\n    >>> isinstance(123, Iterable) # 整数是否可迭代\n    False\n\n## 列表生成式\nPython内置的非常简单却强大的可以用来创建list的生成式;\n例如:要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    >>> list(range(1, 11))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n例如:要生成[1x1, 2x2, 3x3, ..., 10x10];\n\n方法一:(用循环,但是比较繁琐)\n\n    >>> L = []\n    >>> for x in range(1, 11):\n    ...    L.append(x * x)\n    ...\n    >>> L\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]    \n  \n方法二:  \n  \n    >>> [x * x for x in range(1, 11)]\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \n写列表生成式时,把要生成的元素x * x放到前面,后面跟for循环,就可以把list创建出来.此外,for循环后面还可以加上if判断,这样我们就可以筛选出仅偶数的平方,比如\n     \n    >>> [x * x for x in range(1, 11) if x % 2 == 0]\n    [4, 16, 36, 64, 100]\n    \n还可以使用两层循环,可以生成全排列:\n\n    >>> [m + n for m in 'ABC' for n in 'XYZ']\n    ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n    \n列表生成式也可以使用两个变量来生成list:\n\n    >>> d = {'x': 'A', 'y': 'B', 'z': 'C' }\n    >>> [k + '=' + v for k, v in d.items()]\n    ['y=B', 'x=A', 'z=C']\n    \n最后把一个list中所有的字符串变成小写:\n\n    >>> L = ['Hello', 'World', 'IBM', 'apple']\n    >>> [s.lower() for s in L]\n    ['hello', 'world', 'ibm', 'apple']   \n     \n使用内建的isinstance函数可以判断一个变量是不是字符串:\n\n    >>> x = 'abc'\n    >>> y = 123\n    >>> isinstance(x, str)\n    True\n    >>> isinstance(y, str)\n    False    \n      \n### 小结\nPython的语法对矩阵的表示太友好了.  \n   \n## 生成器\n通过列表生成式,可以直接创建一个列表.但是,受到内存限制,列表容量肯定是有限.假如创建一个包含100万个元素的列表,不仅占用很大的存储空间,如果我们仅仅需要访问前面几个元素,那后面绝大多数元素占用的空间都白白浪费了.\n\n如果列表元素可以按照某种算法推算出来,那我们是否可以在循环的过程中不断推算出后续的元素呢?这样就不必创建完整的list,从而节省大量的空间.\n\n在Python中,这种一边循环一边计算的机制,称为生成器:generator.\n\n### 创建生成器方法\n方法一:有个简单的方法,把一个列表生成式的[]改成(),就创建了一个生成器\n\n    >>> L = [x * x for x in range(10)]\n    >>> L\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n    >>> g = (x * x for x in range(10))\n    >>> g\n    \n其中L是一个列表,而g是一个生成器;\n一般情况下,我们可以直接打印出List,而生成器要用何方法打印呢?可以用next()函数;\n\n    >>> next(g)\n    0\n    >>> next(g)\n    1\n    >>> next(g)\n    4\n    >>> next(g)\n    9\n    >>> next(g)\n    16\n    >>> next(g)\n    25\n    >>> next(g)\n    36\n    >>> next(g)\n    49\n    >>> next(g)\n    64\n    >>> next(g)\n    81\n    >>> next(g)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    StopIteration\n    \n为何每次都只打印一个值的原因是:generator保存的是算法,每次调用next(g),就计算出g的下一个元素的值,直到计算到最后一个元素,没有更多的元素时,抛出StopIteration的错误.所以是符合我们之前对generator的定义和最初要求的.\n\n当然逐个打印出来的方法显得略笨,同样可以用for循环来操作打印\n\n    >>> g = (x * x for x in range(10))\n    >>> for n in g:\n    ...     print(n)\n    ... \n    0\n    1\n    4\n    9\n    16\n    25\n    36\n    49\n    64\n    81\n    \n对于generator来说,如果推算的算法比较复杂,用类似列表生成式的for循环无法实现的时候,还可以用函数来实现.\n\n这里有个典型的例子:\n斐波拉契数列函数如下\n\n    def fib(max):\n        n, a, b = 0, 0, 1\n        while n < max:\n            print(b)\n            \n            a, b = b, a + b   #这一句相当于下面的注释的三句代码\n            #t = (b, a + b)   # t是一个tuple\n            #a = t[0]\n            #b = t[1]\n            \n            n = n + 1\n        return 'done'\n \nfib函数实际上是定义了斐波拉契数列的推算规则,可以从第一个元素开始,推算出后续任意的元素,这其实非常类似generator的思想,且达到了generator的意义;\n\n对于另一种生成器的创建方法就是:改写函数,当一个函数中含有关键字yield的时候,那么这个函数就不是一个普通函数,值得注意的是generator和函数的区别:函数是顺序执行,遇到return语句或者最后一行函数语句就返回.而generator函数,在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行.\n\n    def fib(max):\n            n, a, b = 0, 0, 1\n            while n < max:\n                yield b\n                \n                a, b = b, a + b   #这一句相当于下面的注释的三句代码\n                #t = (b, a + b)   # t是一个tuple\n                #a = t[0]\n                #b = t[1]\n                \n                n = n + 1\n            return 'done'\n \n用for循环调用generator时,如果拿不到generator的return语句的返回值,且又想要拿到返回值,那就需要捕获StopIteration错误,返回值包含在StopIteration的value中;\n\n    >>> g = fib(6)\n    >>> while True:\n    ...     try:\n    ...         x = next(g)\n    ...         print('g:', x)\n    ...     except StopIteration as e:\n    ...         print('Generator return value:', e.value)\n    ...         break\n    ...\n    g: 1\n    g: 1\n    g: 2\n    g: 3\n    g: 5\n    g: 8\n    Generator return value: done    \n    \n### 小结\n在Python中,可以简单地把列表生成式改成generator,也可以通过函数实现复杂逻辑的generator.\n要理解generator的工作原理,它是在for循环的过程中不断计算出下一个元素,并在适当的条件结束for循环.对于函数改成的generator来说,遇到return语句或者执行到函数体最后一行语句,就是结束generator的指令,for循环随之结束.\n\n\n## 迭代器\n直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型,如list、tuple、dict、set、str等;\n一类是generator,包括生成器和带yield的generator function.\n这些可以直接作用于for循环的对象统称为可迭代对象:Iterable.\n\n    >>> from collections import Iterable\n    >>> isinstance([], Iterable)\n    True\n    >>> isinstance({}, Iterable)\n    True\n    >>> isinstance('abc', Iterable)\n    True\n    >>> isinstance((x for x in range(10)), Iterable)\n    True\n    >>> isinstance(100, Iterable)\n    False\n\n生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出StopIteration错误表示无法继续返回下一个值了.\n可以被next()函数调用并不断返回下一个值的对象称为迭代器:Iterator.\n可以使用isinstance()判断一个对象是否是Iterator对象.\n\n    >>> from collections import Iterator\n    >>> isinstance((x for x in range(10)), Iterator)\n    True\n    >>> isinstance([], Iterator)\n    False\n    >>> isinstance({}, Iterator)\n    False\n    >>> isinstance('abc', Iterator)\n    False\n    \n生成器都是Iterator对象,但list、dict、str虽然是Iterable(可迭代的),却不是Iterator(迭代器).\n\n但是要把list、dict、str等Iterable变成Iterator可以使用iter()函数:\n\n    >>> isinstance(iter([]), Iterator)\n    True\n    >>> isinstance(iter('abc'), Iterator)\n    True\n    \n因为Python的Iterator对象表示的是一个数据流,Iterator对象可以被next()函数调用并不断返回下一个数据,直到没有数据时抛出StopIteration错误.可以把这个数据流看做是一个有序序列,但我们却不能提前知道序列的长度,只能不断通过next()函数实现按需计算下一个数据,所以Iterator的计算是惰性的,只有在需要返回下一个数据时它才会计算.\nIterator甚至可以表示一个无限大的数据流,例如全体自然数.而使用list是永远不可能存储全体自然数的.\n\n### 小结\n凡是可作用于for循环的对象都是Iterable类型;\n凡是可作用于next()函数的对象都是Iterator类型,它们表示一个惰性计算的序列;\n集合数据类型如list、dict、str等是Iterable但不是Iterator,不过可以通过iter()函数获得一个Iterator对象.\nPython的for循环本质上就是通过不断调用next()函数实现的,例如:\n\n    for x in [1, 2, 3, 4, 5]:\n        pass\n        \n等价于：  \n   \n    # 首先获得Iterator对象:\n    it = iter([1, 2, 3, 4, 5])\n    # 循环:\n    while True:\n        try:\n            # 获得下一个值:\n            x = next(it)\n        except StopIteration:\n            # 遇到StopIteration就退出循环\n            break  \n\n\n\n\n\n\n","updated":"2018-04-20T07:21:06.128Z","permalink":"http://yoursite.com/2017/12/16/Python05/","categories":[]},{"title":"Python04","date":"2017-12-15T08:55:18.000Z","path":"2017/12/15/Python04/","text":"递归函数在函数内部,可以调用其他函数.如果一个函数在内部调用自身本身,这个函数就是递归函数.递归函数的优点是定义简单,逻辑清晰.理论上,所有的递归函数都可以写成循环的方式,但循环的逻辑不如递归清晰.使用递归函数需要注意防止栈溢出.在计算机中,函数调用是通过栈（stack）这种数据结构实现的,每当进入一个函数调用,栈就会加一层栈帧,每当函数返回,栈就会减一层栈帧.由于栈的大小不是无限的,所以,递归调用的次数过多,会导致栈溢出.解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以,把循环看成是一种特殊的尾递归函数也是可以的.尾递归是指,在函数返回的时候,调用自身本身,并且,return语句不能包含表达式.这样,编译器或者解释器就可以把尾递归做优化,使递归本身无论调用多少次,都只占用一个栈帧,不会出现栈溢出的情况.尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出.使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.Python标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题. 示例计算: n! = 1 2 3 … n def factor(n): if n == 1: return 1 return n * factor(n-1) 上面这种写法虽然用递归处理了,但是优化不够,没有做尾递归优化,上面的factor(n)函数由于return n * factor(n - 1) 引入了乘法表达式,所以就不是尾递归了.要改成尾递归方式,需要多一点代码,主要是要把每一步的乘积传入到递归函数中,如下: def factor(n): return factor_iteration(n, 1) def factor_iteration(num, product): if num == 1: return product return factor_iteration(num - 1, num * product) 由于 return factor_iteration(num - 1, num product) 仅返回递归函数本身, num - 1和num product在函数调用前就会被计算,进而不影响函数调用. 尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出. 小结使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.Python标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题.","raw":"---\ntitle: Python04\ndate: 2017-12-15 16:55:18\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 递归函数\n---\n\n# 递归函数\n在函数内部,可以调用其他函数.如果一个函数在内部调用自身本身,这个函数就是递归函数.\n递归函数的优点是定义简单,逻辑清晰.理论上,所有的递归函数都可以写成循环的方式,但循环的逻辑不如递归清晰.\n使用递归函数需要注意防止栈溢出.在计算机中,函数调用是通过栈（stack）这种数据结构实现的,每当进入一个函数调用,栈就会加一层栈帧,每当函数返回,栈就会减一层栈帧.由于栈的大小不是无限的,所以,递归调用的次数过多,会导致栈溢出.\n解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以,把循环看成是一种特殊的尾递归函数也是可以的.\n尾递归是指,在函数返回的时候,调用自身本身,并且,return语句不能包含表达式.这样,编译器或者解释器就可以把尾递归做优化,使递归本身无论调用多少次,都只占用一个栈帧,不会出现栈溢出的情况.\n尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出.\n使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.\n针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.\nPython标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题.\n\n<!--more-->\n\n## 示例\n计算: n! = 1 * 2 * 3 * ... * n \n     \n     def factor(n):\n        if n == 1:\n           return 1\n        return n * factor(n-1)\n\n上面这种写法虽然用递归处理了,但是优化不够,没有做尾递归优化,上面的factor(n)函数由于return n * factor(n - 1) 引入了乘法表达式,所以就不是尾递归了.要改成尾递归方式,需要多一点代码,主要是要把每一步的乘积传入到递归函数中,如下:\n   \n      def factor(n):\n         return factor_iteration(n, 1)\n        \n      def factor_iteration(num, product):\n         if num == 1:\n            return product\n         return factor_iteration(num - 1, num * product)          \n\n由于 return factor_iteration(num - 1, num * product) 仅返回递归函数本身, num - 1和num * product在函数调用前就会被计算,进而不影响函数调用.     \n\n尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出.   \n\n## 小结\n使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.\n针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.\nPython标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题.\n\n","updated":"2018-04-20T07:20:55.660Z","permalink":"http://yoursite.com/2017/12/15/Python04/","categories":[]},{"title":"Python03","date":"2017-12-13T08:04:54.000Z","path":"2017/12/13/Python03/","text":"调用函数要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs,只有一个参数.调用函数的时候,如果传入的参数数量不对,会报TypeError的错误,并且Python会明确地告诉你:abs()有且仅有1个参数,但给出了两个.如果传入的参数数量是对的,但参数类型不能被函数所接受,也会报TypeError的错误,并且给出错误信息.Python在数据转换的时候,也可以用数据类型转换函数.函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,相当于给这个函数起了一个“别名”. 定义函数Python中,定义一个函数要使用def语句,依次写出函数名、括号、括号中的参数和冒号:,然后,在缩进块中编写函数体,函数的返回值用return语句返回.函数体内部的语句在执行时,一旦执行到return时,函数就执行完毕,并将结果返回.如果没有return语句,函数执行完毕后也会返回结果,只是结果为None,return None可以简写为return.如果想定义一个什么事也不做的空函数,可以用pass语句,pass语句什么都不做,那有什么用？实际上pass可以用来作为占位符,比如现在还没想好怎么写函数的代码,就可以先放一个pass,让代码能运行起来.缺少了pass，代码运行就会有语法错误.PS:此处的pass其实相当于别的语言里的空实现,OC/C/Cpp中的空实现,可以不写任何代码或者放任不管不执行,而Python为了达到这一目的,需要用关键词pass来处理. 参数检查调用函数时,如果参数个数不对,Python解释器会自动检查出来,并抛出TypeError.但是如果参数类型不对,Python解释器就无法检查.所以对参数类型做检查,例如只允许整数和浮点数类型的参数会给我们避免很多错误.数据类型检查可以用内置函数isinstance()实现. 返回多个值Python的函数返回多值其实就是返回一个tuple,按照参数位置顺序取值即可 小结定义函数时,需要确定函数名和参数个数;如果有必要,可以先对参数的数据类型做检查;函数体内部可以用return随时返回函数结果;函数执行完毕也没有return语句时,自动return None.函数可以同时返回多个值,但其实就是一个tuple. 函数的参数Python的函数定义非常简单,但灵活度却非常大.除了正常定义的必选参数外,还可以使用默认参数、可变参数和关键字参数,使得函数定义出来的接口,不但能处理复杂的参数,还可以简化调用者的代码. 位置参数power(x, n)函数有两个参数,x和n都是位置参数 默认参数def power(x, n=2): 这里的n是默认参数默认参数可以简化函数的调用.设置默认参数时,要注意:一是必选参数在前,默认参数在后,否则Python的解释器会报错;二当函数有多个参数时,把变化大的参数放前面,变化小的参数放后面.变化小的参数就可以作为默认参数.PS:默认参数必须指向不变对象.不变对象一旦创建,对象内部的数据就不能修改,这样就减少了由于修改数据导致的错误.此外,由于对象不变,多任务环境下同时读取对象不需要加锁,同时读一点问题都没有.我们在编写程序时,如果可以设计一个不变对象,那就尽量设计成不变对象. 可变参数&gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 *nums表示把nums这个list的所有元素作为可变参数传进去. 关键字参数可变参数允许传入0个或任意个参数,这些可变参数在函数调用时自动组装为一个tuple.而关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict.关键字参数有什么用？它可以扩展函数的功能. &gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; &gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra) name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数,kw将获得一个dict,注意kw获得的dict是extra的一份拷贝,对kw的改动不会影响到函数外的extra. 命名关键字参数对于关键字参数,函数的调用者可以传入任意不受限制的关键字参数.至于到底传入了哪些,就需要在函数内部通过kw检查. def person(name, age, **kw): if &apos;city&apos; in kw: # 有city参数 pass if &apos;job&apos; in kw: # 有job参数 pass print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 如果要限制关键字参数的名字,就可以用命名关键字参数.和关键字参数**kw不同,命名关键字参数需要一个特殊分隔符*,*后面的参数被视为命名关键字参数. &gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;) Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数,后面跟着的命名关键字参数就不再需要一个特殊分隔符*了: def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名,这和位置参数不同.如果没有传入参数名,调用将报错. 使用命名关键字参数时,要特别注意,如果没有可变参数,就必须加一个*作为特殊分隔符.如果缺少*,Python解释器将无法识别位置参数和命名关键字参数 def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass 参数组合在Python中定义函数,可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数,这5种参数都可以组合使用.但是请注意,参数定义的顺序必须是:必选参数、默认参数、可变参数、命名关键字参数和关键字参数.所以,对于任意函数,都可以通过类似func(*args, **kw)的形式调用它,无论它的参数是如何定义的.虽然可以组合多达5种参数,但不要同时使用太多的组合,否则函数接口的可理解性很差. 小结Python的函数具有非常灵活的参数形态,既可以实现简单的调用,又可以传入非常复杂的参数.默认参数一定要用不可变对象,如果是可变对象,程序运行时会有逻辑错误!要注意定义可变参数和关键字参数的语法:*args是可变参数,args接收的是一个tuple;**kw是关键字参数,kw接收的是一个dict. 以及调用函数时如何传入可变参数和关键字参数的语法:可变参数既可以直接传入:func(1, 2, 3),又可以先组装list或tuple,再通过*args传入:func(*(1, 2, 3));关键字参数既可以直接传入:func(a=1, b=2),又可以先组装dict,再通过**kw传入：func(**{‘a’: 1, ‘b’: 2}). 使用*args和**kw是Python的习惯写法,当然也可以用其他参数名,但最好使用习惯用法.命名的关键字参数是为了限制调用者可以传入的参数名,同时可以提供默认值.定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*,否则定义的将是位置参数.","raw":"---\ntitle: Python03\ndate: 2017-12-13 16:04:54\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 函数\n---\n\n## 调用函数\n要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs,只有一个参数.\n调用函数的时候,如果传入的参数数量不对,会报TypeError的错误,并且Python会明确地告诉你:abs()有且仅有1个参数,但给出了两个.\n如果传入的参数数量是对的,但参数类型不能被函数所接受,也会报TypeError的错误,并且给出错误信息.\nPython在数据转换的时候,也可以用数据类型转换函数.\n函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,相当于给这个函数起了一个“别名”.\n\n## 定义函数\nPython中,定义一个函数要使用def语句,依次写出函数名、括号、括号中的参数和冒号:,然后,在缩进块中编写函数体,函数的返回值用return语句返回.\n函数体内部的语句在执行时,一旦执行到return时,函数就执行完毕,并将结果返回.\n如果没有return语句,函数执行完毕后也会返回结果,只是结果为None,return None可以简写为return.\n如果想定义一个什么事也不做的空函数,可以用pass语句,pass语句什么都不做,那有什么用？实际上pass可以用来作为占位符,比如现在还没想好怎么写函数的代码,就可以先放一个pass,让代码能运行起来.\n缺少了pass，代码运行就会有语法错误.\nPS:此处的pass其实相当于别的语言里的空实现,OC/C/Cpp中的空实现,可以不写任何代码或者放任不管不执行,而Python为了达到这一目的,需要用关键词pass来处理.\n\n### 参数检查\n调用函数时,如果参数个数不对,Python解释器会自动检查出来,并抛出TypeError.但是如果参数类型不对,Python解释器就无法检查.所以对参数类型做检查,例如只允许整数和浮点数类型的参数会给我们避免很多错误.数据类型检查可以用内置函数isinstance()实现.\n\n### 返回多个值\nPython的函数返回多值其实就是返回一个tuple,按照参数位置顺序取值即可\n\n### 小结\n定义函数时,需要确定函数名和参数个数;\n如果有必要,可以先对参数的数据类型做检查;\n函数体内部可以用return随时返回函数结果;\n函数执行完毕也没有return语句时,自动return None.\n函数可以同时返回多个值,但其实就是一个tuple.\n\n\n\n<!--more-->\n\n\n\n## 函数的参数\nPython的函数定义非常简单,但灵活度却非常大.除了正常定义的必选参数外,还可以使用默认参数、可变参数和关键字参数,使得函数定义出来的接口,不但能处理复杂的参数,还可以简化调用者的代码.\n\n### 位置参数\npower(x, n)函数有两个参数,x和n都是位置参数\n### 默认参数\ndef power(x, n=2):   这里的n是默认参数\n默认参数可以简化函数的调用.设置默认参数时,要注意:\n一是必选参数在前,默认参数在后,否则Python的解释器会报错;\n二当函数有多个参数时,把变化大的参数放前面,变化小的参数放后面.变化小的参数就可以作为默认参数.\nPS:默认参数必须指向不变对象.不变对象一旦创建,对象内部的数据就不能修改,这样就减少了由于修改数据导致的错误.此外,由于对象不变,多任务环境下同时读取对象不需要加锁,同时读一点问题都没有.我们在编写程序时,如果可以设计一个不变对象,那就尽量设计成不变对象.\n\n### 可变参数\n\n    >>> nums = [1, 2, 3]\n    >>> calc(*nums)\n    14\n    \n*nums表示把nums这个list的所有元素作为可变参数传进去.\n\n### 关键字参数\n可变参数允许传入0个或任意个参数,这些可变参数在函数调用时自动组装为一个tuple.而关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict.关键字参数有什么用？它可以扩展函数的功能.\n\n    >>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n    >>> person('Jack', 24, **extra)\n    name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n    \n\\*\\*extra表示把extra这个dict的所有key-value用关键字参数传入到函数的\\*\\*kw参数,kw将获得一个dict,注意kw获得的dict是extra的一份拷贝,对kw的改动不会影响到函数外的extra.\n\n#### 命名关键字参数\n对于关键字参数,函数的调用者可以传入任意不受限制的关键字参数.至于到底传入了哪些,就需要在函数内部通过kw检查.\n    \n    def person(name, age, **kw):\n        if 'city' in kw:\n            # 有city参数\n            pass\n        if 'job' in kw:\n            # 有job参数\n            pass\n        print('name:', name, 'age:', age, 'other:', kw)\n    \n如果要限制关键字参数的名字,就可以用命名关键字参数.和关键字参数\\*\\*kw不同,命名关键字参数需要一个特殊分隔符\\*,\\*后面的参数被视为命名关键字参数.\n\n     >>> person('Jack', 24, city='Beijing', job='Engineer')\n     Jack 24 Beijing Engineer\n\n如果函数定义中已经有了一个可变参数,后面跟着的命名关键字参数就不再需要一个特殊分隔符*了:\n     \n     def person(name, age, *args, city, job):\n     print(name, age, args, city, job)\n     \n命名关键字参数必须传入参数名,这和位置参数不同.如果没有传入参数名,调用将报错.\n\n使用命名关键字参数时,要特别注意,如果没有可变参数,就必须加一个\\*作为特殊分隔符.如果缺少\\*,Python解释器将无法识别位置参数和命名关键字参数   \n     \n     def person(name, age, city, job):\n        # 缺少 *，city和job被视为位置参数\n        pass\n\n### 参数组合\n在Python中定义函数,可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数,这5种参数都可以组合使用.但是请注意,参数定义的顺序必须是:必选参数、默认参数、可变参数、命名关键字参数和关键字参数.所以,对于任意函数,都可以通过类似func(\\*args, \\*\\*kw)的形式调用它,无论它的参数是如何定义的.虽然可以组合多达5种参数,但不要同时使用太多的组合,否则函数接口的可理解性很差.\n\n### 小结\nPython的函数具有非常灵活的参数形态,既可以实现简单的调用,又可以传入非常复杂的参数.\n默认参数一定要用不可变对象,如果是可变对象,程序运行时会有逻辑错误!\n要注意定义可变参数和关键字参数的语法:\n\\*args是可变参数,args接收的是一个tuple;\n\\*\\*kw是关键字参数,kw接收的是一个dict.\n\n以及调用函数时如何传入可变参数和关键字参数的语法:\n可变参数既可以直接传入:func(1, 2, 3),又可以先组装list或tuple,再通过\\*args传入:func(\\*(1, 2, 3));\n关键字参数既可以直接传入:func(a=1, b=2),又可以先组装dict,再通过\\*\\*kw传入：func(\\*\\*{'a': 1, 'b': 2}).\n\n使用\\*args和\\*\\*kw是Python的习惯写法,当然也可以用其他参数名,但最好使用习惯用法.\n命名的关键字参数是为了限制调用者可以传入的参数名,同时可以提供默认值.\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符\\*,否则定义的将是位置参数.\n\n\n","updated":"2018-04-20T07:20:42.283Z","permalink":"http://yoursite.com/2017/12/13/Python03/","categories":[]},{"title":"Python02","date":"2017-12-05T07:47:13.000Z","path":"2017/12/05/Python02/","text":"list (列表)Python内置一种数据类型是列表:list,list是一种有序的集合,可以随时添加和删除其中的元素;其功效和作用和OC以及swift里的可变数组类似; 用len(xxxx)函数可以获得list元素的个数; 用索引来访问list中每一个位置的元素,索引是从0开始;当索引超出了范围时,Python会报一个IndexError错误,所以,要确保索引不要越界,最后一个元素的索引是len(xxxx) - 1;当用来倒数索引查找的时候,我们可以省略len(xxxx),直接写-1,-2,-3,以此类推; 用append(xxxxxxx)函数可以在list末尾追加元素; 用insert(index,xxxxxxx)函数可以在list中插入元素,且是指定位置插入; 用pop()函数可以删除list末尾的元素; 要删除指定位置的元素,用pop(i)方法,其中i是索引位置; 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置; list里面的元素的数据类型也可以不同; list元素也可以是另一个list; tuple (元组)Python内置另一种有序列表叫元组:tuple,tuple和list非常类似,但是tuple一旦初始化就不能修改;其功效和作用和OC以及swift里的不可变数组类似;tuple没有append()，insert()这样的方法,其他获取元素的方法和list是一样的;因为tuple不可变,所以代码更安全.如果可能,能用tuple代替list就尽量用tuple.当定义一个tuple时,在定义的时候tuple的元素就必须被确定下来;如果要定义一个空的tuple,可以写成();只有1个元素的tuple定义时必须加一个逗号,用来来消除歧义; t(1,) 条件判断elif是else if的缩写 if &lt;条件判断1&gt;: &lt;执行1&gt; elif &lt;条件判断2&gt;: &lt;执行2&gt; elif &lt;条件判断3&gt;: &lt;执行3&gt; else: &lt;执行4&gt; if语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else 循环for in 和 while ;while循环,只要条件满足,就不断循环,条件不满足时退出循环.在循环中,break语句可以提前退出循环.在循环过程中,可以通过continue语句,跳过当前的这次循环,直接开始下一次循环.continue的作用是提前结束本轮循环,并直接开始下一轮循环. dict (dictionary)Python内置了字典：dict的支持,dict全称dictionary,在其他语言中也称为map,使用键-值（key-value）存储,有极快的查找速度.由于一个key只能对应一个value,所以,多次对一个key放入value,后面的值会把前面的值冲掉;如果key不存在,dict就会报错;要避免key不存在的错误,有两种办法:一是通过in判断key是否存在;二是通过dict提供的get()方法,如果key不存在,可以返回None,或者自己指定的value;(返回None的时候Python的交互环境不显示结果)要删除一个key,用pop(key)方法,对应的value也会从dict中删除; 和list比较,dict有以下几个特点: 查找和插入的速度极快,不会随着key的增加而变慢;需要占用大量的内存,内存浪费多.而list相反:查找和插入的时间随着元素的增加而增加;占用空间小,浪费内存很少. 所以,dict是用空间来换取时间的一种方法. dict通过Key找Value的位置遵循的是哈希算法,所以同时也就要求了dict的Key必须具有唯一性,所以dict的Key是一个不可变对象且唯一,要保证hash的正确性,作为key的对象就不能变.在Python中,字符串、整数等都是不可变的,因此,可以放心地作为key.而list是可变的,就不能作为key; setset和dict类似,也是一组key的集合,但不存储value.由于key不能重复,所以,在set中,没有重复的key.通过add(key)方法可以添加元素到set中,可以重复添加,但不会有效果.通过remove(key)方法可以删除元素.set可以看成数学意义上的无序和无重复元素的集合,因此,两个set可以做数学意义上的交集/并集等操作(&amp; 取交集, | 取并集).","raw":"---\ntitle: Python02\ndate: 2017-12-05 15:47:13\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 数据结构\n     - Python 条件判断循环\n---\n\n## list (列表)\nPython内置一种数据类型是列表:list,list是一种有序的集合,可以随时添加和删除其中的元素;\n其功效和作用和OC以及swift里的可变数组类似;\n\n用len(xxxx)函数可以获得list元素的个数;\n\n用索引来访问list中每一个位置的元素,索引是从0开始;当索引超出了范围时,Python会报一个IndexError错误,所以,要确保索引不要越界,最后一个元素的索引是len(xxxx) - 1;当用来倒数索引查找的时候,我们可以省略len(xxxx),直接写-1,-2,-3,以此类推;\n\n用append(xxxxxxx)函数可以在list末尾追加元素;\n\n用insert(index,xxxxxxx)函数可以在list中插入元素,且是指定位置插入;\n\n用pop()函数可以删除list末尾的元素;\n\n要删除指定位置的元素,用pop(i)方法,其中i是索引位置;\n\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置;\n\nlist里面的元素的数据类型也可以不同;\n\nlist元素也可以是另一个list;\n\n## tuple (元组)\nPython内置另一种有序列表叫元组:tuple,tuple和list非常类似,但是tuple一旦初始化就不能修改;\n其功效和作用和OC以及swift里的不可变数组类似;\ntuple没有append()，insert()这样的方法,其他获取元素的方法和list是一样的;\n因为tuple不可变,所以代码更安全.如果可能,能用tuple代替list就尽量用tuple.\n当定义一个tuple时,在定义的时候tuple的元素就必须被确定下来;\n如果要定义一个空的tuple,可以写成();\n只有1个元素的tuple定义时必须加一个逗号,用来来消除歧义;\n    \n    t(1,) \n    \n   \n   \n<!--more-->\n\n    \n## 条件判断\nelif是else if的缩写\n\n    if <条件判断1>:\n         <执行1>\n    elif <条件判断2>:\n         <执行2>\n    elif <条件判断3>:\n         <执行3>\n    else:\n         <执行4>\n    \nif语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else   \n\n## 循环\nfor in 和 while ;\nwhile循环,只要条件满足,就不断循环,条件不满足时退出循环.\n在循环中,break语句可以提前退出循环.\n在循环过程中,可以通过continue语句,跳过当前的这次循环,直接开始下一次循环.continue的作用是提前结束本轮循环,并直接开始下一轮循环.\n\n## dict (dictionary)\nPython内置了字典：dict的支持,dict全称dictionary,在其他语言中也称为map,使用键-值（key-value）存储,有极快的查找速度.\n由于一个key只能对应一个value,所以,多次对一个key放入value,后面的值会把前面的值冲掉;如果key不存在,dict就会报错;\n要避免key不存在的错误,有两种办法:\n一是通过in判断key是否存在;\n二是通过dict提供的get()方法,如果key不存在,可以返回None,或者自己指定的value;\n(返回None的时候Python的交互环境不显示结果)\n要删除一个key,用pop(key)方法,对应的value也会从dict中删除;\n\n和list比较,dict有以下几个特点:\n\n查找和插入的速度极快,不会随着key的增加而变慢;\n需要占用大量的内存,内存浪费多.\n而list相反:\n查找和插入的时间随着元素的增加而增加;\n占用空间小,浪费内存很少.\n\n所以,dict是用空间来换取时间的一种方法.\n\ndict通过Key找Value的位置遵循的是哈希算法,所以同时也就要求了dict的Key必须具有唯一性,所以dict的Key是一个不可变对象且唯一,要保证hash的正确性,作为key的对象就不能变.在Python中,字符串、整数等都是不可变的,因此,可以放心地作为key.而list是可变的,就不能作为key;\n\n## set\nset和dict类似,也是一组key的集合,但不存储value.由于key不能重复,所以,在set中,没有重复的key.\n通过add(key)方法可以添加元素到set中,可以重复添加,但不会有效果.\n通过remove(key)方法可以删除元素.\nset可以看成数学意义上的无序和无重复元素的集合,因此,两个set可以做数学意义上的交集/并集等操作\n(& 取交集, | 取并集).\n\n\n","updated":"2018-04-20T07:20:28.290Z","permalink":"http://yoursite.com/2017/12/05/Python02/","categories":[]},{"title":"Python01","date":"2017-11-29T03:22:20.000Z","path":"2017/11/29/Python01/","text":"Python基础Python的语法比较简单，采用缩进方式 实例: #这里是注释,可以写随便的内容,Python的注释采用# #Python的每一行都是一个语句,假如语句以:结尾,其后缩进的语句相当于代码块 #Python缩进多少个空格还是一个tab的长度呢,没有明确规定,但是约定俗成采用 4 个空格缩进 #为了方便在文本编辑器中，把Tab自动转换为4个空格，确保不混用Tab和空格,可以提高编写效率 #缩进的坏处就是“复制－粘贴”功能失效 #当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确 #此外，ide很难像格式化Java代码那样格式化Python代码 #PS:Python程序是大小写敏感的，是区分大小写的 a = 100 if a &gt;= 0: print(a) else: print(-a) 数据类型1.整数有正负,是精确值,即时是做除法运算也是精确值;2.浮点数,Python支持科学计数法,1.23x109和12.3x108是等同的,在Python上书写用e来代替进位10,也即1.23e9;3.字符串用一对双引号或者一对单引号,即’’或””;当字符串内部也包含’或者”的时候,和C语言一样,需要用转义字符; 如果字符串里面有很多字符都需要转义,就需要加很多\\,为了简化,Python还允许用r’’表示’’内部的字符串默认不转义; 如果字符串内部有很多换行,用\\n写在一行里不好阅读,为了简化,Python允许用’’’…’’’的格式表示多行内容; 注意在输入多行内容时,提示符由&gt;&gt;&gt;变为…,提示你可以接着上一行输入,注意…是提示符,不是代码的一部分;4.布尔值和布尔代数的表示完全一致,一个布尔值只有True、False两种值,要么是True,要么是False,在Python中,可以直接用True、False表示布尔值（请注意大小写）,也可以通过布尔运算计算出来; 布尔值可以用and、or和not运算,对应逻辑里的且或非;5.空值,空值是Python里一个特殊的值,用None表示; 变量语言中的变量的含义和中学课本中的变量的含义表示的内容和意义是一致的;同时变量类型本身不固定的语言多称为动态语言;但是这并不是100%的界定固定的东西,OC和Java在表面上都是静态语言,它们都同时符合静态语言的规定特征,但是OC和Java其实本质上都是动态语言,这是跟具体的语言特性还有关系,OC的Runtime Programming和Java的反射机制; PS:常量常量的本质是不变的变量; 小结:Python在处理整数的时候,它的可精确表达范围要比C语言还大,因为本质上Python直接是用比long long还要大的范围来进行二进制操作的,而对于浮点数而言,所有语言都一样,这是有限内存运算和无限无理数之间的战争 字符编码在最新的Python 3版本中,字符串是以Unicode编码的,也就是说,Python的字符串支持多语言. 格式化Python中,采用的格式化方式和C语言是一致的,用%实现. &gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos; &apos;Hello, world&apos; &gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) &apos;Hi, Michael, you have $1000000.&apos; 有几个%?占位符,后面就跟几个变量或者值,顺序要对应好.如果只有一个%?,括号可以省略.","raw":"---\ntitle: Python01\ndate: 2017-11-29 11:22:20\ncategories:\ntoc: ture\ntags:\n     - Python\n     - Python 基础\n---\n\n# Python基础\n## Python的语法比较简单，采用缩进方式\n 实例:\n    \n    #这里是注释,可以写随便的内容,Python的注释采用#\n    #Python的每一行都是一个语句,假如语句以:结尾,其后缩进的语句相当于代码块\n    #Python缩进多少个空格还是一个tab的长度呢,没有明确规定,但是约定俗成采用 4 个空格缩进\n    #为了方便在文本编辑器中，把Tab自动转换为4个空格，确保不混用Tab和空格,可以提高编写效率\n    #缩进的坏处就是“复制－粘贴”功能失效\n    #当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确\n    #此外，ide很难像格式化Java代码那样格式化Python代码\n    #PS:Python程序是大小写敏感的，是区分大小写的\n    \n    a = 100\n    if a >= 0:\n        print(a)\n    else:\n        print(-a)\n\n\n<!--more-->\n\n\n## 数据类型        \n1.整数有正负,是精确值,即时是做除法运算也是精确值;\n2.浮点数,Python支持科学计数法,1.23x109和12.3x108是等同的,在Python上书写用e来代替进位10,也即1.23e9;\n3.字符串用一对双引号或者一对单引号,即''或\"\";当字符串内部也包含'或者\"的时候,和C语言一样,需要用转义字符;\n  如果字符串里面有很多字符都需要转义,就需要加很多\\,为了简化,Python还允许用r''表示''内部的字符串默认不转义;\n  如果字符串内部有很多换行,用\\n写在一行里不好阅读,为了简化,Python允许用'''...'''的格式表示多行内容;\n  注意在输入多行内容时,提示符由>>>变为...,提示你可以接着上一行输入,注意...是提示符,不是代码的一部分;\n4.布尔值和布尔代数的表示完全一致,一个布尔值只有True、False两种值,要么是True,要么是False,在Python中,可以直接用True、False表示布尔值（请注意大小写）,也可以通过布尔运算计算出来;\n  布尔值可以用and、or和not运算,对应逻辑里的且或非;\n5.空值,空值是Python里一个特殊的值,用None表示;\n\n## 变量\n语言中的变量的含义和中学课本中的变量的含义表示的内容和意义是一致的;\n同时变量类型本身不固定的语言多称为动态语言;\n但是这并不是100%的界定固定的东西,OC和Java在表面上都是静态语言,它们都同时符合静态语言的规定特征,但是OC和Java其实本质上都是动态语言,这是跟具体的语言特性还有关系,OC的Runtime Programming和Java的反射机制;\n\nPS:常量\n常量的本质是不变的变量;\n\n小结:\nPython在处理整数的时候,它的可精确表达范围要比C语言还大,因为本质上Python直接是用比long long还要大的范围来进行二进制操作的,而对于浮点数而言,所有语言都一样,这是有限内存运算和无限无理数之间的战争\n\n\n## 字符编码\n在最新的Python 3版本中,字符串是以Unicode编码的,也就是说,Python的字符串支持多语言.\n\n## 格式化\nPython中,采用的格式化方式和C语言是一致的,用%实现.\n\n    >>> 'Hello, %s' % 'world'\n    'Hello, world'\n    >>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n    'Hi, Michael, you have $1000000.'\n    \n有几个%?占位符,后面就跟几个变量或者值,顺序要对应好.如果只有一个%?,括号可以省略.\n\n\n\n\n        \n\n","updated":"2018-04-20T07:20:12.862Z","permalink":"http://yoursite.com/2017/11/29/Python01/","categories":[]},{"title":"我打算做什么","date":"2017-11-27T08:55:01.000Z","path":"2017/11/27/我打算做什么/","text":"周末，就着3.0版本上架空档期，也感谢组织没有给我额外的任务，让我愉快的放松了两天，心里一直在思忖着：我能做些什么和我打算做些什么。 其实说实话，蛮多的感慨，因为我跟团队大部分人可能并不那么特别相似，其实2月份决定来放弃所有的合肥其他的offer来飞修更大的原因是项目的可行性和项目的公益性，项目可行我们已经用这么长的时间进行了验证，可能很少人会像我一样去考虑项目的公益性，我觉得一个项目的社会价值是假如我们做大了可以给更多的人带来福利，这是做实业，是在建设。会让你在跟别人聊天的时候，从你身上透露着你在兼善天下的牛逼感。 我觉得做好一个东西并不容易，日复一日的为此付出除了实现个人的财务自由挣票子之后，更多的是兴趣和热情的驱动，没有诚挚的心，是没法做成一件事的，只能浮于表面最终消亡。 那天中午，乐一歪着头问我：面试不用拘谨，你抽烟的吧，来一根？ 我笑着，接过烟，点上。 我心里多多少少明白，一个乐于跟你分享的领导，不论他以后变得怎样，但是起码现在不坏，如果你觉得跟他干没意义，可以先干着以后再走。这是我第一感觉。 他说我们在做一个维修项目，要整合合肥维修市场，我们拿到了老乡鸡的投资了，暂时有钱，只要能活过第二年，其他都没问题，包括给你双休。 我说挺好，能开到税后8K么，乐一说他要是不行的话，自己拿工资贴。（最后不用猜，绝对是狗白和小智拒绝了我的税后8K的要求。）即使后来给我电话讲：要是税前8K不能接受的话，那可能不行了，我们团队都是这个薪资，其他人不能同意。 所以我曾多次问过我自己，如果我在外漂泊，在最要奋斗的年纪，为了家庭来到合肥，如果是这辈子最正确的一件事，那么来到飞修也终将是一个以后能津津乐道的缘分。 我不曾抱着最大的恶意揣测任何人，也不曾有意诋毁任何人的能力，那是因为当你一开始用一种有缘，年轻，轻松，是件有意义的事来到一个团队的时候，你难免会对自己也好，对和你配合的人也好，有种过高的期许，所以不可避免说了挺多比较没太给面子的话，我偶尔想想我是不是年纪越往后走，耐心变得是足够了，但是是不是期许也变得越来越大了，还是说这个团队还有很长的路要走，我们还需要更多的相互了解。我希望我这么久以来战斗，都是有意义而被后来接手人能更好的利用。 而作为一个客户端开发，直接跟UI/产品/其他技术团队直接打交到且对配合人期许较高的时候，难免会有点小摩擦，今天得空深刻总结反省，有幸是这些变化都让我们配合的更佳好，矛盾也能及时解决，这令我感到倍感欣慰，会让你觉得你既往所付出的心血，都值得。 今天是我来飞修整整9个月时间，9个月我觉得乐一让我从单休变成了单双休，兑现了他当初跟我讲的让我双休的一半，趁我还是在能加得动班的年纪，我觉这个老板还不坏，也想说这个朋友还不坏，即便哪天不再是老板和员工的关系，也能成为很好的朋友，能遇到一个守信的老板，且和你年纪一样的时候，你要想的是他身上有哪些闪光的东西是你能学的，并为此遇见感到高兴。 9个月的时间里，我只做了一点点卑微的工作，将飞修的客户端从1.0跌代到3.0，没有骄人的成绩，也没有突出的贡献，遵守本分，唯一觉得心里高兴的无非就是赶进度的同时，也能交的出去一份不算质量低的代码；如果需要我给我这9个月的工作打分，我能打9分，最后的1分我保留给刘欢，如果能在接下来的半年里带出来另一个娴熟的客户端开发的话，我觉得，那个时候我的工作是能打10分的，打10分意味着，我对得起老板给我创造的所有优秀的环境，给我发的每一分钱薪水。 从11月初，我就在问自己：假如有一天你能放下所有的事情，真去做一件事情不考虑薪水，不考虑环境的话，你愿意做什么？我想我可能会去做一个科学家研究那些年想做的物理课题研究。那么除了这个呢？做算法吧。 这些年还能激荡起心中热情的二件事，我庆幸还没有变。 飞修团队越来越大，每个岗位上的螺丝钉都要拧紧，然后尽自己最大的能力做好自己的份内的事情，要么被替换，要么收拾行囊离开，每天不虚度时光而过的有意义，你且需要的就是把自己最大热情度能投入的事情和你的工作相结合，如果刚刚好公司也是需要的，那么恭喜你，能成为一个快乐工作的人。 接下来我想试着往数据分析这个方向走一走，能走多远走多专业不知道，适不适合也不了解，但是唯一能让我感到开心和有信心的是：我还有很大的热忱和兴趣。 基于我现在对数据分析的行业了解：数据分析有两种，一种类似产品经理，类似产品经理向更加注重业务，对业务能力要求比较高；一种偏向数据挖掘，数据挖掘向更加注重技术，对算法代码能力要求比较高。 二者共同需要的技术的入门标准都是： SQL。 统计学基础。 Python或者R的基础。 二者有区别的技能树是： A.产品经理向：需要对业务感知能力强，对数据十分敏感，掌握常用的一些业务分析模型套路。为公司的业务负责的方向有：商业分析、数据运营、用户研究、策略分析等等。 B.数据挖掘向：需要牢固的底层基础，编程语言基础、算法、数据结构、统计学知识样样不能少。 于我而言，我是乐于专向数据挖掘方向的，但是这里有会有一个矛盾的点，我可能要一遍兼顾iOS的同时，也要学习新的领域的东西，对于我而言也是一个挑战。 其实我对自己的期许并不是做到一个数据分析师就行了，我对自己的要求是做到战略型数据分析师，能站在数据的角度引领公司整体战略。通过数据分析对公司业务以及行业前景进行预判，为公司制定战略的时候，给出科学的分析依据。进而推动公司战略发展，且能符合投资人的期望值。 乐于把你捕获的信息释法出去，用“人话”说给别人听，且让人听懂，这是一个重要的能力，一个好的数据分析师即便分析能力超群，不能把分析的结果用言语打动老板，让老板相信你跟你走，那么也是一个形同虚设。 以上这些，是我这两天出去玩的时候思考的结果。也有诸多的感慨，唯一能感受到的就是时间过的真快。 昨日之事，历历在目。 此贴留为纪念，日后且看今日决策是否正确如预期。 愿诸君不忘初心，砥砺前行，与君共勉。","raw":"---\ntitle: 我打算做什么\ndate: 2017-11-27 16:55:01\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n周末，就着3.0版本上架空档期，也感谢组织没有给我额外的任务，让我愉快的放松了两天，心里一直在思忖着：我能做些什么和我打算做些什么。\n\n其实说实话，蛮多的感慨，因为我跟团队大部分人可能并不那么特别相似，其实2月份决定来放弃所有的合肥其他的offer来飞修更大的原因是项目的可行性和项目的公益性，项目可行我们已经用这么长的时间进行了验证，可能很少人会像我一样去考虑项目的公益性，我觉得一个项目的社会价值是假如我们做大了可以给更多的人带来福利，这是做实业，是在建设。会让你在跟别人聊天的时候，从你身上透露着你在兼善天下的牛逼感。\n\n<!--more-->\n\n我觉得做好一个东西并不容易，日复一日的为此付出除了实现个人的财务自由挣票子之后，更多的是兴趣和热情的驱动，没有诚挚的心，是没法做成一件事的，只能浮于表面最终消亡。\n\n那天中午，乐一歪着头问我：面试不用拘谨，你抽烟的吧，来一根？\n\n我笑着，接过烟，点上。\n\n我心里多多少少明白，一个乐于跟你分享的领导，不论他以后变得怎样，但是起码现在不坏，如果你觉得跟他干没意义，可以先干着以后再走。这是我第一感觉。\n\n他说我们在做一个维修项目，要整合合肥维修市场，我们拿到了老乡鸡的投资了，暂时有钱，只要能活过第二年，其他都没问题，包括给你双休。\n\n我说挺好，能开到税后8K么，乐一说他要是不行的话，自己拿工资贴。（最后不用猜，绝对是狗白和小智拒绝了我的税后8K的要求。）即使后来给我电话讲：要是税前8K不能接受的话，那可能不行了，我们团队都是这个薪资，其他人不能同意。\n\n\n所以我曾多次问过我自己，如果我在外漂泊，在最要奋斗的年纪，为了家庭来到合肥，如果是这辈子最正确的一件事，那么来到飞修也终将是一个以后能津津乐道的缘分。\n\n我不曾抱着最大的恶意揣测任何人，也不曾有意诋毁任何人的能力，那是因为当你一开始用一种有缘，年轻，轻松，是件有意义的事来到一个团队的时候，你难免会对自己也好，对和你配合的人也好，有种过高的期许，所以不可避免说了挺多比较没太给面子的话，我偶尔想想我是不是年纪越往后走，耐心变得是足够了，但是是不是期许也变得越来越大了，还是说这个团队还有很长的路要走，我们还需要更多的相互了解。我希望我这么久以来战斗，都是有意义而被后来接手人能更好的利用。\n\n而作为一个客户端开发，直接跟UI/产品/其他技术团队直接打交到且对配合人期许较高的时候，难免会有点小摩擦，今天得空深刻总结反省，有幸是这些变化都让我们配合的更佳好，矛盾也能及时解决，这令我感到倍感欣慰，会让你觉得你既往所付出的心血，都值得。\n\n今天是我来飞修整整9个月时间，9个月我觉得乐一让我从单休变成了单双休，兑现了他当初跟我讲的让我双休的一半，趁我还是在能加得动班的年纪，我觉这个老板还不坏，也想说这个朋友还不坏，即便哪天不再是老板和员工的关系，也能成为很好的朋友，能遇到一个守信的老板，且和你年纪一样的时候，你要想的是他身上有哪些闪光的东西是你能学的，并为此遇见感到高兴。\n\n9个月的时间里，我只做了一点点卑微的工作，将飞修的客户端从1.0跌代到3.0，没有骄人的成绩，也没有突出的贡献，遵守本分，唯一觉得心里高兴的无非就是赶进度的同时，也能交的出去一份不算质量低的代码；如果需要我给我这9个月的工作打分，我能打9分，最后的1分我保留给刘欢，如果能在接下来的半年里带出来另一个娴熟的客户端开发的话，我觉得，那个时候我的工作是能打10分的，打10分意味着，我对得起老板给我创造的所有优秀的环境，给我发的每一分钱薪水。\n\n从11月初，我就在问自己：假如有一天你能放下所有的事情，真去做一件事情不考虑薪水，不考虑环境的话，你愿意做什么？我想我可能会去做一个科学家研究那些年想做的物理课题研究。那么除了这个呢？做算法吧。\n\n这些年还能激荡起心中热情的二件事，我庆幸还没有变。\n\n飞修团队越来越大，每个岗位上的螺丝钉都要拧紧，然后尽自己最大的能力做好自己的份内的事情，要么被替换，要么收拾行囊离开，每天不虚度时光而过的有意义，你且需要的就是把自己最大热情度能投入的事情和你的工作相结合，如果刚刚好公司也是需要的，那么恭喜你，能成为一个快乐工作的人。\n\n接下来我想试着往数据分析这个方向走一走，能走多远走多专业不知道，适不适合也不了解，但是唯一能让我感到开心和有信心的是：我还有很大的热忱和兴趣。\n\n基于我现在对数据分析的行业了解：数据分析有两种，一种类似产品经理，类似产品经理向更加注重业务，对业务能力要求比较高；一种偏向数据挖掘，数据挖掘向更加注重技术，对算法代码能力要求比较高。\n\n\n二者共同需要的技术的入门标准都是：\n  1. SQL。\n  2. 统计学基础。\n  3. Python或者R的基础。\n\n\n二者有区别的技能树是：\n  A.产品经理向：需要对业务感知能力强，对数据十分敏感，掌握常用的一些业务分析模型套路。为公司的业务负责的方向有：商业分析、数据运营、用户研究、策略分析等等。\n  B.数据挖掘向：需要牢固的底层基础，编程语言基础、算法、数据结构、统计学知识样样不能少。\n\n\n于我而言，我是乐于专向数据挖掘方向的，但是这里有会有一个矛盾的点，我可能要一遍兼顾iOS的同时，也要学习新的领域的东西，对于我而言也是一个挑战。\n\n其实我对自己的期许并不是做到一个数据分析师就行了，我对自己的要求是做到战略型数据分析师，能站在数据的角度引领公司整体战略。通过数据分析对公司业务以及行业前景进行预判，为公司制定战略的时候，给出科学的分析依据。进而推动公司战略发展，且能符合投资人的期望值。\n\n\n乐于把你捕获的信息释法出去，用“人话”说给别人听，且让人听懂，这是一个重要的能力，一个好的数据分析师即便分析能力超群，不能把分析的结果用言语打动老板，让老板相信你跟你走，那么也是一个形同虚设。\n\n以上这些，是我这两天出去玩的时候思考的结果。也有诸多的感慨，唯一能感受到的就是时间过的真快。\n\n昨日之事，历历在目。\n\n此贴留为纪念，日后且看今日决策是否正确如预期。\n\n愿诸君不忘初心，砥砺前行，与君共勉。\n\n\n\n\n","updated":"2021-06-05T17:58:41.561Z","permalink":"http://yoursite.com/2017/11/27/%E6%88%91%E6%89%93%E7%AE%97%E5%81%9A%E4%BB%80%E4%B9%88/","categories":[]},{"title":"钱塘二渡","date":"2017-11-24T16:21:02.000Z","path":"2017/11/25/钱塘二渡/","text":"对杭州的冲动，不在于贪恋江南小家闺秀的气质。 西湖断桥苏白堤，孤山城中楼外楼。于我而言，一无过往，二无艳羡。 我感兴趣的是每个城市的人，和我相似的人们，是怎样的活着，根本上来讲还是在追寻自己活的最佳方式的过程中，想要寻找一些借鉴，这是我旅行的第一要点，所以美景其实是附属，西溪湿地也好，西湖断桥也罢，都是锦上添花的东西，并不是特别重要。第二要点是共同经历，姑娘说她没有和我去很多地方，我想现在大抵上还是年轻，走一走还是要的，且把时间拉后，倘若一旦为家庭操劳，这些皆是奢求，都只能是心头念。 这次吃了两顿杭帮菜，感觉自己可能并不是由衷的热爱，但是好像也没那么坏，我觉得杭帮菜蛮适合我，不至于吃得太多因为太腻歪；摇橹船的大叔让我别去楼外楼了，他说味道并不会太好，只是吃个名气，没啥意思。我在想，但凡这个世上所有的事情都听人劝，自己不去经历，那还有什么意义，别人的建议永远不会充耳不闻，但也不会照搬俗套，问自己想不想就行了。想吗？那就去哇！有意义吗？那还去干嘛？！我觉得能满足自己的想，就是最大的意义啊。 我跟人开玩笑讲：你在西溪湿地和西湖闲逛的时候，一个晃神，你还以为自己在汤池的相思林和金汤湖水库上逛。于苏杭本地人而言，楼外楼外养鱼塘西湖，此般小家碧玉的景致，自不能让人热血沸腾，唯恐是个虚名罢了，自然比不上广阔的天地宏伟的景观，可让人短暂抛却烦心事，也不算太差。 10月中旬，公司安排参加云栖大会，四天繁忙的交流讲座学习，时间甚是紧迫，外加阴雨绵绵，姑娘讨厌雨天，所以那次杭州的偷闲得空的游逛也随之搁浅。 云栖大会让我想起了早些年在深圳隔月的“深圳巅峰技术交流会”，跟荣杰蹭饭聚会的同时，和立华他们吹着牛，聊着好多想做却能力不够做不了的事情，那个时候感觉我们这些人都是互联网的希望，我们想做智能家居，我们想做很多东西，想解决最后一公里的需求，想创业想挣票子，这些大抵是那个时候的想法。 那个时候聊天的内容，很多东西上次在云栖大会上都见到了，仅仅是过了3-4年而已，我们吹的牛已经被这些互联网大佬变现了，我们要搞的无人机快递，我们要搞的人工智能汽车，我们要搞的人工智能家居，我们聊到的神经网络算法的应用于方方面面的同时，还有神经网络对超参数的各种优化，子模函数超模函数的概念，提高了精确度和算法速度的同时极大程度上缩短了神经网络算法参数的确定时间，也就实现了快速获取神经网络算法模型。举个简单的例子并用人话来说就是：现在的技术可以达到用高速运行的相机拍照或者录制视频的同时，就可以进行同步识别了。 而3-4年前我们在深圳闲聊的时候说的要做实时的监控识别的想法，最大的技术门槛就是在于实时识别的反馈结果。那次我在听云栖的技术报告交流的时候，最大的感慨并不是这些大厂好厉害，这些学者好牛，而是感叹道：时间过的真快，好想回到那些年轻的岁月，多做那些有意义的事情。 我庆幸现在在很多事情上的努力有所回馈，也感谢自己的年轻，好多可以做的事情还有机会去做，除了庆幸就是感恩，感谢生命里遇到了这么多有意思的事和那些年已遇的奇迹。 经历放在纵向的意义上来看就会显得尤其的突出和重要，平行时间里的经历，永远都是未知的啊，经历只有有用的时候才会是经历，不然你会觉得是虚度。 经历了人和事，阅千重山行万里路，丰富生命的宽度，让自己在遇到的时候不会惊慌失措，不会变的无畏无知，而是从容淡然，想热血的时候热血，想激动的时候激动，这才是极佳的。 大抵上如此，日子慢悠悠的过。忙的时候疯狂陷入一种状态固然是充实的，但是还是要多走动多陪陪身边的人。注意休息注意身体健康，世间事，除死无大事，能活着，健康的活着比什么都强。 贪恋啊，红尘太过于美好，生活即便残酷，也还有精彩之处。 所以决定给博客开个新的板块。这也是城南旧事存在的意义。","raw":"---\ntitle: 钱塘二渡\ndate: 2017-11-25 00:21:02\ncategories:\ntoc: false\ntags:\n     - Essays\n     - 杭州\n---\n\n\n对杭州的冲动，不在于贪恋江南小家闺秀的气质。\n\n\n西湖断桥苏白堤，孤山城中楼外楼。于我而言，一无过往，二无艳羡。\n\n\n我感兴趣的是每个城市的人，和我相似的人们，是怎样的活着，根本上来讲还是在追寻自己活的最佳方式的过程中，想要寻找一些借鉴，这是我旅行的第一要点，所以美景其实是附属，西溪湿地也好，西湖断桥也罢，都是锦上添花的东西，并不是特别重要。第二要点是共同经历，姑娘说她没有和我去很多地方，我想现在大抵上还是年轻，走一走还是要的，且把时间拉后，倘若一旦为家庭操劳，这些皆是奢求，都只能是心头念。\n\n\n<!--more-->\n\n\n这次吃了两顿杭帮菜，感觉自己可能并不是由衷的热爱，但是好像也没那么坏，我觉得杭帮菜蛮适合我，不至于吃得太多因为太腻歪；摇橹船的大叔让我别去楼外楼了，他说味道并不会太好，只是吃个名气，没啥意思。我在想，但凡这个世上所有的事情都听人劝，自己不去经历，那还有什么意义，别人的建议永远不会充耳不闻，但也不会照搬俗套，问自己想不想就行了。想吗？那就去哇！有意义吗？那还去干嘛？！我觉得能满足自己的想，就是最大的意义啊。\n\n\n我跟人开玩笑讲：你在西溪湿地和西湖闲逛的时候，一个晃神，你还以为自己在汤池的相思林和金汤湖水库上逛。于苏杭本地人而言，楼外楼外养鱼塘西湖，此般小家碧玉的景致，自不能让人热血沸腾，唯恐是个虚名罢了，自然比不上广阔的天地宏伟的景观，可让人短暂抛却烦心事，也不算太差。\n\n\n10月中旬，公司安排参加云栖大会，四天繁忙的交流讲座学习，时间甚是紧迫，外加阴雨绵绵，姑娘讨厌雨天，所以那次杭州的偷闲得空的游逛也随之搁浅。\n\n\n云栖大会让我想起了早些年在深圳隔月的“深圳巅峰技术交流会”，跟荣杰蹭饭聚会的同时，和立华他们吹着牛，聊着好多想做却能力不够做不了的事情，那个时候感觉我们这些人都是互联网的希望，我们想做智能家居，我们想做很多东西，想解决最后一公里的需求，想创业想挣票子，这些大抵是那个时候的想法。\n\n\n那个时候聊天的内容，很多东西上次在云栖大会上都见到了，仅仅是过了3-4年而已，我们吹的牛已经被这些互联网大佬变现了，我们要搞的无人机快递，我们要搞的人工智能汽车，我们要搞的人工智能家居，我们聊到的神经网络算法的应用于方方面面的同时，还有神经网络对超参数的各种优化，子模函数超模函数的概念，提高了精确度和算法速度的同时极大程度上缩短了神经网络算法参数的确定时间，也就实现了快速获取神经网络算法模型。举个简单的例子并用人话来说就是：现在的技术可以达到用高速运行的相机拍照或者录制视频的同时，就可以进行同步识别了。\n\n\n而3-4年前我们在深圳闲聊的时候说的要做实时的监控识别的想法，最大的技术门槛就是在于实时识别的反馈结果。那次我在听云栖的技术报告交流的时候，最大的感慨并不是这些大厂好厉害，这些学者好牛，而是感叹道：时间过的真快，好想回到那些年轻的岁月，多做那些有意义的事情。\n\n\n我庆幸现在在很多事情上的努力有所回馈，也感谢自己的年轻，好多可以做的事情还有机会去做，除了庆幸就是感恩，感谢生命里遇到了这么多有意思的事和那些年已遇的奇迹。\n\n\n经历放在纵向的意义上来看就会显得尤其的突出和重要，平行时间里的经历，永远都是未知的啊，经历只有有用的时候才会是经历，不然你会觉得是虚度。\n\n\n经历了人和事，阅千重山行万里路，丰富生命的宽度，让自己在遇到的时候不会惊慌失措，不会变的无畏无知，而是从容淡然，想热血的时候热血，想激动的时候激动，这才是极佳的。\n\n\n大抵上如此，日子慢悠悠的过。忙的时候疯狂陷入一种状态固然是充实的，但是还是要多走动多陪陪身边的人。注意休息注意身体健康，世间事，除死无大事，能活着，健康的活着比什么都强。\n\n\n贪恋啊，红尘太过于美好，生活即便残酷，也还有精彩之处。\n\n\n所以决定给博客开个新的板块。这也是城南旧事存在的意义。\n\n\n","updated":"2021-06-05T17:14:52.399Z","permalink":"http://yoursite.com/2017/11/25/%E9%92%B1%E5%A1%98%E4%BA%8C%E6%B8%A1/","categories":[]},{"title":"weak singleton模式在iOS中的应用","date":"2017-07-19T07:44:41.000Z","path":"2017/07/19/weak-singleton模式在iOS中的应用/","text":"关于weak要了解的基本内容： weak的使用场景: weak 的常见场景是在 delegate,block,NSTimer 中使用,我们经常用weak来避免以上场景中易产生的循环引用的问题. weak的实际作用是:弱引用,在对象释放后置为 nil,避免错误的内存访问.也就是说:weak 可以在不增加对象的引用计数的同时,又使得指针的访问是安全的. 单例模式在OC和Swift这经常会被用到,好用的小模块工具类、很多SDK的初始化等等.但是这些单例的使用场景里都有一个共同的毛病,单例在被创建之后会伴随着进程一直存活,有时候我们的业务需求,特别是对于前端来说的话,很多单例模式的使用都是为了方便,所以我们其实很想在这些单例不必要存在的时候将它们释放掉,因为这些单例在一定程度上是有内存浪费的. 一个简单的例子:比如登陆模块的 LoginInstance 单例,我们在登陆之后除非需要二次登陆,不然就可能再也用不到这个单例了,我们最好的处理方式是将这个单例释放掉在登陆之后,而在登陆的过程当中我们随时随地的获取和使用这个单例,似乎这样的应用场景在前端开发中显得更多以及更常用,也似乎更佳的合理,更好的符合前端的性能尽可能的高的这种默认标准. 可是常规的单例模式无法实现上述需求,我们只能做到随时随地的获取使用这个单例,而无法释法这个单例. 那么,用weak试一下吧. 弱单例模式的 weak singleton 的具体实现代码如下+ (id)sharedInstance &#123; static __weak ASingletonClass *instance; ASingletonClass *strongInstance = instance; @synchronized(self) &#123; if (strongInstance == nil) &#123; strongInstance = [[[self class] alloc] init]; instance = strongInstance; &#125; &#125; return strongInstance; &#125; 这种特殊的单例有一个有意思的特性:在所有使用该单例的对象都释放后,单例对象本身也会自己释放. 如果 viewController A、B、C 三个视图控制器都调用了上面所描述的这种弱引用的弱单例模式.并且 viewController A、B、C 都持有 ASingletonClass 的强引用,一旦 A，B，C 都销毁后,这个单例就跟着销毁,而这个就跟我们之前的单例模式不一样了,它不会是从创建后就只能一直存在,无法释放. 这样我们再一次回到上述的登陆模块的时候,当我们的登陆控制器在棧里被释放掉之后,登陆的LoginInstance 单例也会随即释放,这样就达到了我们想要的效果. 此外重要的是:当 LoginInstance 再次被调用时,LoginInstance 又会重新被创建.这样二次登陆的时候,LoginInstance 还是一个单例. 然而我们会发现:weak singleton 这种弱单例模式中的 weak ,有着很漂亮的作用,巧妙的利用了weak的作用来设计了一种我们很想要的效果的模式,从而也看出来,对于关键词weak而言,还有很多能发现的美.","raw":"---\ntitle: weak singleton模式在iOS中的应用\ndate: 2017-07-19 15:44:41\ncategories:\ntoc: true\ntags:\n     - OC\n     - weak\n     - weak singleton\n     - 弱单例模式\n---\n\n# 关于weak要了解的基本内容：\n***\nweak的使用场景: weak 的常见场景是在 delegate,block,NSTimer 中使用,我们经常用weak来避免以上场景中易产生的循环引用的问题.\n\nweak的实际作用是:弱引用,在对象释放后置为 nil,避免错误的内存访问.也就是说:weak 可以在不增加对象的引用计数的同时,又使得指针的访问是安全的.\n***\n\n单例模式在OC和Swift这经常会被用到,好用的小模块工具类、很多SDK的初始化等等.但是这些单例的使用场景里都有一个共同的毛病,单例在被创建之后会伴随着进程一直存活,有时候我们的业务需求,特别是对于前端来说的话,很多单例模式的使用都是为了方便,所以我们其实很想在这些单例不必要存在的时候将它们释放掉,因为这些单例在一定程度上是有内存浪费的.\n\n<!--more-->\n\n一个简单的例子:比如登陆模块的 LoginInstance 单例,我们在登陆之后除非需要二次登陆,不然就可能再也用不到这个单例了,我们最好的处理方式是将这个单例释放掉在登陆之后,而在登陆的过程当中我们随时随地的获取和使用这个单例,似乎这样的应用场景在前端开发中显得更多以及更常用,也似乎更佳的合理,更好的符合前端的性能尽可能的高的这种默认标准.\n\n可是常规的单例模式无法实现上述需求,我们只能做到随时随地的获取使用这个单例,而无法释法这个单例.\n\n那么,用weak试一下吧.\n\n\n\n# 弱单例模式的 weak singleton 的具体实现代码如下\n\n    + (id)sharedInstance {\n       static __weak ASingletonClass *instance;\n       ASingletonClass *strongInstance = instance;\n       @synchronized(self) {\n          if (strongInstance == nil) {\n            strongInstance = [[[self class] alloc] init];\n            instance = strongInstance;\n          }\n       }\n       return strongInstance;\n    }\n\n这种特殊的单例有一个有意思的特性:在所有使用该单例的对象都释放后,单例对象本身也会自己释放.\n\n如果 viewController A、B、C 三个视图控制器都调用了上面所描述的这种弱引用的弱单例模式.并且 viewController A、B、C 都持有 ASingletonClass 的强引用,一旦 A，B，C 都销毁后,这个单例就跟着销毁,而这个就跟我们之前的单例模式不一样了,它不会是从创建后就只能一直存在,无法释放.\n\n这样我们再一次回到上述的登陆模块的时候,当我们的登陆控制器在棧里被释放掉之后,登陆的LoginInstance 单例也会随即释放,这样就达到了我们想要的效果.\n\n此外重要的是:当 LoginInstance 再次被调用时,LoginInstance 又会重新被创建.这样二次登陆的时候,LoginInstance 还是一个单例.\n\n然而我们会发现:weak singleton 这种弱单例模式中的 weak ,有着很漂亮的作用,巧妙的利用了weak的作用来设计了一种我们很想要的效果的模式,从而也看出来,对于关键词weak而言,还有很多能发现的美.\n\n\n","updated":"2021-06-05T18:04:06.852Z","permalink":"http://yoursite.com/2017/07/19/weak-singleton%E6%A8%A1%E5%BC%8F%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","categories":[]},{"title":"冷暖自知","date":"2017-03-31T16:16:31.000Z","path":"2017/04/01/冷暖自知/","text":"今天晚上9点多写代码的时候，刘玉琦用电脑放了一首《萍聚》，霎那间被旋律带出了些许的难受。 很感谢尚且足够年轻的自己，感谢自己拥有一个每天爬起来都充满干劲的自己。我仔细的回忆了一下，我已经将近有3年的时间，不曾惶惶度日，从那一刻感到考研复习学习的时间不够的大四开始，我就每天都在数着时间过日子。 虽然有挺多时候熬夜特别幸苦，感到胸闷呼吸不够舒畅，但是好在身体并无大碍，我知道我亏欠年轻的自己太多，所以我好想爬的足够快，快到我自己可以为自己所做的事情开心。 我深感自己的平凡，但心里总会充满了对平庸的不甘和对庸俗的愤怒，但你却不得不承认，一个人的能力很有限。但是每次挫败的时候，我都在问自己做的够好不。 自从心里想好好写代码到现在，无时无刻不深感自己的无力，不是所有的事情都和学习成长般简单，你认识到了这世间还有事情是花时间是不够的。编程像一个无底深渊，没有最好，只有更好，一个没有极限的东西，你穷极所有时间，最后只会换来筋疲力竭的妥协。然后臭骂自己一句：你还是那么没用，毫无是处。 现如今二十多岁，不用多久就三十岁了，好可怕，我瞧瞧我自己，我的确很没用。而立之年，何立？我深知自己的现状，我想好好努力，让自己喜欢，一直过的很煎熬，我挣扎的这一二三年里时间都过的好快，快的我措手不及，让我愈发慌乱。 是我自己疯了，太心急想一口吃一个胖子，是我还没有好好沉下心来，做足够好的自己，是我太自负，自负到我以为很多事情很简单，但往往比预期漫长得太多。 但是我这个人好贱的，我不希望别人说我没用。我只知道这个世界上，有些你越在乎的人，肆无忌惮的说挺多话都是伤人的，但是好贱，你却要原谅他们。这些碎言碎语，往往会让我想很多，想很久。你看我就是这么矫情。 我觉得我始终是个不负责任的人，妄想用年轻的所有精力来对未来好好负责，往往过不好当下。一个不懂得照顾自己的人，不懂得生活的人，不注重身体健康的人，的确有可嫌之处。也难为你们老说我是个傻逼，大抵说的都对，没有错。 我不愿意我在乎的人说要去乞讨来过好生活，或者为了满足自己的某些物质生活。我可以自己活的没尊严，但是不愿意我心里的你们活的比我难堪。倘若生活中的你们因为遇到我而变得如此艰辛，我愿意远离你们，我愿承担所有，只想你们能快乐。 假如生活是一场旅行，我愿意做那个留下的人，当我们不足以两个人一起上路的时候，我会囊倾所有，祝你一臂之力。所以这次小长假里，我写代码累了，或者我睡前翻朋友圈，能看到照片中你们的笑脸，我想我做出的这些努力，总是能过自己这一关的。这世上最难尽之事不就是让自己想通么？ 我做的事情不完美，但是我会在能力范围内能做到的足够的完美，这是我跟你们相处，跟家人相爱，所能做的极限。所以如果你让我连聚精会神专注做事最后这点仅有的快乐你都不允许的话，那我怎么面对如此艰辛的生活？怎么麻痹自己让自己觉得还有希望？ 大学四年打了快上万盘的dota，放了整整一年多没玩，我好佩服老甲，在很忙的时候也有勇气拿起吉他玩起来。 2015年国庆的时候跟自己说2016年的国庆要去一次西藏，每次把手机备忘录打开，还能看到那条没做的愿望我就好难过，我向生活妥协了，我是个没原则的人。后来受不了自己，偷偷又把那条备忘录删掉了。 我想这些年我都没有做过什么单独背个包去走一走，和陌生人坐在一个桌子上吃顿饭，在旅途中跟陌生人点根烟，一起聊聊风俗乡土和流水光阴里别人奋斗的故事。 唉。所以别管以后将如何，冷暖自愿尝透。 今天又是愚人节，但是我说的话又有多少是真的呢，对自己说的都是假的，对你而言都是真的。 你们明日，若是去了远方，踏上火车，望住窗外，飞越过几十个小镇，几千里土地，几千万个人。你不要怀疑，你的一生里，唯一可以相遇的机会，不在目的地，而在起点，那个愿意等你人往往是心甘情愿送你走的人。","raw":"---\ntitle: 冷暖自知\ndate: 2017-04-01 00:16:31\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n今天晚上9点多写代码的时候，刘玉琦用电脑放了一首《萍聚》，霎那间被旋律带出了些许的难受。\n\n很感谢尚且足够年轻的自己，感谢自己拥有一个每天爬起来都充满干劲的自己。我仔细的回忆了一下，我已经将近有3年的时间，不曾惶惶度日，从那一刻感到考研复习学习的时间不够的大四开始，我就每天都在数着时间过日子。\n\n<!--more-->\n\n虽然有挺多时候熬夜特别幸苦，感到胸闷呼吸不够舒畅，但是好在身体并无大碍，我知道我亏欠年轻的自己太多，所以我好想爬的足够快，快到我自己可以为自己所做的事情开心。\n\n我深感自己的平凡，但心里总会充满了对平庸的不甘和对庸俗的愤怒，但你却不得不承认，一个人的能力很有限。但是每次挫败的时候，我都在问自己做的够好不。\n\n自从心里想好好写代码到现在，无时无刻不深感自己的无力，不是所有的事情都和学习成长般简单，你认识到了这世间还有事情是花时间是不够的。编程像一个无底深渊，没有最好，只有更好，一个没有极限的东西，你穷极所有时间，最后只会换来筋疲力竭的妥协。然后臭骂自己一句：你还是那么没用，毫无是处。\n\n现如今二十多岁，不用多久就三十岁了，好可怕，我瞧瞧我自己，我的确很没用。而立之年，何立？我深知自己的现状，我想好好努力，让自己喜欢，一直过的很煎熬，我挣扎的这一二三年里时间都过的好快，快的我措手不及，让我愈发慌乱。\n\n是我自己疯了，太心急想一口吃一个胖子，是我还没有好好沉下心来，做足够好的自己，是我太自负，自负到我以为很多事情很简单，但往往比预期漫长得太多。\n\n但是我这个人好贱的，我不希望别人说我没用。我只知道这个世界上，有些你越在乎的人，肆无忌惮的说挺多话都是伤人的，但是好贱，你却要原谅他们。这些碎言碎语，往往会让我想很多，想很久。你看我就是这么矫情。\n\n我觉得我始终是个不负责任的人，妄想用年轻的所有精力来对未来好好负责，往往过不好当下。一个不懂得照顾自己的人，不懂得生活的人，不注重身体健康的人，的确有可嫌之处。也难为你们老说我是个傻逼，大抵说的都对，没有错。\n\n我不愿意我在乎的人说要去乞讨来过好生活，或者为了满足自己的某些物质生活。我可以自己活的没尊严，但是不愿意我心里的你们活的比我难堪。倘若生活中的你们因为遇到我而变得如此艰辛，我愿意远离你们，我愿承担所有，只想你们能快乐。\n\n假如生活是一场旅行，我愿意做那个留下的人，当我们不足以两个人一起上路的时候，我会囊倾所有，祝你一臂之力。所以这次小长假里，我写代码累了，或者我睡前翻朋友圈，能看到照片中你们的笑脸，我想我做出的这些努力，总是能过自己这一关的。这世上最难尽之事不就是让自己想通么？\n\n我做的事情不完美，但是我会在能力范围内能做到的足够的完美，这是我跟你们相处，跟家人相爱，所能做的极限。所以如果你让我连聚精会神专注做事最后这点仅有的快乐你都不允许的话，那我怎么面对如此艰辛的生活？怎么麻痹自己让自己觉得还有希望？\n\n大学四年打了快上万盘的dota，放了整整一年多没玩，我好佩服老甲，在很忙的时候也有勇气拿起吉他玩起来。\n\n2015年国庆的时候跟自己说2016年的国庆要去一次西藏，每次把手机备忘录打开，还能看到那条没做的愿望我就好难过，我向生活妥协了，我是个没原则的人。后来受不了自己，偷偷又把那条备忘录删掉了。\n\n我想这些年我都没有做过什么单独背个包去走一走，和陌生人坐在一个桌子上吃顿饭，在旅途中跟陌生人点根烟，一起聊聊风俗乡土和流水光阴里别人奋斗的故事。\n\n唉。所以别管以后将如何，冷暖自愿尝透。\n\n今天又是愚人节，但是我说的话又有多少是真的呢，对自己说的都是假的，对你而言都是真的。\n\n你们明日，若是去了远方，踏上火车，望住窗外，飞越过几十个小镇，几千里土地，几千万个人。你不要怀疑，你的一生里，唯一可以相遇的机会，不在目的地，而在起点，那个愿意等你人往往是心甘情愿送你走的人。\n\n","updated":"2021-06-05T18:03:36.168Z","permalink":"http://yoursite.com/2017/04/01/%E5%86%B7%E6%9A%96%E8%87%AA%E7%9F%A5/","categories":[]},{"title":"JavaScript05","date":"2017-03-03T04:05:27.000Z","path":"2017/03/03/JavaScript05/","text":"HTML DOM （文档对象模型） 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 从目前我了解的情况来看，JS可以做到以下几点： 1.JavaScript 能够改变页面中的所有 HTML 元素 2.JavaScript 能够改变页面中的所有 HTML 属性 3.JavaScript 能够改变页面中的所有 CSS 样式 4.JavaScript 能够对页面中的所有事件做出反应 对于JavaScript而言，更加关心的是如何找到 HTML 元素，要是找不到 HTML 元素的话，就没法实施操作，而JS中给我们提供了三种方法去找HTML 元素： 1.通过 id 找到 HTML 元素 2.通过标签名找到 HTML 元素 3.通过类名找到 HTML 元素 ①通过 id 查找 HTML 元素 例:查找id为”intro”的元素 var x = document.getElementById(&quot;intro&quot;); ②通过标签名查找 HTML 元素 例:查找 id=”main” 的元素，然后查找 “main” 中的所有 元素 var x = document.getElementById(&quot;main&quot;); var y = x.getElementsByTagName(&quot;p&quot;); ③通过类名查找 HTML 元素在 IE 5,6,7,8 中无效。 在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。但是不要在文档加载之后使用 document.write()。这会覆盖该文档。 改变 HTML 内容: 修改 HTML 内容的最简单的方法时使用 innerHTML 属性。如需改变 HTML 元素的内容，怎么用下面的语句： document.getElementById(id).innerHTML = new HTML","raw":"---\ntitle: JavaScript05\ndate: 2017-03-03 12:05:27\ncategories:\ntoc: false\ntags:\n     - JavaScript\n     - JavaScript HTML DOM\n     - JavaScript HTML\n---\n\nHTML DOM （文档对象模型）\n\n当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。\n\nHTML DOM 模型被构造为对象的树。\n\n\n![JavaScript02](http://olnzmhc4r.bkt.clouddn.com/JavaScript02.png)\n\n\n从目前我了解的情况来看，JS可以做到以下几点：\n\n1.JavaScript 能够改变页面中的所有 HTML 元素\n\n2.JavaScript 能够改变页面中的所有 HTML 属性\n\n3.JavaScript 能够改变页面中的所有 CSS 样式\n\n4.JavaScript 能够对页面中的所有事件做出反应\n\n<!--more-->\n***\n\n对于JavaScript而言，更加关心的是如何找到 HTML 元素，要是找不到 HTML 元素的话，就没法实施操作，而JS中给我们提供了三种方法去找HTML 元素：\n\n1.通过 id 找到 HTML 元素\n\n2.通过标签名找到 HTML 元素\n\n3.通过类名找到 HTML 元素\n\n\n①通过 id 查找 HTML 元素\n\n例:查找id为\"intro\"的元素\n\n    var x = document.getElementById(\"intro\");\n    \n②通过标签名查找 HTML 元素\n\n例:查找 id=\"main\" 的元素，然后查找 \"main\" 中的所有 <p> 元素\n\n    var x = document.getElementById(\"main\");\n    var y = x.getElementsByTagName(\"p\");\n    \n\n③通过类名查找 HTML 元素在 IE 5,6,7,8 中无效。\n\n\n***\n\n在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。但是不要在文档加载之后使用 document.write()。这会覆盖该文档。\n\n改变 HTML 内容:\n\n修改 HTML 内容的最简单的方法时使用 innerHTML 属性。如需改变 HTML 元素的内容，怎么用下面的语句：\n\n    document.getElementById(id).innerHTML = new HTML \n    \n    \n","updated":"2017-11-24T06:58:03.856Z","permalink":"http://yoursite.com/2017/03/03/JavaScript05/","categories":[]},{"title":"JavaScript04","date":"2017-03-03T02:53:36.000Z","path":"2017/03/03/JavaScript04/","text":"JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。 常见的 JavaScript 验证的这些典型的表单数据有： 用户是否已填写表单中的必填项目？ 用户输入的邮件地址是否合法？ 用户是否在数据域 (numeric field) 中输入了文本？ function validate_required(field,alerttxt) &#123; with (field) &#123; if (value == null || value == &quot;&quot;) &#123; alert(alerttxt); return false; &#125; else &#123; return true; &#125; &#125; &#125; 有个经典的关于邮箱地址的验证： function validate_email(field,alerttxt) &#123; with (field) &#123; apos = value.indexOf(&quot;@&quot;) dotpos = value.lastIndexOf(&quot;.&quot;) if (apos&lt;1||dotpos-apos&lt;2) &#123; alert(alerttxt); return false; &#125; else &#123; return true; &#125; &#125; &#125; 一开始对上面的函数并不陌生，但是仔细一瞅发现中间多了一个 with（field） 查阅资料看了一下JS中的with语句的用法： with语句为一个或一组语句指定默认对象。 with语句可以方便地用来引用某个特定对象中已有的属性，不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。 with的语句结构： with(object instance) &#123; //代码块 &#125; 对比下面二段代码会发现功能是一样的，但是明显有with语句的代码可读性更强，并且易于理解。 x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10); y = Math.tan(14 * Math.E); with (Math) &#123; x = cos(3 * PI) + sin(LN10); y = tan(14 * E); &#125; PS：但是with语句即使带来了很多方便的地方，它也有不好的之处：with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。 除了with有引用对象的作用，在JS中另一个this语句也很常见。 this 对象 是返回“当前”对象。在不同的地方，this代表不同的对象。如果在 JavaScript 的“主程序”中（不在任何 function 中，不在任何事件处理程序中）使用 this，它就代表 window 对象；如果在 with 语句块中使用 this，它就代表 with 所指定的对象；如果在事件处理程序中使用 this，它就代表发生事件的对象。 this的这个浅层意思和OC语言中的self很类似。当然这里仅仅只是用于类比理解。 下面有个this常见的用法，用于立刻检测表单输入的有效性。 &lt;script&gt; ... function check(formObj) &#123; ... &#125; ... &lt;/script&gt; &lt;body ...&gt; ... &lt;form ...&gt; ... &lt;input type=&quot;text&quot; ... onchange=&quot;check(this.form)&quot;&gt; ... &lt;/form&gt; ... &lt;/body&gt;","raw":"---\ntitle: JavaScript04\ndate: 2017-03-03 10:53:36\ncategories:\ntoc: false\ntags:\n     - JavaScript\n     - JavaScript 表单验证\n     - JavaScript with语句\n     - JavaScript this语句\n---\n\nJavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。\n\n>常见的 JavaScript 验证的这些典型的表单数据有：\n>\n>用户是否已填写表单中的必填项目？\n>\n>用户输入的邮件地址是否合法？\n>\n>用户是否在数据域 (numeric field) 中输入了文本？\n\n\n    function validate_required(field,alerttxt) \n    {\n       with (field) \n       {\n         if (value == null || value == \"\")\n         {\n\t         alert(alerttxt);\n\t         return false;\n         }\n         else \n         {\n\t         return true;\n         }\n       }\n    }\n\n\n有个经典的关于邮箱地址的验证：\n\n     function validate_email(field,alerttxt)\n     {\n       with (field)\n       {\n         apos = value.indexOf(\"@\")\n         dotpos = value.lastIndexOf(\".\")\n         if (apos<1||dotpos-apos<2) \n         {\n           alert(alerttxt);\n           return false;\n         }\n         else \n         {\n           return true;\n         }\n        }\n      }\n      \n<!--more-->\n\n一开始对上面的函数并不陌生，但是仔细一瞅发现中间多了一个\n\n    with（field）\n    \n查阅资料看了一下JS中的with语句的用法：\n\nwith语句为一个或一组语句指定默认对象。\n\n>with语句可以方便地用来引用某个特定对象中已有的属性，不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  \n\nwith的语句结构：\n\n    with(object instance) \n    {  \n        //代码块 \n    }  \n\n对比下面二段代码会发现功能是一样的，但是明显有with语句的代码可读性更强，并且易于理解。\n\n    x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10);\n    y = Math.tan(14 * Math.E);\n    \n    \n***\n    \n    with (Math) \n    {\n      x = cos(3 * PI) + sin(LN10);\n      y = tan(14 * E);\n    }\n    \n    \n\n>PS：但是with语句即使带来了很多方便的地方，它也有不好的之处：with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。 \n\n\n除了with有引用对象的作用，在JS中另一个this语句也很常见。\n\nthis 对象 是返回“当前”对象。在不同的地方，this代表不同的对象。如果在 JavaScript 的“主程序”中（不在任何 function 中，不在任何事件处理程序中）使用 this，它就代表 window 对象；如果在 with 语句块中使用 this，它就代表 with 所指定的对象；如果在事件处理程序中使用 this，它就代表发生事件的对象。\n\nthis的这个浅层意思和OC语言中的self很类似。当然这里仅仅只是用于类比理解。\n\n下面有个this常见的用法，用于立刻检测表单输入的有效性。\n\n\n    <script>\n    ...\n    function check(formObj) {\n    ...\n    }\n    ...\n    </script>\n    <body ...>\n    ...\n    <form ...>\n    ...\n    <input type=\"text\" ... onchange=\"check(this.form)\">\n    ...\n    </form>\n    ...\n    </body>\n\n","updated":"2017-11-24T06:57:46.182Z","permalink":"http://yoursite.com/2017/03/03/JavaScript04/","categories":[]},{"title":"JavaScript03","date":"2017-03-02T09:04:23.000Z","path":"2017/03/02/JavaScript03/","text":"JavaScript的 try/catch/throw 语句的用法: 做iOS开发的时候，调试的时候也会用到这些内容，由于之前开发用这些比较少，所以先来重温一下OC的相关语句，大同小异。 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 在OC中，经常用到下面的代码块来捕捉异常 @try &#123; // 可能会出现崩溃的代码 &#125; @catch (NSException *exception) &#123; // 捕获到的异常exception &#125; @finally &#123; // 结果处理 &#125; 下面有个比较详细的OC调试的过程的代码： @try &#123; // 1 [self tryTwo]; &#125; @catch (NSException *exception) &#123; // 2 NSLog(@&quot;%s\\n%@&quot;, __FUNCTION__, exception); // @throw exception; // 这里不能再抛异常 &#125; @finally &#123; // 3 NSLog(@&quot;我一定会执行&quot;); &#125; // 4 // 这里一定会执行 NSLog(@&quot;try&quot;); - (void)tryTwo &#123; @try &#123; // 5 NSString *str = @&quot;abc&quot;; [str substringFromIndex:111]; // 程序到这里会崩 &#125; @catch (NSException *exception) &#123; // 6 // @throw exception; // 抛出异常，即由上一级处理 // 7 NSLog(@&quot;%s\\n%@&quot;, __FUNCTION__, exception); &#125; @finally &#123; // 8 NSLog(@&quot;tryTwo - 我一定会执行&quot;); &#125; // 9 // 如果抛出异常，那么这段代码则不会执行 NSLog(@&quot;如果这里抛出异常，那么这段代码则不会执行&quot;); &#125; 如果6抛出异常，那么执行顺序为：1-&gt;5-&gt;6-&gt;8-&gt;3-&gt;4 如果6没抛出异常，那么执行顺序为：1-&gt;5-&gt;7-&gt;8-&gt;9-&gt;3-&gt;4 Objective-C将可能出现异常的代码放在@try块中，所有的异常处理逻辑放在@catch块中，最后用@finally块来回收资源。 @作为OC语言最大的标志之一，所以相对于JavaScript来说的话，以上的三个语句的用法其实和OC基本一致，仅仅只是格式和书写上的差别。 try &#123; //在这里运行代码 &#125; catch(err) &#123; //在这里处理错误 &#125; throw 语句允许创建自定义错误。 语句如下： throw exception 对于JavaScript的异常可以是：JavaScript 的 字符串、数字、逻辑值或对象。","raw":"---\ntitle: JavaScript03\ndate: 2017-03-02 17:04:23\ncategories:\ntoc: true\ntags:\n     - JavaScript\n     - JavaScript try语句\n     - JavaScript catch语句\n     - JavaScript throw语句\n---\n\n# JavaScript的 try/catch/throw 语句的用法:\n\n>做iOS开发的时候，调试的时候也会用到这些内容，由于之前开发用这些比较少，所以先来重温一下OC的相关语句，大同小异。\n\ntry 语句测试代码块的错误。\n\ncatch 语句处理错误。\n\nthrow 语句创建自定义错误。\n\n在OC中，经常用到下面的代码块来捕捉异常\n\n    @try {\n       // 可能会出现崩溃的代码\n    }\n    @catch (NSException *exception) {\n\t   // 捕获到的异常exception\n\t }\n\t @finally {\n\t   // 结果处理\n\t }\n\n\n<!--more-->\n\n\n下面有个比较详细的OC调试的过程的代码：\n\n\n\t    @try {\n\t    // 1\n\t    [self tryTwo];\n\t    }\n\t    @catch (NSException *exception) {\n\t    // 2\n\t    NSLog(@\"%s\\n%@\", __FUNCTION__, exception);\n\t    //   @throw exception; // 这里不能再抛异常\n\t    }\n\t    @finally {\n\t    // 3\n\t    NSLog(@\"我一定会执行\");\n\t    }\n\t    // 4\n\t    // 这里一定会执行\n\t    NSLog(@\"try\");\n    \n    \n  ***  \n    \n    - (void)tryTwo {\n\t    @try {\n\t        // 5\n\t        NSString *str = @\"abc\";\n\t        [str substringFromIndex:111]; // 程序到这里会崩\n\t    }\n\t    @catch (NSException *exception) {\n\t        // 6\n\t        // @throw exception; // 抛出异常，即由上一级处理\n\t        // 7\n\t        NSLog(@\"%s\\n%@\", __FUNCTION__, exception);\n\t    }\n\t    @finally {\n\t        // 8\n\t        NSLog(@\"tryTwo - 我一定会执行\");\n\t    }\n\t     \n\t\t    // 9\n\t\t    // 如果抛出异常，那么这段代码则不会执行\n\t\t    NSLog(@\"如果这里抛出异常，那么这段代码则不会执行\");\n    }\n\n如果6抛出异常，那么执行顺序为：1->5->6->8->3->4\n\n如果6没抛出异常，那么执行顺序为：1->5->7->8->9->3->4\n\nObjective-C将可能出现异常的代码放在@try块中，所有的异常处理逻辑放在@catch块中，最后用@finally块来回收资源。\n \n\n@作为OC语言最大的标志之一，所以相对于JavaScript来说的话，以上的三个语句的用法其实和OC基本一致，仅仅只是格式和书写上的差别。\n\n    try\n    {\n    //在这里运行代码\n    }\n    catch(err)\n    {\n    //在这里处理错误\n    }\n\nthrow 语句允许创建自定义错误。\n\n语句如下：\n\n    throw exception\n    \n    \n对于JavaScript的异常可以是：JavaScript 的 字符串、数字、逻辑值或对象。    \n","updated":"2017-11-24T06:57:23.466Z","permalink":"http://yoursite.com/2017/03/02/JavaScript03/","categories":[]},{"title":"JavaScript02","date":"2017-03-02T05:33:19.000Z","path":"2017/03/02/JavaScript02/","text":"1、JavaScript关于对象的理解 关于JavaScript的对象性有很多种不同的说话，部分说法是JavaScript是面向对象的语言，还有一部的说法是JavaScript不是面向对象的语言，而是基于对象的语言。面向对象是object-oriented，基于对象是Object-Based，二者有着本质上的差别。但是大部分人认同JavaScript语言是基于对象的（Object-Based），而不是面向对象的（object-oriented）。之所以说它是一门基于对象的语言，主要是因为它没有提供象抽象、继承、重载等有关面向对象语言的许多功能。而是把其它语言所创建的复杂对象统一起来，从而形成一个非常强大的对象系统。虽然JavaScript语言是一门基于对象的，但它还是具有一些面向对象的基本特征。它可以根据需要创建自己的对象，从而进一步扩大JavaScript的应用范围，增强编写功能强大的Web文档。 从上面分析的情况来看，无论是基于对象还是面向对象，对于JavaScript的对象的研究，还是重中之重的一点。 JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。在 JavaScript 中，对象是拥有属性和方法的数据。 例如：现在有一个人对象 var person; person = new Object(); 属性: person.name = &quot;YanCey&quot;; person.age = 25; person.weight = 87; 方法: person.eat() person.run() person.sleep() 2、JavaScript的函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数在多数语言中被理解为函数或方法,所以JavaScript的函数概念和其他语言是类似的。 因为每种语言的格式书写差异很大，所以对于JavaScript函数的格式，要注意它有如下基本的格式： function functionname() &#123; //这里是要执行的代码 &#125; 前面使用了关键词 function PS:JavaScript 对大小写是敏感的。规定关键词 function 必须是小写，并且必须以与函数名称相同的大小写来调用函数。 当我们想调用一个函数需要带参数的时候，在（）内增加参数即可，如下： function myFunction(var1, var2) &#123; //这里是要执行的代码 &#125; 有时，我们会希望函数将值返回调用它的地方。通过使用 return 语句就可以实现。在使用 return 语句时，函数会停止执行，并返回指定的值。 function myFunction() &#123; var x=5; return x; &#125; 有时候，想要返回值是基于传递到函数中的参数： function myFunction(a, b) &#123; return a * b; &#125; 从以上的四种情况来看，JavaScript的函数的特性和C语言函数的情况相类似：无参无返，有参无返，无参有返，有参有返四种大的类型。但是必须要有关键词小写的 function 来修饰函数。 PS：了解完JavaScript的函数之后，避免不了的需要知道和函数有关的全局变量以及局部变量。在JS中对于全局变量和局部变量JS的规定和C语言又不谋而合的类似。 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。 您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。 只要函数运行完毕，本地变量就会被删除。 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。 如果把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。 personName = &quot;YanCeyMichael&quot;; 即使该变量是在函数内执行，也是全局变量。 3、JavaScript的运算符JavaScript的算术运算符和赋值运算符和C以及OC或者其他语言是基本类似的，这里不再赘述。 JavaScript有自己特殊功能的运算符： 用于字符串的”+”运算符: “+” 运算符用于把文本值或字符串变量加起来（连接起来) var txt1 = &quot;What a very&quot;; var txt2 = &quot;nice day&quot;; var txt3 = txt1 + txt2; txt3打印的显示结果就是: What a verynice day 据我了解: Java和.net以及Python都支持 + 来做字符串的拼接。 txt1=&quot;What a very&quot;; txt2=&quot;nice day&quot;; txt3=txt1+&quot; &quot;+txt2; 和下面的把空格放到txt1尾巴或者txt2的开头的作用是一样的。 txt1 = &quot;What a very &quot;; txt2 = &quot;nice day&quot;; txt3 = txt1 + txt2; 有时候对字符串和数字进行加法运算 x = 5 + 5; document.write(x); x = &quot;5&quot; + &quot;5&quot;; document.write(x); x = 5 + &quot;5&quot;; document.write(x); x = &quot;5&quot; + 5; document.write(x); 如果把数字与字符串相加，结果将成为字符串。 JavaScript的比较运算符和逻辑运算符以及条件运算符和C以及OC还有其他语言的语法是基本类似的,这里不再赘述。 4、JavaScript的判断语句JavaScript的判断语句和其他语言的判断语句基本一致，这里不再赘述（if语句/if-else语句/if-elseif-…-else语句/switch语句）。 5、JavaScript的for循环while循环以及break语句和continue语句这些语句和C语言或OC以及其他语言类似，这里不再赘述。","raw":"---\ntitle: JavaScript02\ndate: 2017-03-02 13:33:19\ncategories:\ntoc: true\ntags:\n     - JavaScript\n     - JavaScript 对象\n     - JavaScript 函数\n     - JavaScript 运算符\n     - JavaScript 判断语句\n     - JavaScript 循环语句\n---\n\n# 1、JavaScript关于对象的理解\n\n>关于JavaScript的对象性有很多种不同的说话，部分说法是JavaScript是面向对象的语言，还有一部的说法是JavaScript不是面向对象的语言，而是基于对象的语言。面向对象是object-oriented，基于对象是Object-Based，二者有着本质上的差别。但是大部分人认同JavaScript语言是基于对象的（Object-Based），而不是面向对象的（object-oriented）。之所以说它是一门基于对象的语言，主要是因为它没有提供象抽象、继承、重载等有关面向对象语言的许多功能。而是把其它语言所创建的复杂对象统一起来，从而形成一个非常强大的对象系统。虽然JavaScript语言是一门基于对象的，但它还是具有一些面向对象的基本特征。它可以根据需要创建自己的对象，从而进一步扩大JavaScript的应用范围，增强编写功能强大的Web文档。\n\n\n从上面分析的情况来看，无论是基于对象还是面向对象，对于JavaScript的对象的研究，还是重中之重的一点。\n\nJavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。\n在 JavaScript 中，对象是拥有属性和方法的数据。\n\n例如：现在有一个人对象\n\n    var person;\n    person = new Object();\n    \n属性:\n \n    person.name = \"YanCey\";\n    person.age = 25;\n    person.weight = 87;\n    \n方法:\n\n    person.eat()\n    person.run()\n    person.sleep()   \n    \n<!--more-->\n\n# 2、JavaScript的函数\n\n函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数在多数语言中被理解为函数或方法,所以JavaScript的函数概念和其他语言是类似的。\n\n因为每种语言的格式书写差异很大，所以对于JavaScript函数的格式，要注意它有如下基本的格式：\n\n    function functionname()\n    {\n\t  //这里是要执行的代码\n\t }\n\t \n前面使用了关键词 function\n\nPS:JavaScript 对大小写是敏感的。规定关键词 function 必须是小写，并且必须以与函数名称相同的大小写来调用函数。\n\n当我们想调用一个函数需要带参数的时候，在（）内增加参数即可，如下：\n\n    function myFunction(var1, var2)\n    {\n\t //这里是要执行的代码\n\t }\n\n有时，我们会希望函数将值返回调用它的地方。通过使用 return 语句就可以实现。在使用 return 语句时，函数会停止执行，并返回指定的值。\n\n\tfunction myFunction()\n\t{\n\tvar x=5;\n\treturn x;\n\t}\n\n有时候，想要返回值是基于传递到函数中的参数：\n\n    function myFunction(a, b)\n\t{\n\t  return a * b;\n\t}\n\n从以上的四种情况来看，JavaScript的函数的特性和C语言函数的情况相类似：无参无返，有参无返，无参有返，有参有返四种大的类型。但是必须要有关键词小写的 function 来修饰函数。\n\n***\n\n>PS：了解完JavaScript的函数之后，避免不了的需要知道和函数有关的全局变量以及局部变量。在JS中对于全局变量和局部变量JS的规定和C语言又不谋而合的类似。\n\n>在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。\n\n>您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。\n\n>只要函数运行完毕，本地变量就会被删除。\n\n>在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。\n\n>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。\n\n>如果把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。\n\n>     personName = \"YanCeyMichael\";\n\n>即使该变量是在函数内执行，也是全局变量。\n\n\n***\n\n# 3、JavaScript的运算符\n\nJavaScript的算术运算符和赋值运算符和C以及OC或者其他语言是基本类似的，这里不再赘述。\n\nJavaScript有自己特殊功能的运算符：\n\n>>用于字符串的\"+\"运算符:\n\n\"+\" 运算符用于把文本值或字符串变量加起来（连接起来)\n\n    var txt1 = \"What a very\";\n    var txt2 = \"nice day\";\n    var txt3 = txt1 + txt2;\n\ntxt3打印的显示结果就是:  What a verynice day\n\n据我了解: Java和.net以及Python都支持 + 来做字符串的拼接。  \n\n    txt1=\"What a very\";\n    txt2=\"nice day\";\n    txt3=txt1+\" \"+txt2;\n    \n和下面的把空格放到txt1尾巴或者txt2的开头的作用是一样的。\n\n    txt1 = \"What a very \";\n    txt2 = \"nice day\";\n    txt3 = txt1 + txt2;  \n      \n有时候对字符串和数字进行加法运算\n\n    x = 5 + 5;\n    document.write(x);\n\n    x = \"5\" + \"5\";\n    document.write(x);\n\n    x = 5 + \"5\";\n    document.write(x);\n\n    x = \"5\" + 5;\n    document.write(x);\n    \n如果把数字与字符串相加，结果将成为字符串。 \n\nJavaScript的比较运算符和逻辑运算符以及条件运算符和C以及OC还有其他语言的语法是基本类似的,这里不再赘述。\n\n\n# 4、JavaScript的判断语句\n\nJavaScript的判断语句和其他语言的判断语句基本一致，这里不再赘述（if语句/if-else语句/if-elseif-...-else语句/switch语句）。\n\n# 5、JavaScript的for循环while循环以及break语句和continue语句\n\n这些语句和C语言或OC以及其他语言类似，这里不再赘述。\n","updated":"2017-11-24T06:56:52.461Z","permalink":"http://yoursite.com/2017/03/02/JavaScript02/","categories":[]},{"title":"JavaScript01","date":"2017-03-02T04:09:30.000Z","path":"2017/03/02/JavaScript01/","text":"JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。 1、JavaScript的输出： 假如需从JavaScript访问某个HTML元素，可以使用document.getElementById(id) 方法。使用 “id” 属性来标识 HTML 元素： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;My First Web Page&lt;/h1&gt; &lt;p id = &quot;demo&quot;&gt;My First Paragraph&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JavaScript 由 web 浏览器来执行。在这种情况下，浏览器将访问 id=”demo” 的 HTML 元素，并把它的内容（innerHTML）替换为 “My First JavaScript”。 使用 document.write() 仅仅向文档输出写内容。如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 2、JavaScript的语句：语句； 例如这样的代码块： &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;hello!&quot;); &lt;/script&gt; 其中的： alert(&quot;hello!&quot;); 就是就是一个JavaScript语句。 一行的结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束。 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;I&quot;); document.write(&quot;love&quot;); document.write(&quot;you&quot;); &lt;/script&gt; 像这个代码块，就有三条语句，每句结束后都有”;”，需要强调的是这三条语句是按顺序执行的。 和其他的基本语言一样，语句的末尾的逗号是英文状态下的逗号。注意: “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。 3、JavaScript的注释：和很多其他语言注释方法是一样的，在此不在赘述。 4、JavaScript的变量：定义JavaScript的变量用到关键词var，语法如下： var 变量名 JavaScript的变量名的命名规则如下: 1.变量必须使用字母、下划线(_)或者美元符($)开始。 2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 3.不能使用JavaScript关键词与JavaScript保留字。 1）JavaScript的变量要先声明再赋值； 2）JavaScript的变量可以重复赋值； PS： 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。 5、JavaScript的数据类型：字符串、数字、布尔、数组、对象、Null、Undefined ①.字符串: 字符串是存储字符（比如 “YanCey Michael”）的变量。 字符串可以是引号中的任意文本。可以使用单引号或双引号： var myName = &quot;YanCey Michael&quot;; var myName = &apos;YanCey Michael&apos;; 二者等价。 也可以在字符串中使用引号，只要不匹配包围字符串的引号即可： var answer = &quot;Nice to meet you!&quot;; var answer = &quot;He is called &apos;Bill&apos;&quot;; var answer = &apos;He is called &quot;Bill&quot;&apos;; ②.数字： JavaScript 只有一种数字类型。数字可以带小数点，也可以不带： var x1 = 34.00; //使用小数点来写 var x2 = 34; //不使用小数点来写 var y = 123e5; // 12300000 var z = 123e-5; // 0.00123 ③.布尔： 布尔（逻辑）只能有两个值：true 或 false。 var x = true var y = false ④.数组： 下面的代码创建名为 students 的数组： var students = new Array(); students[0] = &quot;Michael&quot;; students[1] = &quot;Jane&quot;; students[2] = &quot;Maria&quot;; 或者 (condensed array): var students = new Array(&quot;Michael&quot;,&quot;Jane&quot;,&quot;Maria&quot;); 或者 (literal array): var students = [&quot;Michael&quot;,&quot;Jane&quot;,&quot;Maria&quot;]; ⑤.对象： 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person = &#123;firstname:&quot;YanCey&quot;, lastname:&quot;Michael&quot;, id:1208&#125;; PS：JS中的对象有点类似于OC中的字典。当然这里已经不能说就是字典了，只是个人作为一个iOS的软件工程师，我用来对比记忆。 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 当然有时候为了美观好看，也可以这样做书写格式的空格和转行 var person = &#123; firstname: &quot;YanCey&quot;, lastname : &quot;Michael&quot;, id : 1208 &#125;; 对象属性有两种寻址方式： var name = person.lastname; var name = person[&quot;lastname&quot;]; ⑥.Undefined 和 Null Undefined 这个值表示变量不含有值。 可以通过将变量的值设置为 null 来清空变量。 var person; person = null; 6、对于JavaScript的变量声明变量类型注意：声明新变量时，可以使用关键词 “new” 来声明其类型： var carname = new String; var x = new Number; var y = new Boolean; var cars = new Array; var person = new Object; JavaScript的变量均为对象。当声明一个变量时，就创建了一个新的对象。","raw":"---\ntitle: JavaScript01\ndate: 2017-03-02 12:09:30\ncategories:\ntoc: true\ntags:\n     - JavaScript\n     - JavaScript 输出\n     - JavaScript 语句\n     - JavaScript 注释\n     - JavaScript 变量 \n     - JavaScript 数据类型\n     - JavaScript 声明变量类型\n---\n\nJavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。\n\n\n\n# 1、JavaScript的输出：\n\n>假如需从JavaScript访问某个HTML元素，可以使用document.getElementById(id) 方法。使用 \"id\" 属性来标识 HTML 元素：\n\n\n    <!DOCTYPE html>\n    <html>\n    <body>\n\n    <h1>My First Web Page</h1>\n\n    <p id = \"demo\">My First Paragraph</p>\n\n    <script>\n        document.getElementById(\"demo\").innerHTML=\"My First JavaScript\";\n    </script>\n\n    </body>\n    </html>\n\n\nJavaScript 由 web 浏览器来执行。在这种情况下，浏览器将访问 id=\"demo\" 的 HTML 元素，并把它的内容（innerHTML）替换为 \"My First JavaScript\"。\n\n\n使用 document.write() 仅仅向文档输出写内容。\n如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。\n\n\n<!--more-->\n\n# 2、JavaScript的语句：\n    \n    语句；\n     \n例如这样的代码块：\n\n    <script type=\"text/javascript\">\n       alert(\"hello!\");\n    </script>\n     \n其中的：\n    \n    alert(\"hello!\");\n    \n就是就是一个JavaScript语句。\n\n\n一行的结束就被认定为语句的结束，通常在结尾加上一个分号\";\"来表示语句的结束。\n\n    <script type=\"text/javascript\">\n\t   document.write(\"I\");\n\t   document.write(\"love\");\n\t   document.write(\"you\");\n\t</script>\n\t\n像这个代码块，就有三条语句，每句结束后都有\";\"，需要强调的是这三条语句是按顺序执行的。\n\n和其他的基本语言一样，语句的末尾的逗号是英文状态下的逗号。注意:\n\n1. “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。\n\n2. 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。 \n\n\n# 3、JavaScript的注释：\n和很多其他语言注释方法是一样的，在此不在赘述。\n\n\n# 4、JavaScript的变量：\n定义JavaScript的变量用到关键词var，语法如下：\n\n    var 变量名\n    \nJavaScript的变量名的命名规则如下:\n\n    1.变量必须使用字母、下划线(_)或者美元符($)开始。\n    2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。\n    3.不能使用JavaScript关键词与JavaScript保留字。 \n    \n1）JavaScript的变量要先声明再赋值；\n\n2）JavaScript的变量可以重复赋值； \n\nPS：\n\n1. 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。\n2. 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。\n      \n      \n      \n# 5、JavaScript的数据类型：\n\n字符串、数字、布尔、数组、对象、Null、Undefined\n\n***\n\n>>①.字符串:\n\n字符串是存储字符（比如 \"YanCey Michael\"）的变量。\n\n字符串可以是引号中的任意文本。可以使用单引号或双引号：\n\n\tvar myName = \"YanCey Michael\";\n\tvar myName = 'YanCey Michael';\n    \n二者等价。\n\n也可以在字符串中使用引号，只要不匹配包围字符串的引号即可：\n\n\tvar answer = \"Nice to meet you!\";\n\tvar answer = \"He is called 'Bill'\";\n\tvar answer = 'He is called \"Bill\"';\n\n***\n\n>>②.数字：\n\t\t\nJavaScript 只有一种数字类型。数字可以带小数点，也可以不带：\n\n\tvar x1 = 34.00;     //使用小数点来写\n\tvar x2 = 34;        //不使用小数点来写\n\tvar y = 123e5;      // 12300000\n\tvar z = 123e-5;     // 0.00123\t\n\t\t\n***\n\n>>③.布尔：\n\n布尔（逻辑）只能有两个值：true 或 false。\t\t\n\n\tvar x = true\n\tvar y = false\t\n\n***\n\t\t\n>>④.数组：\n\n下面的代码创建名为 students 的数组：\n\n\tvar students = new Array();\n\tstudents[0] = \"Michael\";\n\tstudents[1] = \"Jane\";\n\tstudents[2] = \"Maria\";\n\t\t\n或者 (condensed array):\n\n\tvar students = new Array(\"Michael\",\"Jane\",\"Maria\");\n\t\t\n或者 (literal array):\n\n\tvar students = [\"Michael\",\"Jane\",\"Maria\"];\n\t\t\n***\n\n>>⑤.对象：\n\n对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：\n\n    var person = {firstname:\"YanCey\", lastname:\"Michael\", id:1208};\n    \nPS：JS中的对象有点类似于OC中的字典。当然这里已经不能说就是字典了，只是个人作为一个iOS的软件工程师，我用来对比记忆。\n\n上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 \n\n当然有时候为了美观好看，也可以这样做书写格式的空格和转行\n\n    var person = \n    {\n\t    firstname: \"YanCey\", \n\t    lastname : \"Michael\", \n\t    id       : 1208\n    }; \n    \n\t\n对象属性有两种寻址方式：\n\n\tvar name = person.lastname;\n\tvar name = person[\"lastname\"];\n\n***\n\t\n>>⑥.Undefined 和 Null\n\nUndefined 这个值表示变量不含有值。\n\n可以通过将变量的值设置为 null 来清空变量。\t\n\n    var person;\n    person = null;\n    \n# 6、对于JavaScript的变量声明变量类型   \n \n注意：声明新变量时，可以使用关键词 \"new\" 来声明其类型：\n\n    var carname = new String;\n    var x       = new Number;\n    var y       = new Boolean;\n    var cars    = new Array;\n    var person  = new Object;\n    \nJavaScript的变量均为对象。当声明一个变量时，就创建了一个新的对象。    \n     \n\t\t\t\t\n\n\t\t\n\n\n","updated":"2017-11-29T03:25:50.928Z","permalink":"http://yoursite.com/2017/03/02/JavaScript01/","categories":[]},{"title":"给Blog添加一个相册，先把JS干掉","date":"2017-03-02T03:18:18.000Z","path":"2017/03/02/给Blog添加一个相册，先把JS干掉/","text":"废话写在前面：这个博客没有相册，这会儿刚好不是特别的忙，所以也有点精力来整理一下blog。音乐播放器加了，还差一个相册。为了整个相册出来，我还是要摸一下前端的内容的，也许方向不是特别的对，但是还是先从JS入手吧。 我对JS不是特别了解的，在iOS这边原生的框架开发做的时间用不了多久，就会遇到JS的交互问题，在iOS这边有个UI控件叫UIWebView，它是专门用来承载html内容的一个控件（通俗的来说：这个控件是用来加载网页的）。只有简单的代理方法，所以很多时候，iOS这边想要和web前端做一些交互的时候，难免要用到JS。 JS简介： JS即JavaScript，一般这么解释它：JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 目前所有主流浏览器都支持JavaScript，并且很多的网站的网页都用JavaScript来做一些动态功能，当然还可以用其他的脚本语言来丰富网页的动态效果也不仅仅就是JavaScript。 那么这个开篇的JavaScript的内容就简单介绍一些基本的关于JavaScript的基本概念。 从JavaScript的基本概念介绍看来JavaScript这门语言可用于HTML和Web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。所以它的代码怎么书写，怎么使用，怎么调用等问题是我所关心的。 JavaScript是可插入HTML页面的编程代码。 Q1:怎么在HTML文件内容中写JS代码？ &lt;script&gt;&lt;/script&gt; 使用标签在HTML网页中插入JavaScript代码，这种标签和H5的其他标签一样都是成对存在，JavaScript代码是写在标签中间的。 有时会遇到这样的一对标签 &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 这是表示这对标签之间的内容是文本类型(text)，javascript是为了告诉浏览器里面的文本是属于JavaScript语言。 Q2:JS代码只能写在HTML文件中吗？ 在很多复杂的项目中，一般会遇到把JS的内容单独抽离出来，并不写在HTML的文件中。把HTML文件和JS代码分开，并单独创建一个JavaScript文件(简称JS文件)，其文件后缀通常为.js，然后将JS代码直接写在JS文件中。这样也是可以的。 PS:1）在JS文件中， &lt;script&gt;&lt;/script&gt; 像这样的成对的标签就不再需要了，而是直接在JS文件中编写JavaScript代码就可以了。 2）但是新的问题又出现了，以上抽离部分的JS代码的JS文件并不能直接被运行，它需嵌入到HTML文件中执行，所以需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 相当于告诉浏览器，当你执行到这里的时候，就要去JS文件跑JS代码了。 Q3:JS代码在文件中的位置在哪里？ 我们可以将JavaScript代码放在html文件中任何位置，但是一般放在网页的head或者body部分。 1）放在head部分： 最常用的方式是在页面中head部分放置script元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。 2）放在body部分： JavaScript代码在网页读取到该语句的时候就会执行。 PS: JavaScript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。","raw":"---\ntitle: 给Blog添加一个相册，先把JS干掉\ndate: 2017-03-02 11:18:18\ncategories:\ntoc: false\ntags:\n     - JavaScript\n     - JavaScript 简介\n     - JavaScript 基本概念\n---\n>废话写在前面：这个博客没有相册，这会儿刚好不是特别的忙，所以也有点精力来整理一下blog。音乐播放器加了，还差一个相册。为了整个相册出来，我还是要摸一下前端的内容的，也许方向不是特别的对，但是还是先从JS入手吧。\n>\n>我对JS不是特别了解的，在iOS这边原生的框架开发做的时间用不了多久，就会遇到JS的交互问题，在iOS这边有个UI控件叫UIWebView，它是专门用来承载html内容的一个控件（通俗的来说：这个控件是用来加载网页的）。只有简单的代理方法，所以很多时候，iOS这边想要和web前端做一些交互的时候，难免要用到JS。\n\n<!--more-->\n\nJS简介：\n\nJS即JavaScript，一般这么解释它：JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。\n\n\n目前所有主流浏览器都支持JavaScript，并且很多的网站的网页都用JavaScript来做一些动态功能，当然还可以用其他的脚本语言来丰富网页的动态效果也不仅仅就是JavaScript。\n\n\n那么这个开篇的JavaScript的内容就简单介绍一些基本的关于JavaScript的基本概念。\n\n\n***\n\n从JavaScript的基本概念介绍看来JavaScript这门语言可用于HTML和Web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。所以它的代码怎么书写，怎么使用，怎么调用等问题是我所关心的。\n\n\nJavaScript是可插入HTML页面的编程代码。\n\n\nQ1:怎么在HTML文件内容中写JS代码？\n\n    <script></script>\n    \n使用标签在HTML网页中插入JavaScript代码，这种标签和H5的其他标签一样都是成对存在，JavaScript代码是写在标签中间的。\n\n有时会遇到这样的一对标签\n\n    <script type=\"text/javascript\"></script>\n    \n这是表示这对标签之间的内容是文本类型(text)，javascript是为了告诉浏览器里面的文本是属于JavaScript语言。\n\n***\n\nQ2:JS代码只能写在HTML文件中吗？\n\n在很多复杂的项目中，一般会遇到把JS的内容单独抽离出来，并不写在HTML的文件中。把HTML文件和JS代码分开，并单独创建一个JavaScript文件(简称JS文件)，其文件后缀通常为.js，然后将JS代码直接写在JS文件中。这样也是可以的。\n\nPS:1）在JS文件中，\n\n       <script></script>\n       \n像这样的成对的标签就不再需要了，而是直接在JS文件中编写JavaScript代码就可以了。\n\n2）但是新的问题又出现了，以上抽离部分的JS代码的JS文件并不能直接被运行，它需嵌入到HTML文件中执行，所以需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。\n\n    <script src=\"script.js\"></script>\n    \n相当于告诉浏览器，当你执行到这里的时候，就要去JS文件跑JS代码了。\n\n***\n\nQ3:JS代码在文件中的位置在哪里？\n\n我们可以将JavaScript代码放在html文件中任何位置，但是一般放在网页的head或者body部分。\n\n1）放在head部分：\n\n最常用的方式是在页面中head部分放置script元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。\n\n2）放在body部分：\n\nJavaScript代码在网页读取到该语句的时候就会执行。\n\nPS: JavaScript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。\n\n\n","updated":"2021-06-05T17:59:29.140Z","permalink":"http://yoursite.com/2017/03/02/%E7%BB%99Blog%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%86%8C%EF%BC%8C%E5%85%88%E6%8A%8AJS%E5%B9%B2%E6%8E%89/","categories":[]},{"title":"阳光正好","date":"2017-02-27T04:48:55.000Z","path":"2017/02/27/阳光正好/","text":"我回来了，比自己想象中的要快好多。离职，收拾行李，落脚合肥。前后只用了2天时间。雾总2天前给我电话说我走的好快啊，一不留神就走了。 仓促，慌张。 回来的第二天上午又去面试了一个创业团队，产品跟我说：我们的iOS为了女朋友去上海了，所以缺个人。一个萝卜一个坑这种说法在某种意义上是成立的。和他聊的比较投缘。一个挺有想法的同龄人。 我放弃了那个目前在合肥算高薪的offer，我跟那边的老板说：倘若最终没来你这边，不是薪资的问题，只是单纯的不适合。一晃从我离开合肥庐江，到现如今我回到合肥生活，前前后后有快6年的时间了。6年里我做了很多的选择，每次都考虑的比这次要久。可是适合自己的抉择并不多。 有时候能做到适合自己好难。 一直追随的都是当下的最好也许并不是一件坏事，但是不见得能让自己快乐。之前我问过我自己眼下这几年我需要什么：稳定，安静，舒适，积淀。我从没有像现在这样渴望这些东西。 昨天花了3个小时找到了房子。今天上午把行李拎过来，把地板拖干净之后去天台看了一下，视野挺开阔。整个空的屋子，有点破旧的卫生间好像和这个像模像样的小区有点冲突。我觉得住的地方凑合着就可以了。况且像今天的日子，有这么好的阳光，大抵已经满足了我。 礼拜六晚因吃饭比较晚，错过了南峰子的MVCS框架以及数据通信层梳理的直播，可能要再抽个时间好好的整理一下。我从知乎上翻到了他的技术博客地址：南峰子的技术博客。知乎上他的最后的活跃状态还是三年前的答案。我有时候好想知道这些技术大牛到底都是在干嘛。 用MarkDown写东西更新的频次要是不高的话，下次再想写点东西的时候，都好碍事，很多标签语法不记得，还要重头翻过。更新博客遇到心情差的时候就觉得好累，因为你有很多想写的都被这些东西挡着。 即便诸多不便，可是内心对干净的地儿的诉求一直欲求不满。觉得有一块地儿自己耕种的感觉挺好的，比微博空间写东西要好的多，微信挺棒的，但是里面发长内容好麻烦，可我又偏偏是一个不喜欢发碎片的怪胎，往往丢一个链接要让我省很多事儿。讲真，七牛云做博客的图床加载速度真是快的让我惊叹。 日头和阳光挺好的，想出去跑跑步了。离上次开始想跑步日子已经过去差不多一年了，这一年一直在路上，现在我换了一个地方继续跑。","raw":"---\ntitle: 阳光正好\ndate: 2017-02-27 12:48:55\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n我回来了，比自己想象中的要快好多。离职，收拾行李，落脚合肥。前后只用了2天时间。雾总2天前给我电话说我走的好快啊，一不留神就走了。\n\n仓促，慌张。\n\n<!--more-->\n\n回来的第二天上午又去面试了一个创业团队，产品跟我说：我们的iOS为了女朋友去上海了，所以缺个人。一个萝卜一个坑这种说法在某种意义上是成立的。和他聊的比较投缘。一个挺有想法的同龄人。\n\n我放弃了那个目前在合肥算高薪的offer，我跟那边的老板说：倘若最终没来你这边，不是薪资的问题，只是单纯的不适合。一晃从我离开合肥庐江，到现如今我回到合肥生活，前前后后有快6年的时间了。6年里我做了很多的选择，每次都考虑的比这次要久。可是适合自己的抉择并不多。\n\n有时候能做到适合自己好难。\n\n一直追随的都是当下的最好也许并不是一件坏事，但是不见得能让自己快乐。之前我问过我自己眼下这几年我需要什么：稳定，安静，舒适，积淀。我从没有像现在这样渴望这些东西。\n\n昨天花了3个小时找到了房子。今天上午把行李拎过来，把地板拖干净之后去天台看了一下，视野挺开阔。整个空的屋子，有点破旧的卫生间好像和这个像模像样的小区有点冲突。我觉得住的地方凑合着就可以了。况且像今天的日子，有这么好的阳光，大抵已经满足了我。\n\n礼拜六晚因吃饭比较晚，错过了南峰子的MVCS框架以及数据通信层梳理的直播，可能要再抽个时间好好的整理一下。我从知乎上翻到了他的技术博客地址：[南峰子的技术博客](https://southpeak.github.io/)。知乎上他的最后的活跃状态还是三年前的答案。我有时候好想知道这些技术大牛到底都是在干嘛。\n\n用MarkDown写东西更新的频次要是不高的话，下次再想写点东西的时候，都好碍事，很多标签语法不记得，还要重头翻过。更新博客遇到心情差的时候就觉得好累，因为你有很多想写的都被这些东西挡着。\n\n即便诸多不便，可是内心对干净的地儿的诉求一直欲求不满。觉得有一块地儿自己耕种的感觉挺好的，比微博空间写东西要好的多，微信挺棒的，但是里面发长内容好麻烦，可我又偏偏是一个不喜欢发碎片的怪胎，往往丢一个链接要让我省很多事儿。讲真，七牛云做博客的图床加载速度真是快的让我惊叹。\n\n日头和阳光挺好的，想出去跑跑步了。离上次开始想跑步日子已经过去差不多一年了，这一年一直在路上，现在我换了一个地方继续跑。\n\n\n","updated":"2021-06-05T18:00:59.894Z","permalink":"http://yoursite.com/2017/02/27/%E9%98%B3%E5%85%89%E6%AD%A3%E5%A5%BD/","categories":[]},{"title":"基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器","date":"2017-02-22T08:13:47.000Z","path":"2017/02/22/基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器/","text":"有时候偶尔写东西的时候少音乐挺没劲的。 音乐也是有毒，难以让人专注去做好一件事。 我不知道我添加一个音乐播放器的意义是什么。 纠结那么多好像也没那么多的意义。 所以不管了，文章都开了，还是个音乐播放器吧。 别问我为啥不给移动端加一个，就是不加。 准备工作：一个网易云音乐账号 + 一个网易云音乐歌单 这个音乐播放器是在网易云音乐官网的个人主页里的任意一个歌单中，通过歌单的 生成外链播放器 来生成的一个 iframe 插件。 将原生的代码段： &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=0&amp;id=609175973&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 粘贴到themes/yilia/layout/_partial/left-col.ejs文件的第二行，并作如下的修改之后，将和我现在的博客的音乐布局是一样的。修改一下： &lt;iframe style=&quot;position:absolute;top: 0px;z-index: 100;&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=0&amp;id=609175973&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 添加的部分是设置播放器的相对位置布局，也是很简单的代码就能搞定。 为了适配屏幕把原来的固定width修改成100%。 当然你可以通过检测博客的网页，通过浏览器的布局个人喜欢的位置。","raw":"---\ntitle: 基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器\ndate: 2017-02-22 16:13:47\ncategories:\ntoc: false\ntags:\n     - Hexo+Yilia\n     - PC端\n     - 音乐播放器\n---\n>有时候偶尔写东西的时候少音乐挺没劲的。\n>\n>音乐也是有毒，难以让人专注去做好一件事。\n>\n>我不知道我添加一个音乐播放器的意义是什么。\n>\n>纠结那么多好像也没那么多的意义。\n>\n>所以不管了，文章都开了，还是个音乐播放器吧。\n>\n>别问我为啥不给移动端加一个，就是不加。\n\n***\n\n准备工作：一个网易云音乐账号 + 一个网易云音乐歌单\n\n***\n\n<!--more-->\n\n这个音乐播放器是在网易云音乐官网的个人主页里的任意一个歌单中，通过歌单的 生成外链播放器 来生成的一个 iframe 插件。\n\n将原生的代码段：\n\n\n    <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=0&id=609175973&auto=1&height=32\"></iframe>\n    \n    \n粘贴到themes/yilia/layout/_partial/left-col.ejs文件的第二行，并作如下的修改之后，将和我现在的博客的音乐布局是一样的。    \n修改一下：\n\n     <iframe style=\"position:absolute;top: 0px;z-index: 100;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=52 src=\"//music.163.com/outchain/player?type=0&id=609175973&auto=1&height=32\"></iframe>\n     \n \n添加的部分是设置播放器的相对位置布局，也是很简单的代码就能搞定。\n\n为了适配屏幕把原来的固定width修改成100%。\n\n当然你可以通过检测博客的网页，通过浏览器的布局个人喜欢的位置。\n\n\n\n\n","updated":"2017-11-24T07:00:28.696Z","permalink":"http://yoursite.com/2017/02/22/%E5%9F%BA%E4%BA%8EHexo+Yilia%E7%9A%84PersonalBlog%E7%9A%84PC%E7%AB%AF%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","categories":[]},{"title":"OpenCV之CascadeClassifier(一)","date":"2017-02-20T06:23:58.000Z","path":"2017/02/20/OpenCV之CascadeClassifier(一)/","text":"","raw":"---\ntitle: OpenCV之CascadeClassifier(一)\ndate: 2017-02-20 14:23:58\ncategories:\ntoc: true\ntags:\n     - Cpp\n     - OpenCV\n---\n\n\n","updated":"2018-04-20T07:17:56.369Z","permalink":"http://yoursite.com/2017/02/20/OpenCV%E4%B9%8BCascadeClassifier(%E4%B8%80)/","categories":[]},{"title":"OpenCV之Mat(一)","date":"2017-02-20T05:43:01.000Z","path":"2017/02/20/OpenCV之Mat(一)/","text":"废话内容，写在前面： Mat是个什么玩意? 2015年下半年我在深圳的时候，一边看C++的入门，一边敲一点点和工作有关的代码。有一天飞哥和勇哥终于按耐不住觉得我总是测试光学打光做电子元器件可能就真的要废了，便让我用Visual Studio把一张图片用窗口显示出来，然后对图片进行二值化处理，提取特征值。 我印象特别深刻，方法函数里面涉及到了好多Mat，如今开始动OpenCV第一个碰到的东西就是Mat，在这里把研读的关于Mat类，记录一下。 OpenCV官方文档是这样界定Mat的：基本的图像容器。 处理一张图片为何要用到图像的容器这种定义的概念？没有《图像处理技术》基础知识的人可能不太能懂图像为何需要一个基本的图像容器去处理。我本科学的《图像处理技术》的基础内容现在也不太记得，脑海中只有一些隐约的印象：图像是很多像素点构成，每个像素点有具体的像素值(0~255)，一张二维平面上的图片，它上面所有的点平面坐标位置，有点像《线性代数》里的矩阵，处理一张图片就是处理图片上所包含的像素值的信息，所以图片的处理，就可以转换成矩阵运算。 正如OpenCV官方文档上说到的：如何获取并存储这些像素值由我们的需求而定，最终在计算机世界里所有图像都可以简化为数值矩以及矩阵信息。作为一个计算机视觉库， OpenCV 其主要目的就是通过处理和操作这些信息，来获取更高级的信息。因此，OpenCV如何存储并操作图像是你首先要学习的。 Mat的发展情况： 在2001年刚刚出现的时候，OpenCV基于C语言接口而建。为了在内存（memory）中存放图像，当时采用名为IplImage的C语言结构体，时至今日这仍出现在大多数的旧版教程和教学材料。但这种方法必须接受C语言所有的不足，这其中最大的不足要数手动内存管理，其依据是用户要为开辟和销毁内存负责。虽然对于小型的程序来说手动管理内存不是问题，但一旦代码开始变得越来越庞大，你需要越来越多地纠缠于这个问题，而不是着力解决你的开发目标。 幸运的是，C++出现了，并且带来类的概念，这给用户带来另外一个选择：自动的内存管理（不严谨地说）。这是一个好消息，如果C++完全兼容C的话，这个变化不会带来兼容性问题。为此，OpenCV在2.0版本中引入了一个新的C++接口，利用自动内存管理给出了解决问题的新方法。使用这个方法，你不需要纠结在管理内存上，而且你的代码会变得简洁（少写多得）。但C++接口唯一的不足是当前许多嵌入式开发系统只支持C语言。所以，当目标不是这种开发平台时，没有必要使用旧方法（除非你是自找麻烦的受虐狂码农）。 关于 Mat ，首先要知道的是你不必再手动地（1）为其开辟空间（2）在不需要时立即将空间释放。但手动地做还是可以的：大多数OpenCV函数仍会手动地为输出数据开辟空间。当传递一个已经存在的 Mat 对象时，开辟好的矩阵空间会被重用。也就是说，我们每次都使用大小正好的内存来完成任务。 基本上讲 Mat 是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸，存储方法，存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建拷贝时，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是家常便饭。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，我们不应该拷贝 大 的图像，因为这会降低程序速度。 为了搞定这个问题，OpenCV使用引用计数机制。其思路是让每个 Mat 对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则 只拷贝信息头和矩阵指针 ，而不拷贝矩阵。 关于 Mat 内存管理的问题： 如果矩阵属于多个 Mat 对象，那么当不再需要它时谁来负责清理？简单的回答是：最后一个使用它的对象。通过引用计数机制来实现。无论什么时候有人拷贝了一个 Mat 对象的信息头，都会增加矩阵的引用次数；反之当一个头被释放之后，这个计数被减一；当计数值为零，矩阵会被清理。但某些时候你仍会想拷贝矩阵本身(不只是信息头和矩阵指针)，这时可以使用函数 clone() 或者 copyTo() 。 1.OpenCV函数中输出图像的内存分配是自动完成的（如果不特别指定的话）。 2.使用OpenCV的C++接口时不需要考虑内存释放问题。 3.赋值运算符和拷贝构造函数（ ctor ）只拷贝信息头。 4.使用函数 clone() 或者 copyTo() 来拷贝一副图像的矩阵。 以上是对图像以及 Mat类发展，以及OpenCV在处理图像时的内存管理的一个简单的了解。 接下来要了解一下OpenCV是如何存储图像的： 这里讲述如何存储像素值。需要指定颜色空间和数据类型。颜色空间是指对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间，只处理黑色和白色，对它们进行组合可以产生不同程度的灰色。 对于 彩色 方式则有更多种类的颜色空间，但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。RGB颜色空间是最常用的一种颜色空间，这归功于它也是人眼内部构成颜色的方式。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素 alpha (A)。 有很多的颜色系统，各有自身优势： 1.RGB是最常见的，这是因为人眼采用相似的工作机制，它也被显示设备所采用。 2.HSV和HLS把颜色分解成色调、饱和度和亮度/明度。这是描述颜色更自然的方式，比如可以通过抛弃最后一个元素，使算法对输入图像的光照条件不敏感。 3.YCrCb在JPEG图像格式中广泛使用。 4.CIE L a b *是一种在感知上均匀的颜色空间，它适合用来度量两个颜色之间的距离。 每个组成元素都有其自己的定义域，取决于其数据类型。如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ，占一个字节或者8位，可以是有符号型（0到255之间）或无符号型（-127到+127之间）。尽管使用三个 char 型元素已经可以表示1600万种可能的颜色（使用RGB颜色空间），但若使用float（4字节，32位）或double（8字节，64位）则能给出更加精细的颜色分辨能力。但同时也要切记增加元素的尺寸也会增加了图像所占的内存空间。 关于Mat类的创建，具体的代码和内容可以查阅OpenCV中文网里的相关入门教学，当然还要具备一点点基础的C++入门知识。 待续以后会更新相关内容，等我把C++入门摸一下。","raw":"---\ntitle: OpenCV之Mat(一)\ndate: 2017-02-20 13:43:01\ncategories:\ntoc: false\ntags:\n     - Cpp\n     - OpenCV\n---\n\n***\n>废话内容，写在前面：\n>\n>Mat是个什么玩意?\n>\n>2015年下半年我在深圳的时候，一边看C++的入门，一边敲一点点和工作有关的代码。有一天飞哥和勇哥终于按耐不住觉得我总是测试光学打光做电子元器件可能就真的要废了，便让我用Visual Studio把一张图片用窗口显示出来，然后对图片进行二值化处理，提取特征值。\n>\n>我印象特别深刻，方法函数里面涉及到了好多Mat，如今开始动OpenCV第一个碰到的东西就是Mat，在这里把研读的关于Mat类，记录一下。\n\n***\n\n>OpenCV官方文档是这样界定Mat的：基本的图像容器。\n\n>处理一张图片为何要用到图像的容器这种定义的概念？没有《图像处理技术》基础知识的人可能不太能懂图像为何需要一个基本的图像容器去处理。我本科学的《图像处理技术》的基础内容现在也不太记得，脑海中只有一些隐约的印象：图像是很多像素点构成，每个像素点有具体的像素值(0~255)，一张二维平面上的图片，它上面所有的点平面坐标位置，有点像《线性代数》里的矩阵，处理一张图片就是处理图片上所包含的像素值的信息，所以图片的处理，就可以转换成矩阵运算。\n>\n>正如OpenCV官方文档上说到的：如何获取并存储这些像素值由我们的需求而定，最终在计算机世界里所有图像都可以简化为数值矩以及矩阵信息。作为一个计算机视觉库， OpenCV 其主要目的就是通过处理和操作这些信息，来获取更高级的信息。因此，OpenCV如何存储并操作图像是你首先要学习的。\n\n***\n\n<!--more-->\n\nMat的发展情况：\n\n在2001年刚刚出现的时候，OpenCV基于C语言接口而建。为了在内存（memory）中存放图像，当时采用名为IplImage的C语言结构体，时至今日这仍出现在大多数的旧版教程和教学材料。但这种方法必须接受C语言所有的不足，这其中最大的不足要数手动内存管理，其依据是用户要为开辟和销毁内存负责。虽然对于小型的程序来说手动管理内存不是问题，但一旦代码开始变得越来越庞大，你需要越来越多地纠缠于这个问题，而不是着力解决你的开发目标。\n\n幸运的是，C++出现了，并且带来类的概念，这给用户带来另外一个选择：自动的内存管理（不严谨地说）。这是一个好消息，如果C++完全兼容C的话，这个变化不会带来兼容性问题。为此，OpenCV在2.0版本中引入了一个新的C++接口，利用自动内存管理给出了解决问题的新方法。使用这个方法，你不需要纠结在管理内存上，而且你的代码会变得简洁（少写多得）。但C++接口唯一的不足是当前许多嵌入式开发系统只支持C语言。所以，当目标不是这种开发平台时，没有必要使用旧方法（除非你是自找麻烦的受虐狂码农）。\n\n***\n\n关于 Mat ，首先要知道的是你不必再手动地（1）为其开辟空间（2）在不需要时立即将空间释放。但手动地做还是可以的：大多数OpenCV函数仍会手动地为输出数据开辟空间。当传递一个已经存在的 Mat 对象时，开辟好的矩阵空间会被重用。也就是说，我们每次都使用大小正好的内存来完成任务。\n\n基本上讲 Mat 是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸，存储方法，存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建拷贝时，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是家常便饭。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，我们不应该拷贝 大 的图像，因为这会降低程序速度。\n\n为了搞定这个问题，OpenCV使用引用计数机制。其思路是让每个 Mat 对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则 只拷贝信息头和矩阵指针 ，而不拷贝矩阵。\n\n***\n\n关于 Mat 内存管理的问题：\n\n如果矩阵属于多个 Mat 对象，那么当不再需要它时谁来负责清理？简单的回答是：最后一个使用它的对象。通过引用计数机制来实现。无论什么时候有人拷贝了一个 Mat 对象的信息头，都会增加矩阵的引用次数；反之当一个头被释放之后，这个计数被减一；当计数值为零，矩阵会被清理。但某些时候你仍会想拷贝矩阵本身(不只是信息头和矩阵指针)，这时可以使用函数 clone() 或者 copyTo() 。\n\n***\n\n1.OpenCV函数中输出图像的内存分配是自动完成的（如果不特别指定的话）。\n\n2.使用OpenCV的C++接口时不需要考虑内存释放问题。\n\n3.赋值运算符和拷贝构造函数（ ctor ）只拷贝信息头。\n\n4.使用函数 clone() 或者 copyTo() 来拷贝一副图像的矩阵。\n\n***\n\n以上是对图像以及 Mat类发展，以及OpenCV在处理图像时的内存管理的一个简单的了解。\n\n\n\n接下来要了解一下OpenCV是如何存储图像的：\n\n这里讲述如何存储像素值。需要指定颜色空间和数据类型。颜色空间是指对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间，只处理黑色和白色，对它们进行组合可以产生不同程度的灰色。\n\n对于 彩色 方式则有更多种类的颜色空间，但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。RGB颜色空间是最常用的一种颜色空间，这归功于它也是人眼内部构成颜色的方式。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素 alpha (A)。\n\n有很多的颜色系统，各有自身优势：\n\n1.RGB是最常见的，这是因为人眼采用相似的工作机制，它也被显示设备所采用。\n\n2.HSV和HLS把颜色分解成色调、饱和度和亮度/明度。这是描述颜色更自然的方式，比如可以通过抛弃最后一个元素，使算法对输入图像的光照条件不敏感。\n\n3.YCrCb在JPEG图像格式中广泛使用。\n\n4.CIE L * a * b *是一种在感知上均匀的颜色空间，它适合用来度量两个颜色之间的距离。\n\n每个组成元素都有其自己的定义域，取决于其数据类型。如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ，占一个字节或者8位，可以是有符号型（0到255之间）或无符号型（-127到+127之间）。尽管使用三个 char 型元素已经可以表示1600万种可能的颜色（使用RGB颜色空间），但若使用float（4字节，32位）或double（8字节，64位）则能给出更加精细的颜色分辨能力。但同时也要切记增加元素的尺寸也会增加了图像所占的内存空间。\n\n***\n\n关于Mat类的创建，具体的代码和内容可以查阅[OpenCV中文网](http://www.opencv.org.cn/)里的相关入门教学，当然还要具备一点点基础的C++入门知识。\n\n***\n待续以后会更新相关内容，等我把C++入门摸一下。\n\n\n","updated":"2018-04-20T07:18:05.969Z","permalink":"http://yoursite.com/2017/02/20/OpenCV%E4%B9%8BMat(%E4%B8%80)/","categories":[]},{"title":"人脸识别01","date":"2017-02-20T02:01:22.000Z","path":"2017/02/20/人脸识别01/","text":"废话内容，写在前面: 2016年上半年在上海面试的时候。徐汇区有一家做社交的互联网公司开始打算做人脸识别，由此我了解了深圳脸萌科技的FaceU这款超级激萌的App。很有意思的是徐汇区那家社交公司面试我的时候跟我说的很明确：你做一个类似FaceU的demo给我，我就给你发Offer。有时候我在想一份工作好简单啊，只要你会做人脸识别添加贴纸贴片，一碗饭就来了。 回去之后，我对比了iOS框架自带的人脸识别框架识别的精度不够高，侧脸极其难识别，我只好放弃转而奔向科大讯飞人脸识别的框架去做。 那一个礼拜的时间里，我看科大讯飞的人脸识别SDK和官方Demo，在做识别的过程中想加贴片装饰品的时候，遇到了二个代理方法的冲突，导致某个识别状态始终无法修改。所以那次的demo最终是没有做出来。 时隔快一年，我想人脸识别功能我该动一动了，恰好个人技术博客刚开张，也应该来一点技术干货。同时不一样的是，这次我也不打算用科大讯飞的框架，我想从OpenCV的开源库着手，多多少少还可以学点C++的函数也还不错。 由此我想把研究人脸识别的过程记录下来。所以这个系列是一个不懂C++的iOS开发小白的学习过程。 本系列文章，所有测试内容以及demo的环境如下： 1）Xcode Version 8.2.1 2）OpenCV for iOS 3.2.0 准备工作： 1）先去OpenCV官网下载最新的OpenCV For iOS的视觉库。 2）Xcode创建一个新的项目，把下载的OpenCV库导入工程，并在工程的Building phase里面添加 opencv2.framework。 如果对OpenCV有所了解的会知道，OpenCV的代码是基于C++编写的。因此，想要在Xcode项目中运行C++代码，你需要把文件名后缀名由.m改成.mm即可（当然最好把OpenCV的功能函数写一层OC的API封装，这样可能会比较安全，也会少很多不必要的错误麻烦，也更符合开发需求。）。 注意：OpenCV 声明了命名空间 cv，因此 OpenCV 的类的前面会有个 cv:: 前缀，就像 cv::Mat、 cv::Algorithm 等等。你也可以在 .mm 文件中使用 using namespace cv 来避免在一堆类名前使用 cv:: 前缀。 但是，在某些类名前你必须使用命名空间前缀，比如 cv::Rect 和 cv::Point，因为它们会跟定义在 MacTypes.h 中的 Rect 和 Point 相冲突。尽管这只是个人偏好问题，个人偏向在任何地方都使用 cv:: 以保持一致性。 C++ 命名空间namespace的作用和使用: 命名空间是ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。其作用就是规定该文件中使用的标准库函数都是在标准命名空间std中定义的。通常来说，在C++中，命名空间（namespace）的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个全局命名空间（global namespace），全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用::member的形式表示）。 在C语言中定义了3个层次的作用域，即文件(编译单元)、函数和复合语句。C++在C的基础上又引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。 在导入 opencv2.framework 之后，把你需要加入OpenCV代码的文件的.m文件后缀由.m改成.mm 引入头文件 #import &lt; opencv2/opencv.hpp&gt; #import &lt;opencv2/imgproc/types_c.h&gt; #import &lt;opencv2/imgcodecs/ios.h&gt; 编译运行。 PS:我编译的时候，有二个报错。经过查阅资料做了具体的修改调整之后可以正常运行，分别是OpenCV库的 blenders.hpp 文件 enum &#123; NO, FEATHER, MULTI_BAND &#125;; 修改成： enum &#123; NO_EXPOSURE_COMPENSATOR, FEATHER, MULTI_BAND &#125;; 和 exposure_compensate.hpp 文件 enum &#123; NO, GAIN, GAIN_BLOCKS &#125;; 修改成： enum &#123; NO_EXPOSURE_COMPENSATOR, GAIN, GAIN_BLOCKS &#125;; 先来试试OpenCV的入门内容，把一张彩色图片变成灰色的 在控制器的.mm文件中引入Mat类 @interface ViewController () &#123; cv::Mat cvImage; &#125; @end 关于Mat类:详见另一篇Blog：OpenCV之Mat(一) 图像处理的代码块如下： if(!cvImage.empty())&#123; cv::Mat gray; // 将图像转换为灰度显示 cv::cvtColor(cvImage,gray,CV_RGB2GRAY); // 应用高斯滤波器去除小的边缘 cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2); // 计算与画布边缘 cv::Mat edges; cv::Canny(gray, edges, 0, 50); // 使用白色填充 cvImage.setTo(cv::Scalar::all(225)); // 修改边缘颜色 cvImage.setTo(cv::Scalar(0,128,255,255),edges); // 将Mat转换为Xcode的UIImageView显示 self.testImgView1.image = MatToUIImage(cvImage); &#125; 如果你和我一样运行Xcode之后能得到下图的处理后的照片内容的话，图像的灰度显示算是完成了。 也就是说OpenCV的第一个代码块已经完成了。 如果还有兴趣的话，可以接着玩玩—–人脸识别 现在在你的.mm控制器里引入CascadeClassifier类 @interface ViewController () &#123; cv::CascadeClassifier faceDetector; &#125; @end 关于CascadeClassifier类的调研:详见另一篇Blog：OpenCV之CascadeClassifier(一) 人脸识别核心代码如下: NSString *cascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt&quot; ofType:@&quot;xml&quot;]; faceDetector.load([cascadePath UTF8String]); cv::Mat faceImage; UIImageToMat(image, faceImage); // 转为灰度 cv::Mat gray; cvtColor(faceImage, gray, CV_BGR2GRAY); // 检测人脸并储存 std::vector&lt;cv::Rect&gt;faces; faceDetector.detectMultiScale(gray, faces,1.1,2,0|CV_HAAR_SCALE_IMAGE,cv::Size(30,30)); // 在每个人脸上画一个红色四方形 for(unsigned int i= 0;i &lt; faces.size();i++) &#123; const cv::Rect&amp; face = faces[i]; cv::Point tl(face.x,face.y); cv::Point br = tl + cv::Point(face.width,face.height); // 四方形的画法 cv::Scalar magenta = cv::Scalar(255, 0, 255); cv::rectangle(faceImage, tl, br, magenta, 4, 8, 0); &#125; self.testImgView2.image = MatToUIImage(faceImage); 补充:haarcascade_frontalface_alt.xml该文件是专门用来训练cv::CascadeClassifier函数的资源文件 为什么一定要添加xml文件呢？ 其实这个xml文件就是对人脸识别的初始化（初始化数据by Paul Viola and later extended by Rainer Lienhart），现在已经成为一种人脸识别的标准了。 为了能够把xml文件成功倒入，我们需要把NSString object 转化为 std::string（使用UTF8String） 经过以上的准备工作后我们就可以使用方法detectMultiScale进行人脸检测了。 方法detectMultiScale有四个参数。分别为： scaleFactor ：制定循环递减的图片尺寸 minNeighbors ：制定保留数据的矩形大小 CV_HAAR_SCALE_IMAGE ：这是一个标志，它指定算法缩放图像，而不是检测器。它有助于实现最佳的性能 minSize ：该参数指定最小可能的面部尺寸 如果可以得到下图(imageView重新布局了)，第三张图片里的每个人脸上都有正方形的框，表示已经找到了人脸位置。 到此时，静态图片的人脸识别算是初步完成。","raw":"---\ntitle: 人脸识别01\ndate: 2017-02-20  10:01:22\ncategories:\ntoc: false\ntags:\n     - Cpp\n     - 人脸识别\n     - OpenCV   \n---\n\n>废话内容，写在前面:\n>\n>2016年上半年在上海面试的时候。徐汇区有一家做社交的互联网公司开始打算做人脸识别，由此我了解了深圳脸萌科技的FaceU这款超级激萌的App。很有意思的是徐汇区那家社交公司面试我的时候跟我说的很明确：你做一个类似FaceU的demo给我，我就给你发Offer。有时候我在想一份工作好简单啊，只要你会做人脸识别添加贴纸贴片，一碗饭就来了。\n>\n>回去之后，我对比了iOS框架自带的人脸识别框架识别的精度不够高，侧脸极其难识别，我只好放弃转而奔向科大讯飞人脸识别的框架去做。\n>\n>那一个礼拜的时间里，我看科大讯飞的人脸识别SDK和官方Demo，在做识别的过程中想加贴片装饰品的时候，遇到了二个代理方法的冲突，导致某个识别状态始终无法修改。所以那次的demo最终是没有做出来。\n>\n>时隔快一年，我想人脸识别功能我该动一动了，恰好个人技术博客刚开张，也应该来一点技术干货。同时不一样的是，这次我也不打算用科大讯飞的框架，我想从OpenCV的开源库着手，多多少少还可以学点C++的函数也还不错。\n>\n>由此我想把研究人脸识别的过程记录下来。所以这个系列是一个不懂C++的iOS开发小白的学习过程。\n\n>本系列文章，所有测试内容以及demo的环境如下：\n>\n>1）Xcode Version 8.2.1\n>\n>2）OpenCV for iOS 3.2.0 \n>\n\n\n<!--more-->\n\n准备工作：\n\n1）先去[OpenCV官网](http://opencv.org/)下载最新的OpenCV For iOS的视觉库。\n\n2）Xcode创建一个新的项目，把下载的OpenCV库导入工程，并在工程的Building phase里面添加 opencv2.framework。\n\n\n如果对OpenCV有所了解的会知道，OpenCV的代码是基于C++编写的。因此，想要在Xcode项目中运行C++代码，你需要把文件名后缀名由.m改成.mm即可（当然最好把OpenCV的功能函数写一层OC的API封装，这样可能会比较安全，也会少很多不必要的错误麻烦，也更符合开发需求。）。\n\n注意：OpenCV 声明了命名空间 cv，因此 OpenCV 的类的前面会有个 cv:: 前缀，就像 cv::Mat、 cv::Algorithm 等等。你也可以在 .mm 文件中使用 using namespace cv 来避免在一堆类名前使用 cv:: 前缀。\n\n但是，在某些类名前你必须使用命名空间前缀，比如 cv::Rect 和 cv::Point，因为它们会跟定义在 MacTypes.h 中的 Rect 和 Point 相冲突。尽管这只是个人偏好问题，个人偏向在任何地方都使用 cv:: 以保持一致性。\n\n\n>C++ 命名空间namespace的作用和使用:\n>\n>命名空间是ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。其作用就是规定该文件中使用的标准库函数都是在标准命名空间std中定义的。通常来说，在C++中，命名空间（namespace）的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个全局命名空间（global namespace），全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用::member的形式表示）。\n>\n>在C语言中定义了3个层次的作用域，即文件(编译单元)、函数和复合语句。C++在C的基础上又引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。\n\n在导入  opencv2.framework  之后，把你需要加入OpenCV代码的文件的.m文件后缀由.m改成.mm\n\n引入头文件\n\n    #import < opencv2/opencv.hpp>\n    #import <opencv2/imgproc/types_c.h>\n    #import <opencv2/imgcodecs/ios.h>\n    \n编译运行。\n\nPS:我编译的时候，有二个报错。经过查阅资料做了具体的修改调整之后可以正常运行，分别是OpenCV库的 \n\n blenders.hpp 文件\n\n    enum { NO, FEATHER, MULTI_BAND };\n      \n修改成：\n\n    enum { NO_EXPOSURE_COMPENSATOR, FEATHER, MULTI_BAND };\n      \n和  exposure_compensate.hpp  文件\n\n    enum { NO, GAIN, GAIN_BLOCKS };   \n    \n修改成：\n    \n    enum { NO_EXPOSURE_COMPENSATOR, GAIN, GAIN_BLOCKS };\n    \n    \n先来试试OpenCV的入门内容，把一张彩色图片变成灰色的\n\n在控制器的.mm文件中引入Mat类\n\n    @interface ViewController ()\n\t{\n\t   cv::Mat cvImage;\n\t}\n\t@end\n\t\n>关于Mat类:\n>详见另一篇Blog：[OpenCV之Mat(一)](/2017/02/20/OpenCV之Mat-一/)\n\n图像处理的代码块如下：\n\n    if(!cvImage.empty()){\n        cv::Mat gray;\n        // 将图像转换为灰度显示\n        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);\n        // 应用高斯滤波器去除小的边缘\n        cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2);\n        // 计算与画布边缘\n        cv::Mat edges;\n        cv::Canny(gray, edges, 0, 50);\n        // 使用白色填充\n        cvImage.setTo(cv::Scalar::all(225));\n        // 修改边缘颜色\n        cvImage.setTo(cv::Scalar(0,128,255,255),edges);\n        // 将Mat转换为Xcode的UIImageView显示\n        self.testImgView1.image = MatToUIImage(cvImage);\n    }\n\n如果你和我一样运行Xcode之后能得到下图的处理后的照片内容的话，图像的灰度显示算是完成了。 \n\n\n\n也就是说OpenCV的第一个代码块已经完成了。\n\n\n如果还有兴趣的话，可以接着玩玩-----人脸识别 \n \n现在在你的.mm控制器里引入CascadeClassifier类\n\n    @interface ViewController ()\n    {\n        cv::CascadeClassifier faceDetector;\n    }\n    @end\n\n>关于CascadeClassifier类的调研:\n>详见另一篇Blog：[OpenCV之CascadeClassifier(一)](/2017/02/20/OpenCV之CascadeClassifier-一/)\n\n人脸识别核心代码如下:\n    \n    NSString *cascadePath = [[NSBundle mainBundle]\n                             pathForResource:@\"haarcascade_frontalface_alt\"\n                             ofType:@\"xml\"];\n    faceDetector.load([cascadePath UTF8String]);\n    \n    cv::Mat faceImage;\n    UIImageToMat(image, faceImage);\n    \n    // 转为灰度\n    cv::Mat gray;\n    cvtColor(faceImage, gray, CV_BGR2GRAY);\n    \n    // 检测人脸并储存\n    std::vector<cv::Rect>faces;\n    faceDetector.detectMultiScale(gray, faces,1.1,2,0|CV_HAAR_SCALE_IMAGE,cv::Size(30,30));\n    \n    // 在每个人脸上画一个红色四方形\n    for(unsigned int i= 0;i < faces.size();i++)\n    {\n        const cv::Rect& face = faces[i];\n        cv::Point tl(face.x,face.y);\n        cv::Point br = tl + cv::Point(face.width,face.height);\n        \n        // 四方形的画法\n        cv::Scalar magenta = cv::Scalar(255, 0, 255);\n        cv::rectangle(faceImage, tl, br, magenta, 4, 8, 0);\n    }\n    self.testImgView2.image = MatToUIImage(faceImage);\n\n补充:haarcascade_frontalface_alt.xml该文件是专门用来训练cv::CascadeClassifier函数的资源文件\n\n>为什么一定要添加xml文件呢？\n>\n>其实这个xml文件就是对人脸识别的初始化（初始化数据by Paul Viola and later extended by Rainer Lienhart），现在已经成为一种人脸识别的标准了。\n>\n>为了能够把xml文件成功倒入，我们需要把NSString object 转化为 std::string（使用UTF8String）\n>\n>经过以上的准备工作后我们就可以使用方法detectMultiScale进行人脸检测了。\n>\n>方法detectMultiScale有四个参数。分别为：\n>\n>scaleFactor ：制定循环递减的图片尺寸\n>\n>minNeighbors ：制定保留数据的矩形大小\n\n>CV_HAAR_SCALE_IMAGE ：这是一个标志，它指定算法缩放图像，而不是检测器。它有助于实现最佳的性能\n\n>minSize ：该参数指定最小可能的面部尺寸\n\n如果可以得到下图(imageView重新布局了)，第三张图片里的每个人脸上都有正方形的框，表示已经找到了人脸位置。\n  \n\n到此时，静态图片的人脸识别算是初步完成。\n\n\n","updated":"2018-11-14T07:40:52.157Z","permalink":"http://yoursite.com/2017/02/20/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB01/","categories":[]},{"title":"尝试逃离上广深","date":"2017-02-19T13:53:20.000Z","path":"2017/02/19/尝试逃离上广深/","text":"2017年2月19日了，这天比预期的时间晚来了30天，30天前我告诉自己，要弄一个个人站点。 本来在现有的Hexo成熟的框架条件下，个人博客最多20分钟就可以弄好，但是我却花了比我预期多的多的时间。这些事件都耗费在哪了？耗费在不够专注：上班修改优化项目零碎的时间里，Hexo安装错误，一波接着一波的安装卸载，GitHub Pages删了又重新添加，全是无用之功。 2月17日那天一天跑了四个面试，Cisco上海的技术面问了我很多基础的东西，26分钟后从大厦出来，从没有如此草率的面试，毫无准备，必然不会受到太高的待见。可是为啥我要把自己的实力不足归咎于准备不充分呢？没有什么台阶要给自己下的。自己的无能是原罪。下午在浦东张江高科，那个逆向开发公司的技术面和我聊了20多分钟，问我最近研究什么，问我最近开发上的难点有哪些，我一五一十的说着：搭建个人站点，研究夜间模式以及多主题设计思路和优化方案。后来问我：你会给iPhone越狱嘛？我说我没做过的时候他合起了他的Mac Book，我想这已经终结聊天了。我原本也是抱着试试的态度来的，iOS开发的汇编底层我知道暂时没那个能力去做，不被待见显而易见。但是这还是我第一次面试像别人展示自己的时候和别人想获取的信息完全不在同一个频道上，难免感到话题有点难聊，让我感觉空气里到处弥漫着尴尬。 46分钟之后我离开了那家逆向开发公司，打车去找老甲，我坐在老甲公司楼下的台阶上吹冷风，手机没电我打开Mac给它喂电。我告诉自己都会好的，就像春天来了，柳絮会飘，秋天来了，柿子会熟。少年，你不能太着急哟，我安慰自己，你可以的，这个世界本来就给你留好了位置，你还没遇到最好的自己。可是那天的风好大，吹的我鼻子好难受，鼻子好酸，眼角都湿得一直没干。自我安慰的那些屁话，肯定没有老甲带我去吃的那顿热气腾腾的麻辣烫管用。张江高科消费好贵啊，0.8公斤的料，48块钱，温饱了那天傍晚饥饿的灵魂。 晚上回来之后想想，大概是太过于急功近利。技术需要沉淀的，一点点去学，代码要慢慢的打磨，一行行的敲。这个膨胀的社会却不给年轻人那么多时间去沉淀，膨胀的自己也不给自己那么多机会去尝试。 2016年的每一天我都掰开着用，这一年我都没时间去做噩梦，忙得让我很少在半夜里会醒来，往往都是半夜才睡。那个时候我告诉自己，你要努力，你现在多累些，当下就少求别人一点。下半年项目加班加点，干过40多个小时没合眼，我也不曾抱怨，因为毕竟自己菜，只能用时间来弥补，我把别人喝咖啡的时候都用来写代码了。我庆幸我足够的年轻，年轻到身体严重负荷的时候，仅仅只是胸口有点痛而已。一觉醒来，还可以继续搬砖。 有时候很多事情来的莫名其妙，中午在地铁上打瞌睡打盹点开Boss聊了一个，后来才知道那是合肥的一家美容公司。紧接着下午就视讯通话面试过了，傍晚给我发了Offer，在合肥，试用期税前9K，转正11K。可是我不知道为啥高兴不起来呢，是我过于贪恋一线城市夜晚的霓虹灯么？总是在心里告诉自己一线城市机会多，技术提升快？可是迟早终究要回到那个城市的，为何不早做打算，非要漫无目的的幻想么？ 现在这个机会就摆在我的面前了，我却踌躇满志，迈不开步子。可这又算什么呢？反正我的时间又不值钱，可以大把的浪费大把的挥霍。 年轻就是这样的吧，都不确定，都在准备呢。试试又不是一个坏事。 何况又不是最惨的时候。 毕竟还有那么多希望。","raw":"---\ntitle: 尝试逃离上广深\ndate: 2017-2-19 21:53:20\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n\n2017年2月19日了，这天比预期的时间晚来了30天，30天前我告诉自己，要弄一个个人站点。\n\n本来在现有的Hexo成熟的框架条件下，个人博客最多20分钟就可以弄好，但是我却花了比我预期多的多的时间。这些事件都耗费在哪了？耗费在不够专注：上班修改优化项目零碎的时间里，Hexo安装错误，一波接着一波的安装卸载，GitHub Pages删了又重新添加，全是无用之功。\n\n<!--more-->\n\n2月17日那天一天跑了四个面试，Cisco上海的技术面问了我很多基础的东西，26分钟后从大厦出来，从没有如此草率的面试，毫无准备，必然不会受到太高的待见。可是为啥我要把自己的实力不足归咎于准备不充分呢？没有什么台阶要给自己下的。自己的无能是原罪。下午在浦东张江高科，那个逆向开发公司的技术面和我聊了20多分钟，问我最近研究什么，问我最近开发上的难点有哪些，我一五一十的说着：搭建个人站点，研究夜间模式以及多主题设计思路和优化方案。后来问我：你会给iPhone越狱嘛？我说我没做过的时候他合起了他的Mac Book，我想这已经终结聊天了。我原本也是抱着试试的态度来的，iOS开发的汇编底层我知道暂时没那个能力去做，不被待见显而易见。但是这还是我第一次面试像别人展示自己的时候和别人想获取的信息完全不在同一个频道上，难免感到话题有点难聊，让我感觉空气里到处弥漫着尴尬。\n\n46分钟之后我离开了那家逆向开发公司，打车去找老甲，我坐在老甲公司楼下的台阶上吹冷风，手机没电我打开Mac给它喂电。我告诉自己都会好的，就像春天来了，柳絮会飘，秋天来了，柿子会熟。少年，你不能太着急哟，我安慰自己，你可以的，这个世界本来就给你留好了位置，你还没遇到最好的自己。可是那天的风好大，吹的我鼻子好难受，鼻子好酸，眼角都湿得一直没干。自我安慰的那些屁话，肯定没有老甲带我去吃的那顿热气腾腾的麻辣烫管用。张江高科消费好贵啊，0.8公斤的料，48块钱，温饱了那天傍晚饥饿的灵魂。\n\n\n晚上回来之后想想，大概是太过于急功近利。技术需要沉淀的，一点点去学，代码要慢慢的打磨，一行行的敲。这个膨胀的社会却不给年轻人那么多时间去沉淀，膨胀的自己也不给自己那么多机会去尝试。\n\n\n2016年的每一天我都掰开着用，这一年我都没时间去做噩梦，忙得让我很少在半夜里会醒来，往往都是半夜才睡。那个时候我告诉自己，你要努力，你现在多累些，当下就少求别人一点。下半年项目加班加点，干过40多个小时没合眼，我也不曾抱怨，因为毕竟自己菜，只能用时间来弥补，我把别人喝咖啡的时候都用来写代码了。我庆幸我足够的年轻，年轻到身体严重负荷的时候，仅仅只是胸口有点痛而已。一觉醒来，还可以继续搬砖。\n\n\n有时候很多事情来的莫名其妙，中午在地铁上打瞌睡打盹点开Boss聊了一个，后来才知道那是合肥的一家美容公司。紧接着下午就视讯通话面试过了，傍晚给我发了Offer，在合肥，试用期税前9K，转正11K。可是我不知道为啥高兴不起来呢，是我过于贪恋一线城市夜晚的霓虹灯么？总是在心里告诉自己一线城市机会多，技术提升快？可是迟早终究要回到那个城市的，为何不早做打算，非要漫无目的的幻想么？\n\n\n现在这个机会就摆在我的面前了，我却踌躇满志，迈不开步子。可这又算什么呢？反正我的时间又不值钱，可以大把的浪费大把的挥霍。\n\n\n年轻就是这样的吧，都不确定，都在准备呢。试试又不是一个坏事。\n\n何况又不是最惨的时候。\n\n毕竟还有那么多希望。\n\n","updated":"2021-06-05T18:03:14.013Z","permalink":"http://yoursite.com/2017/02/19/%E5%B0%9D%E8%AF%95%E9%80%83%E7%A6%BB%E4%B8%8A%E5%B9%BF%E6%B7%B1/","categories":[]}]