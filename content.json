[{"title":"Python02","date":"2017-12-05T07:47:13.000Z","path":"2017/12/05/Python02/","text":"list (列表)Python内置一种数据类型是列表:list,list是一种有序的集合,可以随时添加和删除其中的元素;其功效和作用和OC以及swift里的可变数组类似; 用len(xxxx)函数可以获得list元素的个数; 用索引来访问list中每一个位置的元素,索引是从0开始;当索引超出了范围时,Python会报一个IndexError错误,所以,要确保索引不要越界,最后一个元素的索引是len(xxxx) - 1;当用来倒数索引查找的时候,我们可以省略len(xxxx),直接写-1,-2,-3,以此类推; 用append(xxxxxxx)函数可以在list末尾追加元素; 用insert(index,xxxxxxx)函数可以在list中插入元素,且是指定位置插入; 用pop()函数可以删除list末尾的元素; 要删除指定位置的元素,用pop(i)方法,其中i是索引位置; 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置; list里面的元素的数据类型也可以不同; list元素也可以是另一个list; tuple (元组)Python内置另一种有序列表叫元组:tuple,tuple和list非常类似,但是tuple一旦初始化就不能修改;其功效和作用和OC以及swift里的不可变数组类似;tuple没有append()，insert()这样的方法,其他获取元素的方法和list是一样的;因为tuple不可变,所以代码更安全.如果可能,能用tuple代替list就尽量用tuple.当定义一个tuple时,在定义的时候tuple的元素就必须被确定下来;如果要定义一个空的tuple,可以写成();只有1个元素的tuple定义时必须加一个逗号,用来来消除歧义; t(1,) 条件判断elif是else if的缩写 if &lt;条件判断1&gt;: &lt;执行1&gt; elif &lt;条件判断2&gt;: &lt;执行2&gt; elif &lt;条件判断3&gt;: &lt;执行3&gt; else: &lt;执行4&gt; if语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else 循环for in 和 while ;while循环,只要条件满足,就不断循环,条件不满足时退出循环.在循环中,break语句可以提前退出循环.在循环过程中,可以通过continue语句,跳过当前的这次循环,直接开始下一次循环.continue的作用是提前结束本轮循环,并直接开始下一轮循环. dict (dictionary)Python内置了字典：dict的支持,dict全称dictionary,在其他语言中也称为map,使用键-值（key-value）存储,有极快的查找速度.由于一个key只能对应一个value,所以,多次对一个key放入value,后面的值会把前面的值冲掉;如果key不存在,dict就会报错;要避免key不存在的错误,有两种办法:一是通过in判断key是否存在;二是通过dict提供的get()方法,如果key不存在,可以返回None,或者自己指定的value;(返回None的时候Python的交互环境不显示结果)要删除一个key,用pop(key)方法,对应的value也会从dict中删除; 和list比较,dict有以下几个特点: 查找和插入的速度极快,不会随着key的增加而变慢;需要占用大量的内存,内存浪费多.而list相反:查找和插入的时间随着元素的增加而增加;占用空间小,浪费内存很少. 所以,dict是用空间来换取时间的一种方法. dict通过Key找Value的位置遵循的是哈希算法,所以同时也就要求了dict的Key必须具有唯一性,所以dict的Key是一个不可变对象且唯一,要保证hash的正确性,作为key的对象就不能变.在Python中,字符串、整数等都是不可变的,因此,可以放心地作为key.而list是可变的,就不能作为key; setset和dict类似,也是一组key的集合,但不存储value.由于key不能重复,所以,在set中,没有重复的key.通过add(key)方法可以添加元素到set中,可以重复添加,但不会有效果.通过remove(key)方法可以删除元素.set可以看成数学意义上的无序和无重复元素的集合,因此,两个set可以做数学意义上的交集/并集等操作(&amp; 取交集, | 取并集).","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Python list","slug":"Python-list","permalink":"http://yoursite.com/tags/Python-list/"},{"name":"Python tuple","slug":"Python-tuple","permalink":"http://yoursite.com/tags/Python-tuple/"},{"name":"Python 条件判断","slug":"Python-条件判断","permalink":"http://yoursite.com/tags/Python-条件判断/"}]},{"title":"Python01","date":"2017-11-29T03:22:20.000Z","path":"2017/11/29/Python01/","text":"Python基础Python的语法比较简单，采用缩进方式 实例: #这里是注释,可以写随便的内容,Python的注释采用 #Python的每一行都是一个语句,假如语句以:结尾,其后缩进的语句相当于代码块 #Python缩进多少个空格还是一个tab的长度呢,没有明确规定,但是约定俗成采用 4 个空格缩进 #为了方便在文本编辑器中，把Tab自动转换为4个空格，确保不混用Tab和空格,可以提高编写效率 #缩进的坏处就是“复制－粘贴”功能失效 #当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确 #此外，ide很难像格式化Java代码那样格式化Python代码 #PS:Python程序是大小写敏感的，是区分大小写的 a = 100 if a &gt;= 0: print(a) else: print(-a) 数据类型1.整数有正负,是精确值,即时是做除法运算也是精确值;2.浮点数,Python支持科学计数法,1.23x109和12.3x108是等同的,在Python上书写用e来代替进位10,也即1.23e9;3.字符串用一对双引号或者一对单引号,即’’或””;当字符串内部也包含’或者”的时候,和C语言一样,需要用转义字符; 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义; 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容; 注意在输入多行内容时，提示符由&gt;&gt;&gt;变为…，提示你可以接着上一行输入，注意…是提示符，不是代码的一部分;4.布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来; 布尔值可以用and、or和not运算,对应逻辑里的且或非;5.空值,空值是Python里一个特殊的值，用None表示; 变量语言中的变量的含义和中学课本中的变量的含义表示的内容和意义是一致的;同时变量类型本身不固定的语言多称为动态语言;但是这并不是100%的界定固定的东西,OC和Java在表面上都是静态语言,它们都同时符合静态语言的规定特征,但是OC和Java其实本质上都是动态语言,这是跟具体的语言特性还有关系,OC的Runtime Programming和Java的反射机制; PS:常量常量的本质是不变的变量; 小结:Python在处理整数的时候,它的可精确表达范围要比C语言还大,因为本质上Python直接是用比long long还要大的范围来进行二进制操作的,而对于浮点数而言,所有语言都一样,这是有限内存运算和无限无理数之间的战争 字符编码在最新的Python 3版本中,字符串是以Unicode编码的,也就是说,Python的字符串支持多语言. 格式化Python中,采用的格式化方式和C语言是一致的,用%实现. &gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos; &apos;Hello, world&apos; &gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) &apos;Hi, Michael, you have $1000000.&apos; 有几个%?占位符,后面就跟几个变量或者值,顺序要对应好.如果只有一个%?,括号可以省略.","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Python 基础","slug":"Python-基础","permalink":"http://yoursite.com/tags/Python-基础/"},{"name":"Python 数据类型","slug":"Python-数据类型","permalink":"http://yoursite.com/tags/Python-数据类型/"},{"name":"Python 变量","slug":"Python-变量","permalink":"http://yoursite.com/tags/Python-变量/"}]},{"title":"我能做些什么和我打算做些什么","date":"2017-11-27T08:55:01.000Z","path":"2017/11/27/我能做些什么和我打算做些什么/","text":"周末，就着3.0版本上架空档期，也感谢组织没有给我额外的任务，让我愉快的放松了两天，其实这两天陪姑娘逛杭州的时候，心里一直在思忖着：我能做些什么和我打算做些什么。 其实说实话，蛮多的感慨，因为我跟团队大部分人可能并不那么特别相似，其实2月份决定来放弃所有的合肥其他的offer来飞修更大的原因是项目的可行性和项目的公益性，项目可行我们已经用这么长的时间进行了验证，可能你们都没想到我会说项目的公益性，我觉得一个项目的公益性在于，假如我们做大了，我们可以给更多的人带来福利，这是做实业，是在建设和谐的社会主义不是么？会让你在跟别人聊天的时候，从你身上透露着你在兼善天下的牛逼感。 new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"爱你就像爱生命\", author: \"房东的猫\", url: \"http://ozwoorjfp.bkt.clouddn.com/%E6%88%BF%E4%B8%9C%E7%9A%84%E7%8C%AB%20-%20%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD.mp3\", pic: \"\", } }); 我觉得做好一个东西并不容易，日复一日的为此付出除了实现个人的财务自由挣票子之后，更多的是兴趣和热情的驱动，没有诚挚赤裸的心，是没法做成一件事的，只能浮于表面最终消亡。 那天中午，乐一歪着头问我：面试不用拘谨你抽烟的吧，来一根。 我笑着接过烟点上。 我心里多多少少明白，一个乐于跟你分享的领导，不论他以后变得怎样，但是起码现在不坏，如果你觉得跟他干没意义，可以先干着以后再走。这是我第一感觉。 他说我们在做一个维修项目，要整合合肥维修市场，我们拿到了老乡鸡的投资了，暂时有钱，只要能活过第二年，其他都没问题，包括给你双休。 我说挺好，能开到税后8K么，乐一说他要是不行的话，自己拿工资贴。（最后不用猜，绝对是狗白和小智拒绝了我的税后8K的要求。）即使后来给我电话讲：要是税前8K不能接受的话，那可能不行了，我们团队都是这个薪资，其他人不能同意。 说真的，那个时候我只用一个理由说服了我自己：行吧，离我姑娘很近，并不是所有的公司都能离我姑娘只有500米不到的距离。 所以我曾多次问过我自己，如果我在外漂泊，在最要奋斗的年纪，为了家庭来到合肥，如果是这辈子最正确的一件事，那么来到飞修也终将是一个以后能津津乐道的缘分。 我不曾抱着最大的恶意揣测任何人，也不曾有意诋毁任何人的能力，那是因为当你一开始用一种有缘，年轻，轻松，是件有意义的事来到一个团队的时候，你难免会对自己也好，对和你配合的人员也好，有种过高的期许，所以不可避免说了挺多比较没太给面子的话，我偶尔想想我是不是年纪越往后走，耐心变得是足够了，但是是不是期许也变得越来越大了，还是说这个团队还有很长的路要走，我们还需要更多的相互了解。我希望我这么久以来战斗而来的东西，都是有意义而被后来接手人能更好的利用，而不是像我，舔着刀口行走。 而作为一个客户端开发者，直接跟UI/产品/其他技术团队直接打交到且对配合人员期许较高的时候，之前难免会有点小摩擦，今天得空深刻总结反省，有幸是这些变化都让我们配合的更佳好，矛盾也能及时解决，这令我感到倍感欣慰，会让你觉得你既往所付出的心血，都如此值得，也能笑着为此开心。 今天是我来飞修整整9个月时间，9个月我觉得乐一让我从单休变成了单双休，兑现了他当初跟我讲的让我双休的一半，趁我还是在能加得动班的年纪，我觉这个老板还不坏，也想说这个朋友还不坏，即便哪天不再是老板和员工的关系，也能成为很好的朋友，能遇到一个守信的老板，且和你年纪一样的时候，你要想的是他身上有哪些闪光的东西是你能学的，并为此遇见感到高兴。 9个月的时间里，我只做了一点点卑微的工作，将飞修的客户端从1.0跌代到3.0，没有骄人的成绩，也没有突出的贡献，遵守本分，唯一觉得心里高兴的无非就是赶进度的同时，也能交的出去一份不算质量低的代码；如果需要我给我这9个月的工作打分，我能打9分，最后的1分我保留给刘欢，如果能在接下来的半年里带出来另一个娴熟的客户端开发的话，我觉得，那个时候我的工作是能打10分的，打10分意味着，我对得起老板给我创造的所有优秀的环境，给我发的每一分钱薪水。 从11月初，我就在问自己：假如有一天你能放下所有的事情，真去做一件事情不考虑薪水，不考虑环境的话，你愿意做什么？我想我可能会去做一个科学家研究那些年想做的物理课题研究。那么除了这个呢？做算法吧。 这些年还能激荡起心中热情的二件事，我庆幸还没有变。 飞修团队越来越大，每个岗位上的螺丝钉都要拧紧，然后尽自己最大的能力做好自己的份内的事情，要么被替换，要么收拾行囊离开，每天不虚度时光而过的有意义，你且需要的就是把自己最大热情度能投入的事情和你的工作相结合，如果刚刚好公司也是需要的，那么恭喜你，能成为一个快乐工作的人。 接下来我想试着往数据分析这个方向走一走，能走多远走多专业不知道，适不适合也不了解，但是唯一能让我感到开心和有信心的是：我还有很大的热忱和兴趣。 基于我现在对数据分析的行业了解：数据分析有两种，一种类似产品经理，类似产品经理向更加注重业务，对业务能力要求比较高；一种偏向数据挖掘，数据挖掘向更加注重技术，对算法代码能力要求比较高。 二者共同需要的技术的入门标准都是： SQL。 统计学基础。 Python或者R的基础。 二者有区别的技能树是： A.产品经理向：需要对业务感知能力强，对数据十分敏感，掌握常用的一些业务分析模型套路。为公司的业务负责的方向有：商业分析、数据运营、用户研究、策略分析等等。 B.数据挖掘向：需要牢固的底层基础，编程语言基础、算法、数据结构、统计学知识样样不能少。 于我而言，我是乐于专向数据挖掘方向的，但是这里有会有一个矛盾的点，我可能要一遍兼顾iOS的同时，也要学习新的领域的东西，对于我而言也是一个挑战。 其实我对自己的期许并不是做到一个数据分析师就行了，我对自己的要求是做到战略型数据分析师，能站在数据的角度引领公司整体战略。通过数据分析对公司业务以及行业前景进行预判，为公司制定战略的时候，给出科学的分析依据。进而推动公司战略发展，且能符合投资人的期望值。 然而我个人觉得，我的其他条件中有一个很重要的条件符合这个岗位：喜欢演讲。 乐于把你捕获的信息释法出去，用“人话”说给别人听，且让人听懂，这是一个重要的能力，一个好的数据分析师及时分析能力超群，不能把分析的结果用言语打动老板，让老板相信你跟你走，那么也是一个形同虚设。 以上这些，是我这二天出去玩的时候思考的结果。也有诸多的感慨，唯一能感受到的就是时间过的真快。昨日之事，历历在目。 此贴留为纪念，日后且看今日决策是否正确如预期。 愿诸君不忘初心，砥砺前行，与君共勉。 有时候想跟你们说：我爱你们，爱你们就像爱生命。（妈卖批，是假的哦！）","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"钱塘二渡","date":"2017-11-24T16:21:02.000Z","path":"2017/11/25/钱塘二渡/","text":"对杭州的冲动，不在于贪恋江南小家闺秀的气质。 西湖断桥苏白堤，孤山城中楼外楼。于我而言，一无过往，二无艳羡。 我感兴趣的是每个城市的人，和我相似的人们，是怎样的活着，根本上来讲还是在追寻自己活的最佳方式的过程中，想要寻找一些借鉴，这是我旅行的第一要点，所以美景其实是附属，西溪湿地也好，西湖断桥也罢，都是锦上添花的东西，并不是特别重要。第二要点是共同经历，姑娘说她没有和我去很多地方，我想现在大抵上还是年轻，走一走还是要的，且把时间拉后，倘若一旦为家庭操劳，这些皆是奢求，都只能是心头念。 这次吃了两顿杭帮菜，感觉自己可能并不是由衷的热爱，但是好像也没那么坏，我觉得杭帮菜蛮适合我，不至于吃得太多因为太腻歪；摇橹船的大叔让我别去楼外楼了，他说味道并不会太好，只是吃个名气，没啥意思。我在想，但凡这个世上所有的事情都听人劝，自己不去经历，那还有什么意义，别人的建议永远不会充耳不闻，但也不会照搬俗套，问自己想不想就行了。想吗？那就去哇！有意义吗？那还去干嘛？！我觉得能满足自己的想，就是最大的意义啊。 我跟人开玩笑讲：你在西溪湿地和西湖闲逛的时候，一个晃神，你还以为自己在汤池的相思林和金汤湖水库上逛。于苏杭本地人而言，楼外楼外养鱼塘西湖，此般小家碧玉的景致，自不能让人热血沸腾，唯恐是个虚名罢了，自然比不上广阔的天地宏伟的景观，可让人短暂抛却烦心事，也不算太差。 10月中旬，公司安排参加云栖大会，四天繁忙的交流讲座学习，时间甚是紧迫，外加阴雨绵绵，姑娘讨厌雨天，所以那次杭州的偷闲得空的游逛也随之搁浅。 云栖大会让我想起了早些年在深圳隔月的“深圳巅峰技术交流会”，跟荣杰蹭饭聚会的同时，和立华他们吹着牛逼，聊着好多想做却能力不够做不了的事情，那个时候感觉我们这些人都是互联网的希望，我们想做智能家居，我们想做很多东西，想解决最后一公里的需求，想创业想挣票子，想泡妞，这些大抵是那个时候的想法。 那个时候聊天的内容，很多东西上次在云栖大会上都见到了，仅仅是过了3-4年而已，我们吹的牛逼已经被这些互联网大佬变现了，我们要搞的无人机快递，我们要搞的人工智能汽车，我们要搞的人工智能家居，我们聊到的神经网络算法的应用于方方面面的同时，还有神经网络对超参数的各种优化，子模函数超模函数的概念，提高了精确度和算法速度的同时极大程度上缩短了神经网络算法参数的确定时间，也就实现了快速获取神经网络算法模型，举个简单的例子用人话来说就是：现在的技术可以达到用高速运行的相机拍照或者录制视频的同时，就可以进行同步识别了。 而3-4年前我们在深圳吹逼闲聊的时候说的要做实时的监控识别的想法，最大的技术门槛就是在于实时识别的反馈结果。那次我在听云栖的技术报告交流的时候，最大的感慨并不是这些大厂好厉害，这些学者好牛逼，而是感叹道：时间过的真尼玛快，好想回到那些年轻的岁月，多做那些有意义的事情。 我庆幸现在在很多事情上的努力有所回馈，也感谢自己的年轻，好多可以做的事情还有机会去做，除了庆幸就是感恩，感谢生命里遇到了这么多有意思的事和那些年已遇的奇迹。 经历放在纵向的意义上来看就会显得尤其的突出和重要，平行时间里的经历，永远都是未知的啊，经历只有有用的时候才会是经历，不然你会觉得是虚度。 经历了人和事，阅千重山行万里路，丰富生命的宽度，让自己在遇到的时候不会惊慌失措，不会变的无畏无知，而是从容淡然，想热血的时候热血，想激动的时候激动，这才是极佳的。 大抵上如此，日子慢悠悠的过。忙的时候疯狂陷入一种状态固然是充实的，但是还是要多走动多陪陪身边的人。注意休息注意身体健康，世间事，除死无大事，能活着，健康的活着比什么都强。 贪恋啊，红尘太过于美好，生活即便残酷，也还有精彩之处。 所以决定给博客开个新的板块。这也是城南旧事存在的意义。","categories":[],"tags":[{"name":"Travel","slug":"Travel","permalink":"http://yoursite.com/tags/Travel/"},{"name":"杭州","slug":"杭州","permalink":"http://yoursite.com/tags/杭州/"}]},{"title":"weak singleton模式在iOS中的应用","date":"2017-07-19T07:44:41.000Z","path":"2017/07/19/weak-singleton模式在iOS中的应用/","text":"关于weak要了解的基本内容： weak的使用场景：weak 的常见场景是在 delegate，block，NSTimer 中使用，我们经常用weak来避免以上场景中易产生的循环引用的问题。 weak的实际作用是：弱引用，在对象释放后置为 nil，避免错误的内存访问。也就是说：weak 可以在不增加对象的引用计数的同时，又使得指针的访问是安全的。 单例模式在OC和Swift这经常会被用到，好用的小模块工具类、很多SDK的初始化等等。但是这些单例的使用场景里都有一个共同的毛病，单例在被创建之后会伴随着进程一直存活，有时候我们的业务需求，特别是对于前端来说的话，很多单例模式的使用都是为了方便，所以我们其实很想在这些单例不必要存在的时候将它们释放掉，因为这些单例在一定程度上是有内存浪费的。 一个简单的例子：比如登陆模块的 LoginInstance 单例，我们在登陆之后除非需要二次登陆，不然就可能再也用不到这个单例了，我们最好的处理方式是将这个单例释放掉在登陆之后，而在登陆的过程当中我们随时随地的获取和使用这个单例，似乎这样的应用场景在前端开发中显得更多以及更常用，也似乎更佳的合理，更好的符合前端的性能尽可能的高的这种默认标准。 可是常规的单例模式无法实现上述需求，我们只能做到随时随地的获取使用这个单例，而无法释法这个单例。 那么，用weak试一下吧。 弱单例模式的 weak singleton 的具体实现代码如下+ (id)sharedInstance { static __weak ASingletonClass *instance; ASingletonClass *strongInstance = instance; @synchronized(self) { if (strongInstance == nil) { strongInstance = [[[self class] alloc] init]; instance = strongInstance; } } return strongInstance; } 这种特殊的单例有一个有意思的特性：在所有使用该单例的对象都释放后，单例对象本身也会自己释放。 如果 viewController A、B、C 三个视图控制器都调用了上面所描述的这种弱引用的弱单例模式。并且 viewController A、B、C 都持有 ASingletonClass 的强引用，一旦 A，B，C 都销毁后，这个单例就跟着销毁，而这个就跟我们之前的单例模式不一样了,它不会是从创建后就只能一直存在,无法释放。 这样我们再一次回到上述的登陆模块的时候，当我们的登陆控制器在棧里被释放掉之后，登陆的 LoginInstance 单例也会随即释放，这样就达到了我们想要的效果。 此外重要的是：当 LoginInstance 再次被调用时，LoginInstance 又会重新被创建。这样二次登陆的时候，LoginInstance 还是一个单例。 然而我们会发现：weak singleton 这种弱单例模式中的 weak ，有着很漂亮的作用，巧妙的利用了weak的作用来设计了一种我们很想要的效果的模式，从而也看出来，对于关键词weak而言，还有很多能发现的美。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"weak","slug":"weak","permalink":"http://yoursite.com/tags/weak/"},{"name":"weak singleton","slug":"weak-singleton","permalink":"http://yoursite.com/tags/weak-singleton/"},{"name":"弱单例模式","slug":"弱单例模式","permalink":"http://yoursite.com/tags/弱单例模式/"}]},{"title":"别管以后将如何结束，冷暖自愿尝透","date":"2017-03-31T16:16:31.000Z","path":"2017/04/01/别管以后将如何结束，冷暖自愿尝透/","text":"今天晚上9点多写代码的时候，隔壁的后端用电脑放了一首《萍聚》，霎那间被旋律带出了些许的难受。 很感谢尚且足够年轻的自己，感谢自己拥有一个每天爬起来都充满干劲的自己。我仔细的回忆了一下，我已经将近有3年的时间，不曾惶惶度日，从那一刻感到考研复习学习的时间不够的大四开始，我就每天都在舔着刀口数着时间过日子。 虽然有挺多时候熬夜特别幸苦，感到胸闷呼吸不够舒畅，但是好在身体并无大碍，我知道我亏欠年轻的自己太多，所以我好想爬的足够快，快到我自己可以为自己所做的事情开心。 我深感自己的平凡，但心里总会充满了对平庸的不甘和对庸俗的愤怒，但你却不得不承认，一个人的能力很有限。但是每次挫败的时候，我都在问自己做的够好不。 自从心里想好好写代码到现在，无时无刻不深感自己的无力，不是所有的事情都和学习成长般简单，你认识到了这世间还有事情是花时间是不够的。编程像一个无底深渊，没有最好，只有更好，一个没有极限的东西，你穷极所有时间，最后只会换来筋疲力竭的妥协。然后臭骂自己一句：你还是那么没用，毫无是处。 现如今二十多岁，不用多久就三十岁了，好可怕，我瞧瞧我自己，我的确很没用。而立之年，何立？我深知自己的现状，所以我从想好好努力活个让自己喜欢的人样开始，一直过的很煎熬，我挣扎的这一二三年里时间都过的好快，快的我措手不及，让我愈发慌乱。 所以我想对你们说的是我并不是不想好好陪你们，是我自己疯了，太心急想一口吃一个胖子，是我还没有好好沉下心来，做足够好的自己，是我太自负，自负到我以为很多事情很简单就能过去，往往比预期漫长得太多。 我平时开玩笑对你们说的那些我真没用的话，是真的是发自内心的。但是我这个人好贱的，我不希望别人说我没用，包括你。我只知道这个世界上，有些你越在乎的人，肆无忌惮的说挺多话都是伤人的，但是好贱的你却要原谅他们。这些碎言碎语，往往会让我想很多，想很久。你看我就是这么矫情的傻逼，那又能怎么办？ 我觉得我始终是个不负责任的人，妄想用年轻的所有精力来对未来好好负责，往往过不好当下。一个不懂得照顾自己的人，不懂得生活的人，不注重身体健康的人，的确有可嫌之处。也难为你们老说我是个傻逼，大抵说的都对，没有错。 我不愿意我在乎的人说要去乞讨来过好生活，或者为了满足自己的某些物质生活。我可以自己活的没尊严，但是不愿意我心里的你们活的比我难堪。倘若生活中的你们因为遇到我而变得如此艰辛，我愿意远离你们，我愿承担所有的不幸，只想你们能活的很快乐。 假如生活是一场旅行，我愿意做那个留下的人，当我们不足以两个人一起上路的时候，我会囊倾所有，祝你一臂之力。所以这次小长假里，我写代码累了，或者我睡前翻朋友圈，能看到照片中你们的笑脸，我想我做出的这些努力，总是能过自己这一关的。这世上最难尽之事不就是让自己想通么？ 我做的事情不完美，但是我只做我能力范围内能做到的足够的完美，这是我跟你们相处，跟家人相爱，所能做的最大的事。所以如果你让我连聚精会神专注做事最后这点仅有的快乐你都不允许的话，那我怎么面对生活如此艰辛？怎么麻痹自己？怎么让自己觉得还有希望？难道要让我苟且的做事，蝼蚁一样的生活？抱歉，我真的做不到了。我想这无论是我用来麻痹自己，还是我想难变中寻求突变，唯一可以让自己还能仅仅感觉到的甜头和动力。 大学四年打了快上万盘的dota，放了整整一年多没玩，2016年年初我跟自己说：等你闲下来，你要趁自己年轻，还有心思，去参加一次线下活动，上海一年一度的亚洲邀请赛就在你眼前。就需要一次，带上你的朋友一起，和那些年一起玩游戏的小伙伴一起。4月1日开始的线下8强亚洲邀请赛又在上海举办了。而这次一如既往的没时间了。想想还是算了，要回去看看父母了，还有代码没写完。 我想这些年我都没参与过那些大型歌舞演唱会和线下大型比赛，也不知道面对人山人海两兄弟，我会做出怎样恰当的表情。我好佩服老甲，在很忙的时候也有勇气拿起吉他玩起来。 2015年国庆的时候跟自己说2016年的国庆要去一次西藏，每次把手机备忘录打开，还能看到那条没做的愿望我就好难过，我向生活妥协了，我是个没原则的人。后来受不了自己，偷偷又把那条备忘录删掉了。 我想这些年我都没有做过什么也不干，就单独背个包去走一走，浪一浪，和陌生人坐在一个桌子上吃顿饭，在旅途中给老大爷散根烟，一起聊聊风俗乡土，一起聊聊流水光阴里别人奋斗的故事。 唉。 所以别管以后将如何，冷暖自愿尝透。 今天又是愚人节，但是我说的话又有多少是真的呢，对自己说的都是假的，对你而言都是真的。 你们明日，若是去了远方，踏上火车，望住窗外，飞越过几十个小镇，几千里土地，几千万个人。你不要怀疑，你的一生里，唯一可以相遇的机会，不在目的地，而在起点，那个愿意等你人往往是心甘情愿送你走的人。 别管以后将如何结束 至少我们曾经相聚过 却也等候只因你 冷暖自愿尝透","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"JavaScript05","date":"2017-03-03T04:05:27.000Z","path":"2017/03/03/JavaScript05/","text":"HTML DOM （文档对象模型） 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 从目前我了解的情况来看，JS可以做到以下几点： 1.JavaScript 能够改变页面中的所有 HTML 元素 2.JavaScript 能够改变页面中的所有 HTML 属性 3.JavaScript 能够改变页面中的所有 CSS 样式 4.JavaScript 能够对页面中的所有事件做出反应 对于JavaScript而言，更加关心的是如何找到 HTML 元素，要是找不到 HTML 元素的话，就没法实施操作，而JS中给我们提供了三种方法去找HTML 元素： 1.通过 id 找到 HTML 元素 2.通过标签名找到 HTML 元素 3.通过类名找到 HTML 元素 ①通过 id 查找 HTML 元素 例:查找id为”intro”的元素 var x = document.getElementById(&quot;intro&quot;); ②通过标签名查找 HTML 元素 例:查找 id=”main” 的元素，然后查找 “main” 中的所有 元素 var x = document.getElementById(&quot;main&quot;); var y = x.getElementsByTagName(&quot;p&quot;); ③通过类名查找 HTML 元素在 IE 5,6,7,8 中无效。 在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。但是不要在文档加载之后使用 document.write()。这会覆盖该文档。 改变 HTML 内容: 修改 HTML 内容的最简单的方法时使用 innerHTML 属性。如需改变 HTML 元素的内容，怎么用下面的语句： document.getElementById(id).innerHTML = new HTML","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript HTML DOM","slug":"JavaScript-HTML-DOM","permalink":"http://yoursite.com/tags/JavaScript-HTML-DOM/"},{"name":"JavaScript HTML","slug":"JavaScript-HTML","permalink":"http://yoursite.com/tags/JavaScript-HTML/"}]},{"title":"JavaScript04","date":"2017-03-03T02:53:36.000Z","path":"2017/03/03/JavaScript04/","text":"JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。 常见的 JavaScript 验证的这些典型的表单数据有： 用户是否已填写表单中的必填项目？ 用户输入的邮件地址是否合法？ 用户是否在数据域 (numeric field) 中输入了文本？ function validate_required(field,alerttxt) { with (field) { if (value == null || value == &quot;&quot;) { alert(alerttxt); return false; } else { return true; } } } 有个经典的关于邮箱地址的验证： function validate_email(field,alerttxt) { with (field) { apos = value.indexOf(&quot;@&quot;) dotpos = value.lastIndexOf(&quot;.&quot;) if (apos&lt;1||dotpos-apos&lt;2) { alert(alerttxt); return false; } else { return true; } } } 一开始对上面的函数并不陌生，但是仔细一瞅发现中间多了一个 with（field） 查阅资料看了一下JS中的with语句的用法： with语句为一个或一组语句指定默认对象。 with语句可以方便地用来引用某个特定对象中已有的属性，不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。 with的语句结构： with(object instance) { //代码块 } 对比下面二段代码会发现功能是一样的，但是明显有with语句的代码可读性更强，并且易于理解。 x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10); y = Math.tan(14 * Math.E); with (Math) { x = cos(3 * PI) + sin(LN10); y = tan(14 * E); } PS：但是with语句即使带来了很多方便的地方，它也有不好的之处：with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。 除了with有引用对象的作用，在JS中另一个this语句也很常见。 this 对象 是返回“当前”对象。在不同的地方，this代表不同的对象。如果在 JavaScript 的“主程序”中（不在任何 function 中，不在任何事件处理程序中）使用 this，它就代表 window 对象；如果在 with 语句块中使用 this，它就代表 with 所指定的对象；如果在事件处理程序中使用 this，它就代表发生事件的对象。 this的这个浅层意思和OC语言中的self很类似。当然这里仅仅只是用于类比理解。 下面有个this常见的用法，用于立刻检测表单输入的有效性。 &lt;script&gt; ... function check(formObj) { ... } ... &lt;/script&gt; &lt;body ...&gt; ... &lt;form ...&gt; ... &lt;input type=&quot;text&quot; ... onchange=&quot;check(this.form)&quot;&gt; ... &lt;/form&gt; ... &lt;/body&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 表单验证","slug":"JavaScript-表单验证","permalink":"http://yoursite.com/tags/JavaScript-表单验证/"},{"name":"JavaScript with语句","slug":"JavaScript-with语句","permalink":"http://yoursite.com/tags/JavaScript-with语句/"},{"name":"JavaScript this语句","slug":"JavaScript-this语句","permalink":"http://yoursite.com/tags/JavaScript-this语句/"}]},{"title":"JavaScript03","date":"2017-03-02T09:04:23.000Z","path":"2017/03/02/JavaScript03/","text":"JavaScript的 try/catch/throw 语句的用法: 做iOS开发的时候，调试的时候也会用到这些内容，由于之前开发用这些比较少，所以先来重温一下OC的相关语句，大同小异。 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 在OC中，经常用到下面的代码块来捕捉异常 @try { // 可能会出现崩溃的代码 } @catch (NSException *exception) { // 捕获到的异常exception } @finally { // 结果处理 } 下面有个比较详细的OC调试的过程的代码： @try { // 1 [self tryTwo]; } @catch (NSException *exception) { // 2 NSLog(@&quot;%s\\n%@&quot;, __FUNCTION__, exception); // @throw exception; // 这里不能再抛异常 } @finally { // 3 NSLog(@&quot;我一定会执行&quot;); } // 4 // 这里一定会执行 NSLog(@&quot;try&quot;); - (void)tryTwo { @try { // 5 NSString *str = @&quot;abc&quot;; [str substringFromIndex:111]; // 程序到这里会崩 } @catch (NSException *exception) { // 6 // @throw exception; // 抛出异常，即由上一级处理 // 7 NSLog(@&quot;%s\\n%@&quot;, __FUNCTION__, exception); } @finally { // 8 NSLog(@&quot;tryTwo - 我一定会执行&quot;); } // 9 // 如果抛出异常，那么这段代码则不会执行 NSLog(@&quot;如果这里抛出异常，那么这段代码则不会执行&quot;); } 如果6抛出异常，那么执行顺序为：1-&gt;5-&gt;6-&gt;8-&gt;3-&gt;4 如果6没抛出异常，那么执行顺序为：1-&gt;5-&gt;7-&gt;8-&gt;9-&gt;3-&gt;4 Objective-C将可能出现异常的代码放在@try块中，所有的异常处理逻辑放在@catch块中，最后用@finally块来回收资源。 @作为OC语言最大的标志之一，所以相对于JavaScript来说的话，以上的三个语句的用法其实和OC基本一致，仅仅只是格式和书写上的差别。 try { //在这里运行代码 } catch(err) { //在这里处理错误 } throw 语句允许创建自定义错误。 语句如下： throw exception 对于JavaScript的异常可以是：JavaScript 的 字符串、数字、逻辑值或对象。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript try语句","slug":"JavaScript-try语句","permalink":"http://yoursite.com/tags/JavaScript-try语句/"},{"name":"JavaScript catch语句","slug":"JavaScript-catch语句","permalink":"http://yoursite.com/tags/JavaScript-catch语句/"},{"name":"JavaScript throw语句","slug":"JavaScript-throw语句","permalink":"http://yoursite.com/tags/JavaScript-throw语句/"}]},{"title":"JavaScript02","date":"2017-03-02T05:33:19.000Z","path":"2017/03/02/JavaScript02/","text":"1、JavaScript关于对象的理解 关于JavaScript的对象性有很多种不同的说话，部分说法是JavaScript是面向对象的语言，还有一部的说法是JavaScript不是面向对象的语言，而是基于对象的语言。面向对象是object-oriented，基于对象是Object-Based，二者有着本质上的差别。但是大部分人认同JavaScript语言是基于对象的（Object-Based），而不是面向对象的（object-oriented）。之所以说它是一门基于对象的语言，主要是因为它没有提供象抽象、继承、重载等有关面向对象语言的许多功能。而是把其它语言所创建的复杂对象统一起来，从而形成一个非常强大的对象系统。虽然JavaScript语言是一门基于对象的，但它还是具有一些面向对象的基本特征。它可以根据需要创建自己的对象，从而进一步扩大JavaScript的应用范围，增强编写功能强大的Web文档。 从上面分析的情况来看，无论是基于对象还是面向对象，对于JavaScript的对象的研究，还是重中之重的一点。 JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。在 JavaScript 中，对象是拥有属性和方法的数据。 例如：现在有一个人对象 var person; person = new Object(); 属性: person.name = &quot;YanCey&quot;; person.age = 25; person.weight = 87; 方法: person.eat() person.run() person.sleep() 2、JavaScript的函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数在多数语言中被理解为函数或方法,所以JavaScript的函数概念和其他语言是类似的。 因为每种语言的格式书写差异很大，所以对于JavaScript函数的格式，要注意它有如下基本的格式： function functionname() { //这里是要执行的代码 } 前面使用了关键词 function PS:JavaScript 对大小写是敏感的。规定关键词 function 必须是小写，并且必须以与函数名称相同的大小写来调用函数。 当我们想调用一个函数需要带参数的时候，在（）内增加参数即可，如下： function myFunction(var1, var2) { //这里是要执行的代码 } 有时，我们会希望函数将值返回调用它的地方。通过使用 return 语句就可以实现。在使用 return 语句时，函数会停止执行，并返回指定的值。 function myFunction() { var x=5; return x; } 有时候，想要返回值是基于传递到函数中的参数： function myFunction(a, b) { return a * b; } 从以上的四种情况来看，JavaScript的函数的特性和C语言函数的情况相类似：无参无返，有参无返，无参有返，有参有返四种大的类型。但是必须要有关键词小写的 function 来修饰函数。 PS：了解完JavaScript的函数之后，避免不了的需要知道和函数有关的全局变量以及局部变量。在JS中对于全局变量和局部变量JS的规定和C语言又不谋而合的类似。 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。 您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。 只要函数运行完毕，本地变量就会被删除。 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。 如果把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。 personName = &quot;YanCeyMichael&quot;; 即使该变量是在函数内执行，也是全局变量。 3、JavaScript的运算符JavaScript的算术运算符和赋值运算符和C以及OC或者其他语言是基本类似的，这里不再赘述。 JavaScript有自己特殊功能的运算符： 用于字符串的”+”运算符: “+” 运算符用于把文本值或字符串变量加起来（连接起来) var txt1 = &quot;What a very&quot;; var txt2 = &quot;nice day&quot;; var txt3 = txt1 + txt2; txt3打印的显示结果就是: What a verynice day 据我了解: Java和.net以及Python都支持 + 来做字符串的拼接。 txt1=&quot;What a very&quot;; txt2=&quot;nice day&quot;; txt3=txt1+&quot; &quot;+txt2; 和下面的把空格放到txt1尾巴或者txt2的开头的作用是一样的。 txt1 = &quot;What a very &quot;; txt2 = &quot;nice day&quot;; txt3 = txt1 + txt2; 有时候对字符串和数字进行加法运算 x = 5 + 5; document.write(x); x = &quot;5&quot; + &quot;5&quot;; document.write(x); x = 5 + &quot;5&quot;; document.write(x); x = &quot;5&quot; + 5; document.write(x); 如果把数字与字符串相加，结果将成为字符串。 JavaScript的比较运算符和逻辑运算符以及条件运算符和C以及OC还有其他语言的语法是基本类似的,这里不再赘述。 4、JavaScript的判断语句JavaScript的判断语句和其他语言的判断语句基本一致，这里不再赘述（if语句/if-else语句/if-elseif-…-else语句/switch语句）。 5、JavaScript的for循环while循环以及break语句和continue语句这些语句和C语言或OC以及其他语言类似，这里不再赘述。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 对象","slug":"JavaScript-对象","permalink":"http://yoursite.com/tags/JavaScript-对象/"},{"name":"JavaScript 函数","slug":"JavaScript-函数","permalink":"http://yoursite.com/tags/JavaScript-函数/"},{"name":"JavaScript 运算符","slug":"JavaScript-运算符","permalink":"http://yoursite.com/tags/JavaScript-运算符/"},{"name":"JavaScript 判断语句","slug":"JavaScript-判断语句","permalink":"http://yoursite.com/tags/JavaScript-判断语句/"},{"name":"JavaScript 循环语句","slug":"JavaScript-循环语句","permalink":"http://yoursite.com/tags/JavaScript-循环语句/"}]},{"title":"JavaScript01","date":"2017-03-02T04:09:30.000Z","path":"2017/03/02/JavaScript01/","text":"JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。 1、JavaScript的输出： 假如需从JavaScript访问某个HTML元素，可以使用document.getElementById(id) 方法。使用 “id” 属性来标识 HTML 元素： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;My First Web Page&lt;/h1&gt; &lt;p id = &quot;demo&quot;&gt;My First Paragraph&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JavaScript 由 web 浏览器来执行。在这种情况下，浏览器将访问 id=”demo” 的 HTML 元素，并把它的内容（innerHTML）替换为 “My First JavaScript”。 使用 document.write() 仅仅向文档输出写内容。如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 2、JavaScript的语句：语句； 例如这样的代码块： &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;hello!&quot;); &lt;/script&gt; 其中的： alert(&quot;hello!&quot;); 就是就是一个JavaScript语句。 一行的结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束。 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;I&quot;); document.write(&quot;love&quot;); document.write(&quot;you&quot;); &lt;/script&gt; 像这个代码块，就有三条语句，每句结束后都有”;”，需要强调的是这三条语句是按顺序执行的。 和其他的基本语言一样，语句的末尾的逗号是英文状态下的逗号。注意: “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。 3、JavaScript的注释：和很多其他语言注释方法是一样的，在此不在赘述。 4、JavaScript的变量：定义JavaScript的变量用到关键词var，语法如下： var 变量名 JavaScript的变量名的命名规则如下: 1.变量必须使用字母、下划线(_)或者美元符($)开始。 2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 3.不能使用JavaScript关键词与JavaScript保留字。 1）JavaScript的变量要先声明再赋值； 2）JavaScript的变量可以重复赋值； PS： 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。 5、JavaScript的数据类型：字符串、数字、布尔、数组、对象、Null、Undefined ①.字符串: 字符串是存储字符（比如 “YanCey Michael”）的变量。 字符串可以是引号中的任意文本。可以使用单引号或双引号： var myName = &quot;YanCey Michael&quot;; var myName = &apos;YanCey Michael&apos;; 二者等价。 也可以在字符串中使用引号，只要不匹配包围字符串的引号即可： var answer = &quot;Nice to meet you!&quot;; var answer = &quot;He is called &apos;Bill&apos;&quot;; var answer = &apos;He is called &quot;Bill&quot;&apos;; ②.数字： JavaScript 只有一种数字类型。数字可以带小数点，也可以不带： var x1 = 34.00; //使用小数点来写 var x2 = 34; //不使用小数点来写 var y = 123e5; // 12300000 var z = 123e-5; // 0.00123 ③.布尔： 布尔（逻辑）只能有两个值：true 或 false。 var x = true var y = false ④.数组： 下面的代码创建名为 students 的数组： var students = new Array(); students[0] = &quot;Michael&quot;; students[1] = &quot;Jane&quot;; students[2] = &quot;Maria&quot;; 或者 (condensed array): var students = new Array(&quot;Michael&quot;,&quot;Jane&quot;,&quot;Maria&quot;); 或者 (literal array): var students = [&quot;Michael&quot;,&quot;Jane&quot;,&quot;Maria&quot;]; ⑤.对象： 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person = {firstname:&quot;YanCey&quot;, lastname:&quot;Michael&quot;, id:1208}; PS：JS中的对象有点类似于OC中的字典。当然这里已经不能说就是字典了，只是个人作为一个iOS的软件工程师，我用来对比记忆。 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 当然有时候为了美观好看，也可以这样做书写格式的空格和转行 var person = { firstname: &quot;YanCey&quot;, lastname : &quot;Michael&quot;, id : 1208 }; 对象属性有两种寻址方式： var name = person.lastname; var name = person[&quot;lastname&quot;]; ⑥.Undefined 和 Null Undefined 这个值表示变量不含有值。 可以通过将变量的值设置为 null 来清空变量。 var person; person = null; 6、对于JavaScript的变量声明变量类型注意：声明新变量时，可以使用关键词 “new” 来声明其类型： var carname = new String; var x = new Number; var y = new Boolean; var cars = new Array; var person = new Object; JavaScript的变量均为对象。当声明一个变量时，就创建了一个新的对象。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 输出","slug":"JavaScript-输出","permalink":"http://yoursite.com/tags/JavaScript-输出/"},{"name":"JavaScript 语句","slug":"JavaScript-语句","permalink":"http://yoursite.com/tags/JavaScript-语句/"},{"name":"JavaScript 注释","slug":"JavaScript-注释","permalink":"http://yoursite.com/tags/JavaScript-注释/"},{"name":"JavaScript 变量","slug":"JavaScript-变量","permalink":"http://yoursite.com/tags/JavaScript-变量/"},{"name":"JavaScript 数据类型","slug":"JavaScript-数据类型","permalink":"http://yoursite.com/tags/JavaScript-数据类型/"},{"name":"JavaScript 声明变量类型","slug":"JavaScript-声明变量类型","permalink":"http://yoursite.com/tags/JavaScript-声明变量类型/"}]},{"title":"给blog添加一个相册，先把JS干掉","date":"2017-03-02T03:18:18.000Z","path":"2017/03/02/给blog添加一个相册，先把JS干掉/","text":"废话写在前面：这个博客没有相册，这会儿刚好不是特别的忙，所以也有点精力来整理一下blog。音乐播放器加了，还差一个相册。为了整个相册出来，我还是要摸一下前端的内容的，也许方向不是特别的对，但是还是先从JS入手吧。 我对JS不是特别了解的，在iOS这边原生的框架开发做的时间用不了多久，就会遇到JS的交互问题，在iOS这边有个UI控件叫UIWebView，它是专门用来承载html内容的一个控件（通俗的来说：这个控件是用来加载网页的）。只有简单的代理方法，所以很多时候，iOS这边想要和web前端做一些交互的时候，难免要用到JS。 JS简介： JS即JavaScript，一般这么解释它：JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 目前所有主流浏览器都支持JavaScript，并且很多的网站的网页都用JavaScript来做一些动态功能，当然还可以用其他的脚本语言来丰富网页的动态效果也不仅仅就是JavaScript。 那么这个开篇的JavaScript的内容就简单介绍一些基本的关于JavaScript的基本概念。 从JavaScript的基本概念介绍看来JavaScript这门语言可用于HTML和Web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。所以它的代码怎么书写，怎么使用，怎么调用等问题是我所关心的。 JavaScript是可插入HTML页面的编程代码。 Q1:怎么在HTML文件内容中写JS代码？ &lt;script&gt;&lt;/script&gt; 使用标签在HTML网页中插入JavaScript代码，这种标签和H5的其他标签一样都是成对存在，JavaScript代码是写在标签中间的。 有时会遇到这样的一对标签 &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 这是表示这对标签之间的内容是文本类型(text)，javascript是为了告诉浏览器里面的文本是属于JavaScript语言。 Q2:JS代码只能写在HTML文件中吗？ 在很多复杂的项目中，一般会遇到把JS的内容单独抽离出来，并不写在HTML的文件中。把HTML文件和JS代码分开，并单独创建一个JavaScript文件(简称JS文件)，其文件后缀通常为.js，然后将JS代码直接写在JS文件中。这样也是可以的。 PS:1）在JS文件中， &lt;script&gt;&lt;/script&gt; 像这样的成对的标签就不再需要了，而是直接在JS文件中编写JavaScript代码就可以了。 2）但是新的问题又出现了，以上抽离部分的JS代码的JS文件并不能直接被运行，它需嵌入到HTML文件中执行，所以需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 相当于告诉浏览器，当你执行到这里的时候，就要去JS文件跑JS代码了。 Q3:JS代码在文件中的位置在哪里？ 我们可以将JavaScript代码放在html文件中任何位置，但是一般放在网页的head或者body部分。 1）放在head部分： 最常用的方式是在页面中head部分放置script元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。 2）放在body部分： JavaScript代码在网页读取到该语句的时候就会执行。 PS: JavaScript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。如下图：","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 简介","slug":"JavaScript-简介","permalink":"http://yoursite.com/tags/JavaScript-简介/"},{"name":"JavaScript 基本概念","slug":"JavaScript-基本概念","permalink":"http://yoursite.com/tags/JavaScript-基本概念/"}]},{"title":"阳光正好","date":"2017-02-27T04:48:55.000Z","path":"2017/02/27/阳光正好/","text":"我回来了，比自己想象中的要快好多。离职，收拾行李，落脚合肥。前后只用了2天时间。雾总二天前给我电话说我走的好快啊，一不留神就走了。仓促，慌张。 回来的第二天上午又去面试了一个创业团队，产品跟我说：我们的iOS为了女朋友去上海了，所以缺个人。一个萝卜一个坑这种说法在某种意义上是成立的。和他聊的比较投缘。一个挺有想法的同龄人。 我放弃了那个目前在合肥算高薪的offer，我跟那边的老板说：倘若最终没来你这边，不是薪资的问题，只是单纯的不适合。一晃从我离开合肥庐江，到现如今我回到合肥生活，前前后后有快6年的时间了。6年里我做了很多的选择，每次都考虑的比这次要久。可是适合自己的抉择并不多。 有时候能做到适合自己好难。 一直追随的都是当下的最好也许并不是一件坏事，但是不见得能让自己快乐。之前我问过我自己眼下这几年我需要什么：稳定，安静，舒适，积淀。我从没有像现在这样渴望这些东西。 昨天花了3个小时找到了房子。今天上午把行李拎过来，把地板拖干净之后去天台看了一下，视野挺开阔。整个空的屋子，有点破旧的卫生间好像和这个像模像样的小区有点冲突。我觉得住的地方凑合着就可以了。况且像今天的日子，有这么好的阳光，大抵已经满足了我。 礼拜六晚因吃饭比较晚，错过了南峰子的MVCS框架以及数据通信层梳理的直播，可能要再抽个时间好好的整理一下。我从知乎上翻到了他的技术博客地址：南峰子的技术博客。知乎上他的最后的活跃状态还是三年前的答案。我有时候好想知道这些技术大牛到底都是在干嘛。 用MacDown写东西更新的频次要是不高的话，下次再想写点东西的时候，都好碍事，很多标签语法不记得，还要重头翻过。更新博客遇到心情差的时候就觉得好累，因为你有很多想写的都被这些东西挡着。 即便诸多不便，可是内心对干净的地儿的诉求一直欲求不满。觉得有一块地儿自己耕种的感觉挺好的，比微博空间写东西要好的多，微信挺棒的，但是里面发长内容好麻烦，可我又偏偏是一个不喜欢发碎片的怪胎，往往丢一个链接要让我省很多事儿。讲真，七牛云做博客的图床加载速度真是快的让我惊叹。 日头和阳光挺好的，想出去跑跑步了。离上次开始想跑步日子已经过去差不多一年了，这一年一直在路上，现在我换了一个地方继续跑。 老友们：平时不忙的时候，可以约一发哟～","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器","date":"2017-02-22T08:13:47.000Z","path":"2017/02/22/基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器/","text":"有时候偶尔写东西的时候少音乐挺没劲的。 音乐也是有毒，难以让人专注去做好一件事。 我不知道我添加一个音乐播放器的意义是什么。 纠结那么多好像也没那么多的意义。 所以不管了，文章都开了，还是个音乐播放器吧。 别问我为啥不给移动端加一个，就是不加。 准备工作：一个网易云音乐账号 + 一个网易云音乐歌单 这个音乐播放器是在网易云音乐官网的个人主页里的任意一个歌单中，通过歌单的 生成外链播放器 来生成的一个 iframe 插件。 将原生的代码段： &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=0&amp;id=609175973&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 粘贴到themes/yilia/layout/_partial/left-col.ejs文件的第二行，并作如下的修改之后，将和我现在的博客的音乐布局是一样的。修改一下： &lt;iframe style=&quot;position:absolute;top: 0px;z-index: 100;&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=0&amp;id=609175973&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 添加的部分是设置播放器的相对位置布局，也是很简单的代码就能搞定。 为了适配屏幕把原来的固定width修改成100%。 当然你可以通过检测博客的网页，通过浏览器的布局个人喜欢的位置。","categories":[],"tags":[{"name":"Hexo+Yilia","slug":"Hexo-Yilia","permalink":"http://yoursite.com/tags/Hexo-Yilia/"},{"name":"PC端","slug":"PC端","permalink":"http://yoursite.com/tags/PC端/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"http://yoursite.com/tags/音乐播放器/"}]},{"title":"OpenCV之CascadeClassifier(一)","date":"2017-02-20T06:23:58.000Z","path":"2017/02/20/OpenCV之CascadeClassifier(一)/","text":"","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV之Mat(一)","date":"2017-02-20T05:43:01.000Z","path":"2017/02/20/OpenCV之Mat(一)/","text":"废话内容，写在前面： Mat是个什么玩意? 2015年下半年我在深圳的时候，一边看C++的入门，一边敲一点点和工作有关的代码。有一天飞哥和勇哥终于按耐不住觉得我总是测试光学打光做电子元器件可能就真的要废了，便让我用Visual Studio把一张图片用窗口显示出来，然后对图片进行二值化处理，提取特征值。 我印象特别深刻，方法函数里面涉及到了好多Mat，如今开始动OpenCV第一个碰到的东西就是Mat，在这里把研读的关于Mat类，记录一下。 OpenCV官方文档是这样界定Mat的：基本的图像容器。 处理一张图片为何要用到图像的容器这种定义的概念？没有《图像处理技术》基础知识的人可能不太能懂图像为何需要一个基本的图像容器去处理。我本科学的《图像处理技术》的基础内容现在也不太记得，脑海中只有一些隐约的印象：图像是很多像素点构成，每个像素点有具体的像素值(0~255)，一张二维平面上的图片，它上面所有的点平面坐标位置，有点像《线性代数》里的矩阵，处理一张图片就是处理图片上所包含的像素值的信息，所以图片的处理，就可以转换成矩阵运算。 正如OpenCV官方文档上说到的：如何获取并存储这些像素值由我们的需求而定，最终在计算机世界里所有图像都可以简化为数值矩以及矩阵信息。作为一个计算机视觉库， OpenCV 其主要目的就是通过处理和操作这些信息，来获取更高级的信息。因此，OpenCV如何存储并操作图像是你首先要学习的。 Mat的发展情况： 在2001年刚刚出现的时候，OpenCV基于C语言接口而建。为了在内存（memory）中存放图像，当时采用名为IplImage的C语言结构体，时至今日这仍出现在大多数的旧版教程和教学材料。但这种方法必须接受C语言所有的不足，这其中最大的不足要数手动内存管理，其依据是用户要为开辟和销毁内存负责。虽然对于小型的程序来说手动管理内存不是问题，但一旦代码开始变得越来越庞大，你需要越来越多地纠缠于这个问题，而不是着力解决你的开发目标。 幸运的是，C++出现了，并且带来类的概念，这给用户带来另外一个选择：自动的内存管理（不严谨地说）。这是一个好消息，如果C++完全兼容C的话，这个变化不会带来兼容性问题。为此，OpenCV在2.0版本中引入了一个新的C++接口，利用自动内存管理给出了解决问题的新方法。使用这个方法，你不需要纠结在管理内存上，而且你的代码会变得简洁（少写多得）。但C++接口唯一的不足是当前许多嵌入式开发系统只支持C语言。所以，当目标不是这种开发平台时，没有必要使用旧方法（除非你是自找麻烦的受虐狂码农）。 关于 Mat ，首先要知道的是你不必再手动地（1）为其开辟空间（2）在不需要时立即将空间释放。但手动地做还是可以的：大多数OpenCV函数仍会手动地为输出数据开辟空间。当传递一个已经存在的 Mat 对象时，开辟好的矩阵空间会被重用。也就是说，我们每次都使用大小正好的内存来完成任务。 基本上讲 Mat 是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸，存储方法，存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建拷贝时，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是家常便饭。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，我们不应该拷贝 大 的图像，因为这会降低程序速度。 为了搞定这个问题，OpenCV使用引用计数机制。其思路是让每个 Mat 对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则 只拷贝信息头和矩阵指针 ，而不拷贝矩阵。 关于 Mat 内存管理的问题： 如果矩阵属于多个 Mat 对象，那么当不再需要它时谁来负责清理？简单的回答是：最后一个使用它的对象。通过引用计数机制来实现。无论什么时候有人拷贝了一个 Mat 对象的信息头，都会增加矩阵的引用次数；反之当一个头被释放之后，这个计数被减一；当计数值为零，矩阵会被清理。但某些时候你仍会想拷贝矩阵本身(不只是信息头和矩阵指针)，这时可以使用函数 clone() 或者 copyTo() 。 1.OpenCV函数中输出图像的内存分配是自动完成的（如果不特别指定的话）。 2.使用OpenCV的C++接口时不需要考虑内存释放问题。 3.赋值运算符和拷贝构造函数（ ctor ）只拷贝信息头。 4.使用函数 clone() 或者 copyTo() 来拷贝一副图像的矩阵。 以上是对图像以及 Mat类发展，以及OpenCV在处理图像时的内存管理的一个简单的了解。 接下来要了解一下OpenCV是如何存储图像的： 这里讲述如何存储像素值。需要指定颜色空间和数据类型。颜色空间是指对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间，只处理黑色和白色，对它们进行组合可以产生不同程度的灰色。 对于 彩色 方式则有更多种类的颜色空间，但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。RGB颜色空间是最常用的一种颜色空间，这归功于它也是人眼内部构成颜色的方式。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素 alpha (A)。 有很多的颜色系统，各有自身优势： 1.RGB是最常见的，这是因为人眼采用相似的工作机制，它也被显示设备所采用。 2.HSV和HLS把颜色分解成色调、饱和度和亮度/明度。这是描述颜色更自然的方式，比如可以通过抛弃最后一个元素，使算法对输入图像的光照条件不敏感。 3.YCrCb在JPEG图像格式中广泛使用。 4.CIE L a b *是一种在感知上均匀的颜色空间，它适合用来度量两个颜色之间的距离。 每个组成元素都有其自己的定义域，取决于其数据类型。如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ，占一个字节或者8位，可以是有符号型（0到255之间）或无符号型（-127到+127之间）。尽管使用三个 char 型元素已经可以表示1600万种可能的颜色（使用RGB颜色空间），但若使用float（4字节，32位）或double（8字节，64位）则能给出更加精细的颜色分辨能力。但同时也要切记增加元素的尺寸也会增加了图像所占的内存空间。 关于Mat类的创建，具体的代码和内容可以查阅OpenCV中文网里的相关入门教学，当然还要具备一点点基础的C++入门知识。 待续以后会更新相关内容，等我把C++入门摸一下。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"人脸识别01","date":"2017-02-20T02:01:22.000Z","path":"2017/02/20/人脸识别01/","text":"废话内容，写在前面: 2016年上半年在上海面试的时候。徐汇区有一家做社交的互联网公司开始打算做人脸识别，由此我了解了深圳脸萌科技的FaceU这款超级激萌的App。很有意思的是徐汇区那家社交公司面试我的时候跟我说的很明确：你做一个类似FaceU的demo给我，我就给你发Offer。有时候我在想一份工作好简单啊，只要你会做人脸识别添加贴纸贴片，一碗饭就来了。 回去之后，我对比了iOS框架自带的人脸识别框架识别的精度不够高，侧脸极其难识别，我只好放弃转而奔向科大讯飞人脸识别的框架去做。 那一个礼拜的时间里，我看科大讯飞的人脸识别SDK和官方Demo，在做识别的过程中想加贴片装饰品的时候，遇到了二个代理方法的冲突，导致某个识别状态始终无法修改。所以那次的demo最终是没有做出来。 时隔快一年，我想人脸识别功能我该动一动了，恰好个人技术博客刚开张，也应该来一点技术干货。同时不一样的是，这次我也不打算用科大讯飞的框架，我想从OpenCV的开源库着手，多多少少还可以学点C++的函数也还不错。 由此我想把研究人脸识别的过程记录下来。所以这个系列是一个不懂C++的iOS开发小白的学习过程。 本系列文章，所有测试内容以及demo的环境如下： 1）Xcode Version 8.2.1 2）OpenCV for iOS 3.2.0 准备工作： 1）先去OpenCV官网下载最新的OpenCV For iOS的视觉库。 2）Xcode创建一个新的项目，把下载的OpenCV库导入工程，并在工程的Building phase里面添加 opencv2.framework。 如果对OpenCV有所了解的会知道，OpenCV的代码是基于C++编写的。因此，想要在Xcode项目中运行C++代码，你需要把文件名后缀名由.m改成.mm即可（当然最好把OpenCV的功能函数写一层OC的API封装，这样可能会比较安全，也会少很多不必要的错误麻烦，也更符合开发需求。）。 注意：OpenCV 声明了命名空间 cv，因此 OpenCV 的类的前面会有个 cv:: 前缀，就像 cv::Mat、 cv::Algorithm 等等。你也可以在 .mm 文件中使用 using namespace cv 来避免在一堆类名前使用 cv:: 前缀。 但是，在某些类名前你必须使用命名空间前缀，比如 cv::Rect 和 cv::Point，因为它们会跟定义在 MacTypes.h 中的 Rect 和 Point 相冲突。尽管这只是个人偏好问题，个人偏向在任何地方都使用 cv:: 以保持一致性。 C++ 命名空间namespace的作用和使用: 命名空间是ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。其作用就是规定该文件中使用的标准库函数都是在标准命名空间std中定义的。通常来说，在C++中，命名空间（namespace）的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个全局命名空间（global namespace），全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用::member的形式表示）。 在C语言中定义了3个层次的作用域，即文件(编译单元)、函数和复合语句。C++在C的基础上又引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。 在导入 opencv2.framework 之后，把你需要加入OpenCV代码的文件的.m文件后缀由.m改成.mm 引入头文件 #import &lt; opencv2/opencv.hpp&gt; #import &lt;opencv2/imgproc/types_c.h&gt; #import &lt;opencv2/imgcodecs/ios.h&gt; 编译运行。 PS:我编译的时候，有二个报错。经过查阅资料做了具体的修改调整之后可以正常运行，分别是OpenCV库的 blenders.hpp 文件 enum { NO, FEATHER, MULTI_BAND }; 修改成： enum { NO_EXPOSURE_COMPENSATOR, FEATHER, MULTI_BAND }; 和 exposure_compensate.hpp 文件 enum { NO, GAIN, GAIN_BLOCKS }; 修改成： enum { NO_EXPOSURE_COMPENSATOR, GAIN, GAIN_BLOCKS }; 先来试试OpenCV的入门内容，把一张彩色图片变成灰色的 在控制器的.mm文件中引入Mat类 @interface ViewController () { cv::Mat cvImage; } @end 关于Mat类:详见另一篇Blog：OpenCV之Mat(一) 图像处理的代码块如下： if(!cvImage.empty()){ cv::Mat gray; // 将图像转换为灰度显示 cv::cvtColor(cvImage,gray,CV_RGB2GRAY); // 应用高斯滤波器去除小的边缘 cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2); // 计算与画布边缘 cv::Mat edges; cv::Canny(gray, edges, 0, 50); // 使用白色填充 cvImage.setTo(cv::Scalar::all(225)); // 修改边缘颜色 cvImage.setTo(cv::Scalar(0,128,255,255),edges); // 将Mat转换为Xcode的UIImageView显示 self.testImgView1.image = MatToUIImage(cvImage); } 如果你和我一样运行Xcode之后能得到下图的处理后的照片内容的话，图像的灰度显示算是完成了。 也就是说OpenCV的第一个代码块已经完成了。 如果还有兴趣的话，可以接着玩玩—–人脸识别 现在在你的.mm控制器里引入CascadeClassifier类 @interface ViewController () { cv::CascadeClassifier faceDetector; } @end 关于CascadeClassifier类的调研:详见另一篇Blog：OpenCV之CascadeClassifier(一) 人脸识别核心代码如下: NSString *cascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt&quot; ofType:@&quot;xml&quot;]; faceDetector.load([cascadePath UTF8String]); cv::Mat faceImage; UIImageToMat(image, faceImage); // 转为灰度 cv::Mat gray; cvtColor(faceImage, gray, CV_BGR2GRAY); // 检测人脸并储存 std::vector&lt;cv::Rect&gt;faces; faceDetector.detectMultiScale(gray, faces,1.1,2,0|CV_HAAR_SCALE_IMAGE,cv::Size(30,30)); // 在每个人脸上画一个红色四方形 for(unsigned int i= 0;i &lt; faces.size();i++) { const cv::Rect&amp; face = faces[i]; cv::Point tl(face.x,face.y); cv::Point br = tl + cv::Point(face.width,face.height); // 四方形的画法 cv::Scalar magenta = cv::Scalar(255, 0, 255); cv::rectangle(faceImage, tl, br, magenta, 4, 8, 0); } self.testImgView2.image = MatToUIImage(faceImage); 补充:haarcascade_frontalface_alt.xml该文件是专门用来训练cv::CascadeClassifier函数的资源文件 为什么一定要添加xml文件呢？ 其实这个xml文件就是对人脸识别的初始化（初始化数据by Paul Viola and later extended by Rainer Lienhart），现在已经成为一种人脸识别的标准了。 为了能够把xml文件成功倒入，我们需要把NSString object 转化为 std::string（使用UTF8String） 经过以上的准备工作后我们就可以使用方法detectMultiScale进行人脸检测了。 方法detectMultiScale有四个参数。分别为： scaleFactor ：制定循环递减的图片尺寸 minNeighbors ：制定保留数据的矩形大小 CV_HAAR_SCALE_IMAGE ：这是一个标志，它指定算法缩放图像，而不是检测器。它有助于实现最佳的性能 minSize ：该参数指定最小可能的面部尺寸 如果可以得到下图(imageView重新布局了)，第三张图片里的每个人脸上都有正方形的框，表示已经找到了人脸位置。 到此时，静态图片的人脸识别算是初步完成。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"}]},{"title":"要尝试逃离上广深了么？","date":"2017-02-19T13:53:20.000Z","path":"2017/02/19/要尝试逃离上广深了么？/","text":"2017年2月19日了，这天比预期的时间晚来了30天，30天前我告诉自己，要弄一个个人站点，不管这个站点的Theme是从哪个大牛手里偷的，都要先用着。 本来在现有的Hexo成熟的框架条件下，个人博客最多20分钟就可以弄好，但是我却花了比我预期多的多的时间。这些事件都耗费在哪了？耗费在不够专注：上班修改优化项目零碎的时间里，Hexo安装错误，一波接着一波的安装卸载，GitHub Pages删了又重新添加，全是无用之功。 2月17日那天一天跑了四个面试，Cisco上海的技术面问了我很多基础的东西，26分钟后从大厦出来，从没有如此草率的面试，毫无准备，必然不会受到太高的待见。可是为啥我要把自己的实力不足归咎于准备不充分呢？没有什么台阶要给自己下的。自己的无能是原罪。下午在浦东张江高科，那个逆向开发公司的技术面和我聊了20多分钟，问我最近研究什么，问我最近开发上的难点有哪些，我一五一十的说着：搭建个人站点，研究夜间模式以及多主题设计思路和优化方案。后来问我：你会给iPhone越狱嘛？我说我没做过的时候他合起了他的Mac。我想这已经终结聊天了。我原本也是抱着试试的态度来的，iOS开发的汇编底层我知道暂时没那个能力去做，不被待见显而易见。但是这还是我第一次面试像别人展示自己的时候和别人想获取的信息完全不在同一个频道上，难免感到话题有点难聊，让我感觉空气里到处弥漫着尴尬。 46分钟之后我离开了那家逆向开发公司，打车去找老甲，我坐在老甲公司楼下的台阶上吹冷风，手机没电我打开Mac给它喂奶。我告诉自己都会好的，就像春天来了，柳絮会飘，秋天过来，柿子会熟。少年，你不能太着急的哟。我安慰自己，你可以的，这个世界本来就给你留好了位置，你还没遇到最好的自己。可是那天的风好大，吹的我鼻子好难受，鼻子好酸，眼角都湿得一直没干。自我安慰的那些屁话，肯定没有老甲带我去吃的那顿热气腾腾的麻辣烫管用。张江高科消费好贵啊，0.8公斤的料，48块钱，温饱了那天傍晚我饥饿的灵魂。 晚上回来之后想想，大概是太过于急功近利。技术需要沉淀的，一点点去学，代码要慢慢的打磨，一行行的敲。这个膨胀的社会却不给年轻人那么多时间去沉淀，膨胀的自己也不给自己那么多机会去尝试。 2016年的每一天我都掰开着用，这一年我都没时间去做噩梦，忙得让我很少在半夜里会醒来，往往都是半夜才睡。那个时候我告诉自己，你要努力，你现在多累些，当下就少求别人一点。下半年项目加班加点，干过40多个小时没合眼，我也不曾抱怨，因为毕竟自己菜，只能用时间来弥补，我把别人喝咖啡的时候都用来写项目了。我庆幸我足够的年轻，年轻到身体严重负荷的时候，仅仅只是胸口有点痛而已。一觉醒来，代码还可以撸的飞起。 TinyTian说代码是我大老婆，她是小三，满是哀怨的时候我只能咧开嘴笑，的确我欠她太多的时间。有时候我在想，幸福的日子就是有一个人成了你这一生唯一的软肋，遇事再也不莽撞，即使丢掉激情你也不会觉得后悔。好寡淡的时光啊，可就是这么心安理得的欢喜。 有时候很多事情来的莫名其妙，中午在地铁上打瞌睡打盹点开Boss聊了一个，后来才知道那是合肥的一家美容公司。紧接着下午就视讯通话面试过了，傍晚给我发了Offer，在合肥，试用期税前9K，转正11K。可是我不知道为啥高兴不起来呢，是我过于贪恋一线城市夜晚的霓虹灯么？总是在心里告诉自己一线城市机会多，技术提升快？可是迟早终究要回到那个城市的，为何不早做打算，非要漫无目的的幻想么？ 现在这个机会就摆在我的面前了，我却踌躇满志，迈不开步子。可这又算什么呢？反正我的时间又不值钱，可以大把的浪费大把的挥霍。 年轻就是这样的吧，都不确定，都在准备呢。试试又不是一个坏事。 何况又不是最惨的时候。 毕竟还有那么多希望。","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]}]