[{"title":"C语言 malloc 和 free","date":"2018-02-03T07:01:44.000Z","path":"2018/02/03/C语言-malloc-和-free/","text":"","raw":"---\ntitle: C语言 malloc 和 free\ndate: 2018-02-03 15:01:44\ntags:\n---\n","updated":"2018-02-03T07:01:44.168Z","permalink":"http://yoursite.com/2018/02/03/C语言-malloc-和-free/","categories":[],"tags":[]},{"title":"iOS自动布局高级用法以及代码约束小纪","date":"2018-02-03T03:48:05.000Z","path":"2018/02/03/iOS自动布局高级用法以及代码约束小纪/","text":"","raw":"---\ntitle: iOS自动布局高级用法以及代码约束小纪\ndate: 2018-02-03 11:48:05\ncategories:\ntoc: false\ntags:\n     - autolayout\n     - autoresizing\n---\n\n\n\n\n","updated":"2018-02-03T06:50:15.383Z","permalink":"http://yoursite.com/2018/02/03/iOS自动布局高级用法以及代码约束小纪/","categories":[],"tags":[{"name":"autolayout","slug":"autolayout","permalink":"http://yoursite.com/tags/autolayout/"},{"name":"autoresizing","slug":"autoresizing","permalink":"http://yoursite.com/tags/autoresizing/"}]},{"title":"关于运行时的损耗和内存管理在几种语言中的差异小记","date":"2018-01-31T04:33:03.000Z","path":"2018/01/31/关于运行时的损耗和内存管理在几种语言中的差异小纪/","text":"OC 和 Swift 运行时的损耗主要来自于内存管理中对对象的计数,一个对象会不停地进行 retain 和 release, runtime 必须一直 observe 每一个对象的 retain count,当 retain count 达到 0 的时候就释放这个对象.而 C 就没有这个问题,因为 C 没有对象,不需要对对象进行生命周期的内存维护,没有运行时的损耗. 目前主流的内存管理方式分三种: 手动: C 语言的 malloc 库,特点就是无运行时损耗,但不好控制释放内存的时机. 半自动: Objective-C 和 Swift 的 MRC/ARC,有运行时损耗,但基本上可以让程序员不用去考虑内存管理的问题. 自动的: Java/Go 的 GC.基本上同上,但需要在某个时间点去停止所有线程,释放内存的时机不可控. Objective-C 的 MRC 还需要手动去写 retain/release,在进化到 ARC 之后,除了需要在类成员变量声明的时候,显式地声明是 weak/strong/retain/copy 就可以了, retain/release 的插入交给编译器即可, ARC 其实已经是实际上的自动化内存管理模式了. 而 Swift 在把指针抽象为引用类型,加入 Mutable/Immutable 的概念之后,就只需要偶尔写写 weak 就行了,唯一需要对于内存管理费心的就是 retain cycle 的问题,但也比之前省心很多了.而且随着 Swift 工具链的发展,这些问题都可以在编译期或者 Debug 时就暴露出来. 半自动的内存管理,实际上还有一种,就是 Rust 的 OwnerShip ,这种方式其实是 MRC/ARC 的一种延续,但 MRC/ARC 内存释放的时机还是需要在运行时才能知道,而 Rust 可以在编译期就解析出什么时候可以释放掉内存,从而省略掉 retain/release 的存在,也没必要专门跑一个 runtime 去监测对象的引用计数.从而达到比 ARC 更高的运行效率.仔细思考一下这种自动化的内存管理模式,其实都是在把指针分类,加上 context(上下文),抽象出来,暴露给编译器更多与关于指针的信息,而不是单纯的一个内存地址,从而让编译器可以分析释放对象的时机. Rust 也不例外,既然要达到比 ARC 更高的运行效率,那就必然要提供给编译器更多的指针信息,以此提供给编译器更多的优化空间,因此在指针声明和传递时都需要显式地声明所有权,代码量也会相应地增多,对于程序员的要求也会更高. 虽然写起来比 ARC 更麻烦一点,但也比 C 那种原始的方式简单很多,提供给了 Rust, Swift 这些”现代编程语言”编写底层程序的可能性.","raw":"---\ntitle: 关于运行时的损耗和内存管理在几种语言中的差异小记\ndate: 2018-01-31 12:33:03\ncategories:\ntoc: false\ntags:\n     - 内存管理\n---\n\nOC 和 Swift 运行时的损耗主要来自于内存管理中对对象的计数,一个对象会不停地进行 retain 和 release, runtime 必须一直 observe 每一个对象的 retain count,当 retain count 达到 0 的时候就释放这个对象.而 C 就没有这个问题,因为 C 没有对象,不需要对对象进行生命周期的内存维护,没有运行时的损耗.\n\n目前主流的内存管理方式分三种:\n\n手动: C 语言的 malloc 库,特点就是无运行时损耗,但不好控制释放内存的时机.\n[]()\n\n半自动: Objective-C 和 Swift 的 MRC/ARC,有运行时损耗,但基本上可以让程序员不用去考虑内存管理的问题.\n\n自动的: Java/Go 的 GC.基本上同上,但需要在某个时间点去停止所有线程,释放内存的时机不可控.\n\nObjective-C 的 MRC 还需要手动去写 retain/release,在进化到 ARC 之后,除了需要在类成员变量声明的时候,显式地声明是 weak/strong/retain/copy 就可以了, retain/release 的插入交给编译器即可, ARC 其实已经是实际上的自动化内存管理模式了.\n\n而 Swift 在把指针抽象为引用类型,加入 Mutable/Immutable 的概念之后,就只需要偶尔写写 weak 就行了,唯一需要对于内存管理费心的就是 retain cycle 的问题,但也比之前省心很多了.而且随着 Swift 工具链的发展,这些问题都可以在编译期或者 Debug 时就暴露出来.\n\n<!--more-->\n\n半自动的内存管理,实际上还有一种,就是 Rust 的 OwnerShip ,这种方式其实是 MRC/ARC 的一种延续,但 MRC/ARC 内存释放的时机还是需要在运行时才能知道,而 Rust 可以在编译期就解析出什么时候可以释放掉内存,从而省略掉 retain/release 的存在,也没必要专门跑一个 runtime 去监测对象的引用计数.从而达到比 ARC 更高的运行效率.仔细思考一下这种自动化的内存管理模式,其实都是在把指针分类,加上 context(上下文),抽象出来,暴露给编译器更多与关于指针的信息,而不是单纯的一个内存地址,从而让编译器可以分析释放对象的时机.\n\nRust 也不例外,既然要达到比 ARC 更高的运行效率,那就必然要提供给编译器更多的指针信息,以此提供给编译器更多的优化空间,因此在指针声明和传递时都需要显式地声明所有权,代码量也会相应地增多,对于程序员的要求也会更高.\n\n虽然写起来比 ARC 更麻烦一点,但也比 C 那种原始的方式简单很多,提供给了 Rust, Swift 这些”现代编程语言”编写底层程序的可能性.\n\n\n","updated":"2018-02-03T07:00:45.672Z","permalink":"http://yoursite.com/2018/01/31/关于运行时的损耗和内存管理在几种语言中的差异小纪/","categories":[],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://yoursite.com/tags/内存管理/"}]},{"title":"SDWebImage如何支持https协议","date":"2018-01-18T07:03:00.000Z","path":"2018/01/18/SDWebImage如何支持https协议/","text":"大量的App现在都用优秀的图片处理框架 SDWebImage 框架来展示图片内容,由于现在 Apple 对 app 的安全管控开始越来越严格. Apple 的做法是从管控开发者的角度来提升用户的安全度,普及 https 的措施一定会逐渐全面覆盖. 实际开发当中,我们的网络请求封住模块,除非 App 内部有下载资源的模块,不然我们很少会将自己的 App 内部的图片做特殊处理,在实际开发过程中,网络模块和 SDWebImage 联合起来才算一个完整的网络架构模块,而 SDWebImage 本身是有校验证书方法的,只不过内部没有具体的操作,也没有详细写,每个开发者可以根据具体业务需要根据实际情况来处理,所以对 SDWebImage 框架在哪里修改,在哪里改写来成功完成 https 的请求,就变成了一个事儿. 其实只要理解了SDWebImage框架的底层,以及几个关键类的作用,这个问题便不是问题: 对于 SDWebImage 框架下的 SDWebImageDownloaderOperation 这个类中的这个方法重写: - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler; 个人建议不要修改原框架的原文件,无破坏性无入侵式修改的话,对 SDWebImageDownloaderOperation 这个类 写一个分类,然后重写上述方法,以下是具体重写内容. - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler { NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) { if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) { disposition = NSURLSessionAuthChallengePerformDefaultHandling; } else { //改写方法 然后插入证书验证代码 do { SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust]; NSCAssert(serverTrust != nil, @&quot;serverTrust is nil&quot;); if(nil == serverTrust) break; /* failed */ /** * 导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称 */ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;oss-ifeixiu-com&quot; ofType:@&quot;cer&quot;]; //自签名证书 NSData *caCert = [NSData dataWithContentsOfFile:cerPath]; NSCAssert(caCert != nil, @&quot;caCert is nil&quot;); if(nil == caCert) break; /* failed */ SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert); NSCAssert(caRef != nil, @&quot;caRef is nil&quot;); if(nil == caRef) break; /* failed */ //可以添加多张证书 NSArray *caArray = @[(__bridge id)(caRef)]; NSCAssert(caArray != nil, @&quot;caArray is nil&quot;); if(nil == caArray) break; /* failed */ //将读取的证书设置为服务端帧数的根证书 OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray); NSCAssert(errSecSuccess == status, @&quot;SecTrustSetAnchorCertificates failed&quot;); if(!(errSecSuccess == status)) break; /* failed */ SecTrustResultType result = - 1; //通过本地导入的证书来验证服务器的证书是否可信 status = SecTrustEvaluate(serverTrust, &amp;result); if(!(errSecSuccess == status)) break; /* failed */ debug_NSLog(@&quot;stutas:%d&quot;,(int)status); debug_NSLog(@&quot;Result: %d&quot;, result); BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed); if (allowConnect) { debug_NSLog(@&quot;success&quot;); }else { debug_NSLog(@&quot;error&quot;); } /* kSecTrustResultUnspecified and kSecTrustResultProceed are success */ if(!allowConnect) { break; /* failed */ } #if 0 /* Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success */ /* since the user will likely tap-through to see the dancing bunnies */ if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError) break; /* failed to trust cert (good in this case) */ #endif // The only good exit point debug_NSLog(@&quot;信任该证书&quot;); credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; disposition = NSURLSessionAuthChallengeUseCredential; } while(0); } } else { if (challenge.previousFailureCount == 0) { if (self.credential) { credential = self.credential; disposition = NSURLSessionAuthChallengeUseCredential; } else { disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; } } else { disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; } } if (completionHandler) { completionHandler(disposition, credential); } }","raw":"---\ntitle: SDWebImage如何支持https协议\ndate: 2018-01-18 15:03:00\ncategories:\ntoc: true\ntags:\n     - iOS\n     - SDWebImage\n     - https\n---\n\n大量的App现在都用优秀的图片处理框架 SDWebImage 框架来展示图片内容,由于现在 Apple 对 app 的安全管控开始越来越严格. Apple 的做法是从管控开发者的角度来提升用户的安全度,普及 https 的措施一定会逐渐全面覆盖.\n\n实际开发当中,我们的网络请求封住模块,除非 App 内部有下载资源的模块,不然我们很少会将自己的 App 内部的图片做特殊处理,在实际开发过程中,网络模块和 SDWebImage 联合起来才算一个完整的网络架构模块,而 SDWebImage 本身是有校验证书方法的,只不过内部没有具体的操作,也没有详细写,每个开发者可以根据具体业务需要根据实际情况来处理,所以对 SDWebImage 框架在哪里修改,在哪里改写来成功完成 https 的请求,就变成了一个事儿.\n\n其实只要理解了SDWebImage框架的底层,以及几个关键类的作用,这个问题便不是问题:\n\n对于 SDWebImage 框架下的 SDWebImageDownloaderOperation 这个类中的这个方法重写:\n\n    - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler;\n\n\n\n个人建议不要修改原框架的原文件,无破坏性无入侵式修改的话,对  SDWebImageDownloaderOperation 这个类 写一个分类,然后重写上述方法,以下是具体重写内容.\n\n\n    - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler\n    {\n       NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;\n       __block NSURLCredential *credential = nil;\n       \n       if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {\n           if (!(self.options & SDWebImageDownloaderAllowInvalidSSLCertificates)) {\n               disposition = NSURLSessionAuthChallengePerformDefaultHandling;\n           } else {\n               //改写方法 然后插入证书验证代码\n               do\n               {\n                   SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];\n                   NSCAssert(serverTrust != nil, @\"serverTrust is nil\");\n                   if(nil == serverTrust)                break;\n                   /* failed */\n                   /**\n                    *  导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称\n                    */\n                   NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"oss-ifeixiu-com\" ofType:@\"cer\"];\n                   //自签名证书\n                   NSData *caCert = [NSData dataWithContentsOfFile:cerPath];\n                   \n                   NSCAssert(caCert != nil, @\"caCert is nil\");\n                   \n                   if(nil == caCert)                break;\n                   /* failed */\n                   SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert);\n                   NSCAssert(caRef != nil, @\"caRef is nil\");\n                   if(nil == caRef)                 break;\n                   /* failed */\n                   //可以添加多张证书\n                   NSArray *caArray = @[(__bridge id)(caRef)];\n                   NSCAssert(caArray != nil, @\"caArray is nil\");\n                   if(nil == caArray)                break;\n                   /* failed */\n                   //将读取的证书设置为服务端帧数的根证书\n                   OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);\n                   NSCAssert(errSecSuccess == status, @\"SecTrustSetAnchorCertificates failed\");\n                   if(!(errSecSuccess == status))                break;\n                   /* failed */\n                   SecTrustResultType result = - 1;\n                   //通过本地导入的证书来验证服务器的证书是否可信\n                   status = SecTrustEvaluate(serverTrust, &result);\n                   if(!(errSecSuccess == status))                break;\n                   /* failed */\n                   debug_NSLog(@\"stutas:%d\",(int)status);\n                   debug_NSLog(@\"Result: %d\", result);\n                   BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed);\n                   if (allowConnect) {\n                       debug_NSLog(@\"success\");\n                   }else {\n                       debug_NSLog(@\"error\");\n                   }\n                   \n                   /* kSecTrustResultUnspecified and kSecTrustResultProceed are success */\n                   if(!allowConnect)            {\n                       break;\n                       /* failed */\n                   }\n       #if 0\n                   /*\n                    Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success\n                    */\n                   \n                   /*   since the user will likely tap-through to see the dancing bunnies */\n                   if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError)                break;\n                   /* failed to trust cert (good in this case) */\n       #endif\n                   // The only good exit point\n                   debug_NSLog(@\"信任该证书\");\n                   credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];\n                   disposition = NSURLSessionAuthChallengeUseCredential;\n               }\n               while(0);\n           }\n       } else {\n           if (challenge.previousFailureCount == 0) {\n               if (self.credential) {\n                   credential = self.credential;\n                   disposition = NSURLSessionAuthChallengeUseCredential;\n               } else {\n                   disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;\n               }\n           } else {\n               disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;\n           }\n       }\n       \n       if (completionHandler) {\n           completionHandler(disposition, credential);\n       }\n    }\n\n\n    \n\n\n\n","updated":"2018-01-29T01:49:26.016Z","permalink":"http://yoursite.com/2018/01/18/SDWebImage如何支持https协议/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"SDWebImage","slug":"SDWebImage","permalink":"http://yoursite.com/tags/SDWebImage/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"}]},{"title":"全新的生活和逐渐的喜爱","date":"2018-01-03T05:35:00.000Z","path":"2018/01/03/全新的生活和逐渐的喜爱/","text":"17年2月,从上海回来,从有想法离开到回到合肥用了仅仅5天的时间; 我上海的几个好基友,都没有来得及一一道别,因为我不想犹豫. 我觉得我的17年可以用收获来概括: 收获了稳定的感情,收获了30斤的体重,收获了一帮现在一起共事的团队. 心怀感激. 从3月初到现在的1月初,这10个月里,飞修团队从零散几个人到目前的30多人.感受到了一种成长的喜悦. 这10个月里只做了一丢丢不值一提的工作,心里即便不想再多写业务代码,但是还是对iOS端放心不下,也许是我自己的毛病,总觉得别人写的东西看不惯,当然这里并没有说欢哥代码写的不好,仅仅只是自己性格的原因,但是也足够的信任. 转型大数据和数据挖掘,是新的起点,也是对自己新的要求.此路很长,要学的东西很多. 乐一说新年的1月,老乡鸡有个新的需求要做,我也想试试从一个产品的角度,做一下产品.可能心太大,但是还是想试试. 12月31日,过了我人生第二十五个生日,不巧的是我往后一天,就哗啦一下变成了二十六岁,很可怕的是二十六岁离三十岁那么近,还有好多事情没有做,做过的事情也做得不够好. 17年遵守承诺,下半年年底带菇凉出去玩了两次,去了健身房虽然断断续续,但是已经累计跑了差不多1000公里的距离:1000公里里有暨大的操场,深圳的大街,上海的郊区,合肥的大蜀山,合肥的健身房. 点点滴滴看起来收货慢慢有种莫名的骄傲却依然对不起现在的体重,2018年要加油. 17年的年底松了一口气,我和菇凉在武汉光谷广场跨年的时候,我发现武汉并没有比合肥好很多,也没合肥舒服,这意味着我开始习惯合肥的生活,所以我觉得我的全新的生活才刚刚开始,也有了逐渐的喜爱,即便每天都要吐槽个够,但这都不重要. 18年要准备买房了,希望能完成这人生第一大任务. 18年要更懂得生活,要更收敛得住脾气. 18年要好好锻炼,做适当的胖子. 18年代码更精益求精. new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"Despacito(钢琴版)\", author: \"未知\", url: \"http://ozwoorjfp.bkt.clouddn.com/Despacito%28%E9%92%A2%E7%90%B4%E7%89%88%29.mp3\", pic: \"\", } });","raw":"---\ntitle: 全新的生活和逐渐的喜爱\ndate: 2018-01-03 13:35:00\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n\n17年2月,从上海回来,从有想法离开到回到合肥用了仅仅5天的时间;\n\n我上海的几个好基友,都没有来得及一一道别,因为我不想犹豫.\n\n我觉得我的17年可以用收获来概括:\n\n收获了稳定的感情,收获了30斤的体重,收获了一帮现在一起共事的团队.\n\n心怀感激.\n\n从3月初到现在的1月初,这10个月里,飞修团队从零散几个人到目前的30多人.感受到了一种成长的喜悦.\n\n这10个月里只做了一丢丢不值一提的工作,心里即便不想再多写业务代码,但是还是对iOS端放心不下,也许是我自己的毛病,总觉得别人写的东西看不惯,当然这里并没有说欢哥代码写的不好,仅仅只是自己性格的原因,但是也足够的信任.\n\n转型大数据和数据挖掘,是新的起点,也是对自己新的要求.此路很长,要学的东西很多.\n\n乐一说新年的1月,老乡鸡有个新的需求要做,我也想试试从一个产品的角度,做一下产品.可能心太大,但是还是想试试.\n\n12月31日,过了我人生第二十五个生日,不巧的是我往后一天,就哗啦一下变成了二十六岁,很可怕的是二十六岁离三十岁那么近,还有好多事情没有做,做过的事情也做得不够好.\n\n17年遵守承诺,下半年年底带菇凉出去玩了两次,去了健身房虽然断断续续,但是已经累计跑了差不多1000公里的距离:1000公里里有暨大的操场,深圳的大街,上海的郊区,合肥的大蜀山,合肥的健身房.\n\n点点滴滴看起来收货慢慢有种莫名的骄傲却依然对不起现在的体重,2018年要加油.\n\n17年的年底松了一口气,我和菇凉在武汉光谷广场跨年的时候,我发现武汉并没有比合肥好很多,也没合肥舒服,这意味着我开始习惯合肥的生活,所以我觉得我的全新的生活才刚刚开始,也有了逐渐的喜爱,即便每天都要吐槽个够,但这都不重要.\n\n18年要准备买房了,希望能完成这人生第一大任务.\n\n18年要更懂得生活,要更收敛得住脾气.\n\n18年要好好锻炼,做适当的胖子.\n\n18年代码更精益求精.\n\n\n<!--more-->\n\n\n{% aplayer \"Despacito(钢琴版)\" \"未知\" \"http://ozwoorjfp.bkt.clouddn.com/Despacito%28%E9%92%A2%E7%90%B4%E7%89%88%29.mp3\" \"\" \"autoplay\" %}\n\n\n","updated":"2018-01-03T07:42:08.301Z","permalink":"http://yoursite.com/2018/01/03/全新的生活和逐渐的喜爱/","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"Python07","date":"2017-12-26T03:59:25.000Z","path":"2017/12/26/Python07/","text":"模块import sys 导入sys模块,用变量sys指向该模块,利用sys这个变量,就可以访问sys模块的所有功能.sys模块有一个argv变量,用list存储了命令行的所有参数.argv至少有一个元素,因为第一个参数永远是该.py文件的名称. 作用域在Python中函数和变量的访问限制可以用来实现.一般情况下函数和变量名是公开的（public）,可以被直接引用.类似xxx这样的变量是特殊变量,可以被直接引用,但是有特殊用途.比如 \\_author__和__name__是特殊变量,但是我们一般不这样去定义变量.一般情况下我们定义的变量是:类似_xxx和__xxx这样的函数或变量就是非公开的（private）,不应该被直接引用.值得注意的是private函数和变量“不应该”被直接引用,而不是“不能”被直接引用,是因为Python并没有一种方法可以完全限制访问private函数或变量,但是,从编程习惯上不应该引用private函数或变量.这种意义上来看Python和很多其他语言一样,也是注重开源的. 举例: def _private_1(name): return &apos;Hello, %s&apos; % name def _private_2(name): return &apos;Hi, %s&apos; % name def greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 外部不需要引用的函数全部定义成private,只有外部需要引用的函数才定义为public.","raw":"---\ntitle: Python07\ndate: 2017-12-26 11:59:25\ncategories:\ntoc: ture\ntags:\n     - Python 模块\n---\n\n# 模块\n\n    import sys\n    \n导入sys模块,用变量sys指向该模块,利用sys这个变量,就可以访问sys模块的所有功能.\nsys模块有一个argv变量,用list存储了命令行的所有参数.argv至少有一个元素,因为第一个参数永远是该.py文件的名称.\n\n## 作用域\n\n在Python中函数和变量的访问限制可以用_来实现.\n一般情况下函数和变量名是公开的（public）,可以被直接引用.\n类似__xxx__这样的变量是特殊变量,可以被直接引用,但是有特殊用途.比如 \\_\\_author\\_\\_和\\_\\_name\\_\\_是特殊变量,但是我们一般不这样去定义变量.\n一般情况下我们定义的变量是:类似_xxx和__xxx这样的函数或变量就是非公开的（private）,不应该被直接引用.\n值得注意的是private函数和变量“不应该”被直接引用,而不是“不能”被直接引用,是因为Python并没有一种方法可以完全限制访问private函数或变量,但是,从编程习惯上不应该引用private函数或变量.这种意义上来看Python和很多其他语言一样,也是注重开源的.\n\n举例:\n\n    def _private_1(name):\n        return 'Hello, %s' % name\n    \n    def _private_2(name):\n        return 'Hi, %s' % name\n    \n    def greeting(name):\n        if len(name) > 3:\n            return _private_1(name)\n        else:\n            return _private_2(name)\n            \n外部不需要引用的函数全部定义成private,只有外部需要引用的函数才定义为public.\n\n    \n\n\n","updated":"2018-01-09T02:06:42.656Z","permalink":"http://yoursite.com/2017/12/26/Python07/","categories":[],"tags":[{"name":"Python 模块","slug":"Python-模块","permalink":"http://yoursite.com/tags/Python-模块/"}]},{"title":"Python06","date":"2017-12-19T04:44:09.000Z","path":"2017/12/19/Python06/","text":"高阶函数定义:把函数作为参数传入,这样的函数称为高阶函数,函数式编程就是指这种高度抽象的编程范式.理解:个人以为这种思想和逻辑思路,在C语言上早就有,C中的指向函数指针的指针这种思想概念是可以的,而OC中却没有强化这种概念,OC的Block已经强大到足够完成这种纬度的调用和处理业务的场景复杂度,JavaScript这种脚本语言和Python解释型语言反而愈加强化这种观念,将函数(本质上是指针)作为参数使用传递. 变量可以指向函数&gt;&gt;&gt; x = abs(-10) &gt;&gt;&gt; x 10 abs是函数,abs(-10)是函数的调用,上面是将abs(-10)的结果赋值给x; &gt;&gt;&gt; f = abs &gt;&gt;&gt; f &lt;built-in function abs&gt; 上面是将abs函数整体赋值给f,也就是函数本身赋值给变量,即:变量可以指向函数. 当一个变量指向了一个函数,那么可以通过该变量来调用这个函数; &gt;&gt;&gt; f = abs &gt;&gt;&gt; f(-10) 10 直接调用abs()函数和调用变量f()完全相同; 函数名也是变量那么函数名是什么呢?函数名其实就是指向函数的变量!对于abs()这个函数,完全可以把函数名abs看成变量,它指向一个可以计算绝对值的函数! 传入函数既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数. def add(x, y, f): return f(x) + f(y) 当调用add(-5, 6, abs)时,推导计算过程为 x = -5 y = 6 f = abs f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11 return 11 编写高阶函数,就是让函数的参数能够接收别的函数. map/reducemap重点了解map()和reduce()两个函数; 对于map()而言:接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回; 举例:将函数f(x) = x ^ 2 ,要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上. &gt;&gt;&gt; def f(x): ... return x * x ... &gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f,即函数对象本身.由于结果r是一个Iterator,Iterator是惰性序列,因此通过list()函数让它把整个序列都计算出来并返回一个list. 当然上面的过程和需求的作用结果,我们用循环遍历也可以做,比如讲循环遍历挨个平方,也能得到类似的结果,但是你需要看真个循环你才知道这个循环的作用是用来干嘛的,而map()的意义在于,它作为高阶函数,把具体的运算规则抽象化; 例如:要把list [1, 2, 3, 4, 5, 6, 7, 8, 9]所有元素转成字符 &gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] 用map()去执行的话,相当的简洁明. reducereduce把一个函数作用在一个序列[x1, x2, x3, …]上,这个函数必须接收两个参数,reduce把结果继续和序列的下一个元素做累积计算,其效果就是: reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 求和运算可以直接用Python内建函数sum(),没必要动用reduce.假如需要把 [1,3,5,7,9]变换成整数13579,reduce就可以施展拳脚了. &gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; def fn(x, y): ... return x * 10 + y ... &gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9]) 13579 filterfilter()和map()类似,filter()也接收一个函数和一个序列.和map()不同的是,filter()把传入的函数依次作用于每个元素,然后根据返回值是True还是False决定保留还是丢弃该元素. 举例:删掉list里的偶数,保留基数 def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] filter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list. 经典案例分析:用filter求素数(质数又称素数,一个大于1的自然数,除了1和它自身外,不能被其他自然数整除的数叫做质数;否则称为合数.) 最常见的统计素数的方法是埃氏筛法,原理如下: 首先,列出从2开始的所有自然数,构造一个序列:2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取序列的第一个数2,它一定是素数,然后用2把序列的2的倍数筛掉:3, 4(X), 5, 6(X), 7, 8(X), 9, 10(X), 11, 12(X), 13, 14(X), 15, 16(X), 17, 18(X), 19, 20(X), …取新序列的第一个数3,它一定是素数,然后用3把序列的3的倍数筛掉:5, 6(X), 7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), …取新序列的第一个数5,然后用5把序列的5的倍数筛掉:7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), … 不断筛下去,就可以得到所有的素数. def _int_iter(): n = 1 while True: n = n + 1 yield n def _not_divisible(n): return lambda x:x % n &gt; 0 def primes(): it = _int_iter() while True: n = next(it) yield n it = filter(_not_divisible(n), it) sorted排序不管是常见的冒泡还是快排,核心的思想都是比较两个元素的大小;有个问题是:当我们比较数字大小的时候,可以直接快速的比较,但是对于比较字符串或者dict的时候,便没有了数学意义上的大小意义,因此可以把过程抽象出来. 举例:对List排序 &gt;&gt;&gt; sorted([36, 5, -12, 9, -21]) [-21, -12, 5, 9, 36] sorted()可以接收一个key函数来实现自定义的排序,比如按绝对值大小排序: &gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36] 从这里可以看出,sorted()排序的关键在于实现一个映射函数. 返回函数函数作为返回值高阶函数不仅可以把函数作为参数,同时也可以把函数作为结果返回. 下面是个求和函数 def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 如果不需要立即求和,后续根据需求再求和,可以不返回求和结果,而是返回求和的函数: def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum (这两个是python中的可变参数.*args表示任何多个无名参数,它是一个tuple;**kwargs表示关键字参数,它是一个dict.并且同时使用*args和**kwargs时,必须*args参数列要在**\\kwargs前.) &gt;&gt;&gt; f = lazy_sum(1,3,5,7,9) &gt;&gt;&gt; f &lt;function sum at 0x1010f9d70&gt; &gt;&gt;&gt; f() 25 在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数sum时,相关参数和变量都保存在返回的函数中,这种称为“闭包（Closure）”. 闭包返回闭包时牢记一点:返回函数不要引用任何循环变量,或者后续会发生变化的变量.如果一定要引用循环变量怎么办?方法是再创建一个函数,用该函数的参数绑定循环变量当前的值,无论该循环变量后续如何更改,已绑定到函数参数的值不变. def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 一个函数可以返回一个计算结果,也可以返回一个函数.返回一个函数时,函数并未执行,返回函数中不要引用任何可能会变化的变量. 匿名函数传入函数时,有些时候,不需要显式地定义函数,直接传入匿名函数更方便.Python中对匿名函数有一些有限的支持. &gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [1, 4, 9, 16, 25, 36, 49, 64, 81] 上面的lambda x: x * x的本质是 def f(x): return x * x 关键字lambda [‘læmdə] (是λ的英文)表示匿名函数,冒号前面的x表示函数参数.匿名函数有个限制,就是只能有一个表达式,不用写return,返回值就是该表达式的结果. 用匿名函数有个好处,因为函数没有名字,不必担心函数名冲突.此外,匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,再利用变量来调用该函数: &gt;&gt;&gt; f = lambda x: x * x &gt;&gt;&gt; f &lt;function &lt;lambda&gt; at 0x101c6ef28&gt; &gt;&gt;&gt; f(5) 25 同样,也可以把匿名函数作为返回值返回: def build(x, y): return lambda: x * x + y * y 装饰器举例: &gt;&gt;&gt; def now(): ... print(&apos;2015-3-25&apos;) ... &gt;&gt;&gt; f = now &gt;&gt;&gt; f() 2015-3-25 函数对象有一个name属性,可以拿到函数的名字: &gt;&gt;&gt; now.__name__ &apos;now&apos; &gt;&gt;&gt; f.__name__ &apos;now&apos; 要增强now()函数的功能,比如在函数调用前后自动打印日志,但又不希望修改now()函数的定义,这种在代码运行期间动态增加功能的方式,称之为“装饰器”（Decorator）.本质上,decorator就是一个返回函数的高阶函数. def log(func): def wrapper(*args, **kw): print(&apos;call %s():&apos; % func.__name__) return func(*args, **kw) return wrapper log接受一个函数,且返回一个函数,Python中提供了一个@语法,可以把修饰器放置在函数定义的地方,从而来影响函数的执行效果和结果. @log def now(): print(&apos;2015-3-25&apos;) 这样你在调用now的时候,不仅会执行原本的now函数,同时会执行log函数,把@log放到now()函数的定义处,相当于执行了语句: now = log(now) 由于log()是一个decorator,返回一个函数,所以原来的now()函数仍然存在,只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数.wrapper()函数的参数定义是(*args, **kw),因此，wrapper()函数可以接受任意参数的调用.在wrapper()函数内,首先打印日志，再紧接着调用原始函数. def log(text): def decorator(func): def wrapper(*args, **kw): print(&apos;%s %s():&apos; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 如果decorator本身需要传入参数,那就需要编写一个返回decorator的高阶函数.调用如下: @log(&apos;execute&apos;) def now(): print(&apos;2015-3-25&apos;) 执行效果如下: &gt;&gt;&gt; now() execute now(): 2015-3-25 本质上调用了如下代码: &gt;&gt;&gt; now = log(&apos;execute&apos;)(now) 首先执行log(‘execute’),返回的是decorator函数,再调用返回的函数,参数是now函数,返回值最终是wrapper函数 偏函数当函数的参数个数太多,需要简化时,使用functools.partial可以创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单.","raw":"---\ntitle: Python06\ndate: 2017-12-19 12:44:09\ncategories:\ntoc: ture\ntags:\n     - Python 函数式编程\n---\n\n\n# 高阶函数\n\n定义:把函数作为参数传入,这样的函数称为高阶函数,函数式编程就是指这种高度抽象的编程范式.\n理解:个人以为这种思想和逻辑思路,在C语言上早就有,C中的指向函数指针的指针这种思想概念是可以的,而OC中却没有强化这种概念,OC的Block已经强大到足够完成这种纬度的调用和处理业务的场景复杂度,JavaScript这种脚本语言和Python解释型语言反而愈加强化这种观念,将函数(本质上是指针)作为参数使用传递.\n\n\n## 变量可以指向函数\n\n    >>> x = abs(-10)\n    >>> x\n    10\n    \nabs是函数,abs(-10)是函数的调用,上面是将abs(-10)的结果赋值给x;\n\n    >>> f = abs\n    >>> f\n    <built-in function abs>\n    \n上面是将abs函数整体赋值给f,也就是函数本身赋值给变量,即:变量可以指向函数.\n\n当一个变量指向了一个函数,那么可以通过该变量来调用这个函数;\n\n    >>> f = abs\n    >>> f(-10)\n    10\n\n直接调用abs()函数和调用变量f()完全相同;\n\n## 函数名也是变量\n\n那么函数名是什么呢?函数名其实就是指向函数的变量!对于abs()这个函数,完全可以把函数名abs看成变量,它指向一个可以计算绝对值的函数!\n\n## 传入函数\n\n既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数.\n\n    def add(x, y, f):\n        return f(x) + f(y)\n\n当调用add(-5, 6, abs)时,推导计算过程为\n\n    x = -5\n    y = 6\n    f = abs\n    f(x) + f(y) ==> abs(-5) + abs(6) ==> 11\n    return 11\n    \n编写高阶函数,就是让函数的参数能够接收别的函数.\n\n\n<!--more-->\n\n\n## map/reduce\n\n### map\n\n重点了解map()和reduce()两个函数;\n\n对于map()而言:接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回;\n\n举例:将函数f(x) = x ^ 2 ,要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上.\n\n    >>> def f(x):\n    ...     return x * x\n    ...\n    >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> list(r)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nmap()传入的第一个参数是f,即函数对象本身.由于结果r是一个Iterator,Iterator是惰性序列,因此通过list()函数让它把整个序列都计算出来并返回一个list.\n\n当然上面的过程和需求的作用结果,我们用循环遍历也可以做,比如讲循环遍历挨个平方,也能得到类似的结果,但是你需要看真个循环你才知道这个循环的作用是用来干嘛的,而map()的意义在于,它作为高阶函数,把具体的运算规则抽象化;\n\n例如:要把list [1, 2, 3, 4, 5, 6, 7, 8, 9]所有元素转成字符\n\n    >>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    \n用map()去执行的话,相当的简洁明.\n\n### reduce\n\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上,这个函数必须接收两个参数,reduce把结果继续和序列的下一个元素做累积计算,其效果就是:\n\n    reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n\n求和运算可以直接用Python内建函数sum(),没必要动用reduce.\n假如需要把 [1,3,5,7,9]变换成整数13579,reduce就可以施展拳脚了.\n\n    >>> from functools import reduce\n    >>> def fn(x, y):\n    ...     return x * 10 + y\n    ...\n    >>> reduce(fn, [1, 3, 5, 7, 9])\n    13579\n\n### filter\n\nfilter()和map()类似,filter()也接收一个函数和一个序列.和map()不同的是,filter()把传入的函数依次作用于每个元素,然后根据返回值是True还是False决定保留还是丢弃该元素.\n\n举例:删掉list里的偶数,保留基数\n\n    def is_odd(n):\n    return n % 2 == 1\n    \n    list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n    # 结果: [1, 5, 9, 15]\n\nfilter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list.\n\n经典案例分析:用filter求素数\n(质数又称素数,一个大于1的自然数,除了1和它自身外,不能被其他自然数整除的数叫做质数;否则称为合数.)\n\n最常见的统计素数的方法是埃氏筛法,原理如下:\n\n首先,列出从2开始的所有自然数,构造一个序列:\n2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...\n取序列的第一个数2,它一定是素数,然后用2把序列的2的倍数筛掉:\n3, 4(X), 5, 6(X), 7, 8(X), 9, 10(X), 11, 12(X), 13, 14(X), 15, 16(X), 17, 18(X), 19, 20(X), ...\n取新序列的第一个数3,它一定是素数,然后用3把序列的3的倍数筛掉:\n5, 6(X), 7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), ...\n取新序列的第一个数5,然后用5把序列的5的倍数筛掉:\n7, 8(X), 9(X), 10(X), 11, 12(X), 13, 14(X), 15(X), 16(X), 17, 18(X), 19, 20(X), ...\n\n不断筛下去,就可以得到所有的素数.\n\n    def _int_iter():\n        n = 1\n        while True:\n            n = n + 1\n            yield n\n     \n    def  _not_divisible(n):\n        return lambda x:x % n > 0\n     \n    def primes():\n        it = _int_iter()\n        while True:\n            n = next(it)\n            yield n\n            it = filter(_not_divisible(n), it)\n\n### sorted\n\n排序不管是常见的冒泡还是快排,核心的思想都是比较两个元素的大小;有个问题是:当我们比较数字大小的时候,可以直接快速的比较,但是对于比较字符串或者dict的时候,便没有了数学意义上的大小意义,因此可以把过程抽象出来.\n\n举例:对List排序\n\n    >>> sorted([36, 5, -12, 9, -21])\n    [-21, -12, 5, 9, 36]\n    \nsorted()可以接收一个key函数来实现自定义的排序,比如按绝对值大小排序: \n\n    >>> sorted([36, 5, -12, 9, -21], key=abs)\n    [5, 9, -12, -21, 36]\n\n从这里可以看出,sorted()排序的关键在于实现一个映射函数.\n\n# 返回函数\n\n## 函数作为返回值\n\n高阶函数不仅可以把函数作为参数,同时也可以把函数作为结果返回.\n\n下面是个求和函数\n\n    def calc_sum(*args):\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n\n如果不需要立即求和,后续根据需求再求和,可以不返回求和结果,而是返回求和的函数:\n\n    def lazy_sum(*args):\n        def sum():\n            ax = 0\n            for n in args:\n                ax = ax + n\n            return ax\n        return sum\n\n(这两个是python中的可变参数.\\*args表示任何多个无名参数,它是一个tuple;\\*\\*kwargs表示关键字参数,它是一个dict.并且同时使用\\*args和\\*\\*kwargs时,必须\\*args参数列要在\\**\\kwargs前.)\n\n    >>> f = lazy_sum(1,3,5,7,9)\n    >>> f\n    <function sum at 0x1010f9d70>\n    >>> f()\n    25\n   \n在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数sum时,相关参数和变量都保存在返回的函数中,这种称为“闭包（Closure）”.\n \n## 闭包\n\n返回闭包时牢记一点:返回函数不要引用任何循环变量,或者后续会发生变化的变量.\n如果一定要引用循环变量怎么办?方法是再创建一个函数,用该函数的参数绑定循环变量当前的值,无论该循环变量后续如何更改,已绑定到函数参数的值不变.\n\n    def count():\n        def f(j):\n            def g():\n                return j*j\n            return g\n        fs = []\n        for i in range(1, 4):\n            fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()\n        return fs\n \n一个函数可以返回一个计算结果,也可以返回一个函数.\n返回一个函数时,函数并未执行,返回函数中不要引用任何可能会变化的变量.\n\n# 匿名函数\n\n传入函数时,有些时候,不需要显式地定义函数,直接传入匿名函数更方便.\nPython中对匿名函数有一些有限的支持.\n\n    >>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    [1, 4, 9, 16, 25, 36, 49, 64, 81]\n    \n上面的lambda x: x * x的本质是\n\n    def f(x):\n        return x * x\n        \n关键字lambda \\['læmdə] (是λ的英文)表示匿名函数,冒号前面的x表示函数参数.\n匿名函数有个限制,就是只能有一个表达式,不用写return,返回值就是该表达式的结果.\n\n用匿名函数有个好处,因为函数没有名字,不必担心函数名冲突.此外,匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,再利用变量来调用该函数:\n\n    >>> f = lambda x: x * x\n    >>> f\n    <function <lambda> at 0x101c6ef28>\n    >>> f(5)\n    25\n    \n同样,也可以把匿名函数作为返回值返回:\n\n    def build(x, y):\n        return lambda: x * x + y * y\n        \n# 装饰器\n\n举例:\n\n    >>> def now():\n    ...     print('2015-3-25')\n    ...\n    >>> f = now\n    >>> f()\n    2015-3-25\n    \n函数对象有一个__name__属性,可以拿到函数的名字:\n\n    >>> now.__name__\n    'now'\n    >>> f.__name__\n    'now'\n    \n要增强now()函数的功能,比如在函数调用前后自动打印日志,但又不希望修改now()函数的定义,这种在代码运行期间动态增加功能的方式,称之为“装饰器”（Decorator）.本质上,decorator就是一个返回函数的高阶函数.\n\n    def log(func):\n        def wrapper(*args, **kw):\n            print('call %s():' % func.__name__)\n            return func(*args, **kw)\n        return wrapper\n\nlog接受一个函数,且返回一个函数,Python中提供了一个@语法,可以把修饰器放置在函数定义的地方,从而来影响函数的执行效果和结果.\n\n    @log\n    def now():\n        print('2015-3-25')\n        \n这样你在调用now的时候,不仅会执行原本的now函数,同时会执行log函数,把@log放到now()函数的定义处,相当于执行了语句:\n\n    now = log(now)\n\n由于log()是一个decorator,返回一个函数,所以原来的now()函数仍然存在,只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数.\nwrapper()函数的参数定义是(\\*args, \\*\\*kw),因此，wrapper()函数可以接受任意参数的调用.在wrapper()函数内,首先打印日志，再紧接着调用原始函数. \n\n    def log(text):\n        def decorator(func):\n            def wrapper(*args, **kw):\n                print('%s %s():' % (text, func.__name__))\n                return func(*args, **kw)\n            return wrapper\n        return decorator\n        \n如果decorator本身需要传入参数,那就需要编写一个返回decorator的高阶函数.\n调用如下:\n\n    @log('execute')\n    def now():\n        print('2015-3-25')\n     \n执行效果如下:     \n   \n    >>> now()\n    execute now():\n    2015-3-25\n    \n本质上调用了如下代码:\n\n    >>> now = log('execute')(now)\n    \n首先执行log('execute'),返回的是decorator函数,再调用返回的函数,参数是now函数,返回值最终是wrapper函数\n\n# 偏函数\n\n当函数的参数个数太多,需要简化时,使用functools.partial可以创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单.\n\n\n\n\n\n\n\n","updated":"2017-12-26T03:59:56.209Z","permalink":"http://yoursite.com/2017/12/19/Python06/","categories":[],"tags":[{"name":"Python 函数式编程","slug":"Python-函数式编程","permalink":"http://yoursite.com/tags/Python-函数式编程/"}]},{"title":"Python05","date":"2017-12-16T05:45:53.000Z","path":"2017/12/16/Python05/","text":"切片在很多编程语言中,针对字符串提供了很多各种截取函数（例如,substring）,其实目的就是对字符串切片.Python没有针对字符串的截取函数,只需要切片一个操作就可以完成,非常简单. Python针对所有需要截取的操作,统一都用切片操作来处理,比如对list,tuple元素的截取,对string的字符截取,都可以用切片操作来完成. [1,2,3,4,5] [0:5] (0, 1, 2, 3, 4, 5)[:3] &apos;string&apos;[1:3] 迭代对于给定一个list或tuple,可以通过for循环来遍历这个list或tuple,这种遍历在被称为迭代（Iteration）.而Python OC Swift等语言支持 for … in 循环遍历, Java 是 for X : X 这种类型,其实本质上都一样,只是语言规则形式上的区别,而 C 语言中的迭代要溯源于for循环的下标循环 for (i=0; i&lt;list.length; i++) { // 处理操作 } 在Python中,对于list和tuple这种带下标顺序的数据结构类型无疑是可以迭代的,Python同样支持无下标的一些数据结构比如Python中的dict, 其实意味着dict对于Python而言是一个可迭代的对象,OC和Swift以及Java其实对字典亦或是Map的操作处理都具有类似的迭代功能; 而对于字符串处理的其他语言可能实现迭代较为繁琐,需要先转化一下在进行迭代操作,而Python有直接操作的兼容性,其实本质上都是做了转化处理;相反的Python反而想做下标循环遍历要比C/OC/Swift/Java等要困难; 小结但是Python的思想是想告诉使用者,但凡遇到了一串,一堆的东西的时候,首先它都是可以当成一个容器的结构去处理的;Python对这些的处理总有一种化繁为简的操作,处理都使用同样的接口和同样的API来处理不同的数据结构;迭代的思想如此,切片的思想也是如此; 在Python中,任何可迭代对象都可以作用于for循环,包括自定义的数据类型,只要符合迭代条件,就可以使用for循环. Tips:如何判断一个对象是可迭代对象?方法是通过collections模块的Iterable类型判断: &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 列表生成式Python内置的非常简单却强大的可以用来创建list的生成式;例如:要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; &gt;&gt;&gt; list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 例如:要生成[1x1, 2x2, 3x3, …, 10x10]; 方法一:(用循环,但是比较繁琐) &gt;&gt;&gt; L = [] &gt;&gt;&gt; for x in range(1, 11): ... L.append(x * x) ... &gt;&gt;&gt; L [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 方法二: &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表生成式时,把要生成的元素x * x放到前面,后面跟for循环,就可以把list创建出来.此外,for循环后面还可以加上if判断,这样我们就可以筛选出仅偶数的平方,比如 &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 还可以使用两层循环,可以生成全排列: &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 列表生成式也可以使用两个变量来生成list: &gt;&gt;&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; } &gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()] [&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;] 最后把一个list中所有的字符串变成小写: &gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;apple&apos;] &gt;&gt;&gt; [s.lower() for s in L] [&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 使用内建的isinstance函数可以判断一个变量是不是字符串: &gt;&gt;&gt; x = &apos;abc&apos; &gt;&gt;&gt; y = 123 &gt;&gt;&gt; isinstance(x, str) True &gt;&gt;&gt; isinstance(y, str) False 小结Python的语法对矩阵的表示太友好了. 生成器通过列表生成式,可以直接创建一个列表.但是,受到内存限制,列表容量肯定是有限.假如创建一个包含100万个元素的列表,不仅占用很大的存储空间,如果我们仅仅需要访问前面几个元素,那后面绝大多数元素占用的空间都白白浪费了. 如果列表元素可以按照某种算法推算出来,那我们是否可以在循环的过程中不断推算出后续的元素呢?这样就不必创建完整的list,从而节省大量的空间. 在Python中,这种一边循环一边计算的机制,称为生成器:generator. 创建生成器方法方法一:有个简单的方法,把一个列表生成式的[]改成(),就创建了一个生成器 &gt;&gt;&gt; L = [x * x for x in range(10)] &gt;&gt;&gt; L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; g 其中L是一个列表,而g是一个生成器;一般情况下,我们可以直接打印出List,而生成器要用何方法打印呢?可以用next()函数; &gt;&gt;&gt; next(g) 0 &gt;&gt;&gt; next(g) 1 &gt;&gt;&gt; next(g) 4 &gt;&gt;&gt; next(g) 9 &gt;&gt;&gt; next(g) 16 &gt;&gt;&gt; next(g) 25 &gt;&gt;&gt; next(g) 36 &gt;&gt;&gt; next(g) 49 &gt;&gt;&gt; next(g) 64 &gt;&gt;&gt; next(g) 81 &gt;&gt;&gt; next(g) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration 为何每次都只打印一个值的原因是:generator保存的是算法,每次调用next(g),就计算出g的下一个元素的值,直到计算到最后一个元素,没有更多的元素时,抛出StopIteration的错误.所以是符合我们之前对generator的定义和最初要求的. 当然逐个打印出来的方法显得略笨,同样可以用for循环来操作打印 &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81 对于generator来说,如果推算的算法比较复杂,用类似列表生成式的for循环无法实现的时候,还可以用函数来实现. 这里有个典型的例子:斐波拉契数列函数如下 def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b #这一句相当于下面的注释的三句代码 #t = (b, a + b) # t是一个tuple #a = t[0] #b = t[1] n = n + 1 return &apos;done&apos; fib函数实际上是定义了斐波拉契数列的推算规则,可以从第一个元素开始,推算出后续任意的元素,这其实非常类似generator的思想,且达到了generator的意义; 对于另一种生成器的创建方法就是:改写函数,当一个函数中含有关键字yield的时候,那么这个函数就不是一个普通函数,值得注意的是generator和函数的区别:函数是顺序执行,遇到return语句或者最后一行函数语句就返回.而generator函数,在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行. def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b #这一句相当于下面的注释的三句代码 #t = (b, a + b) # t是一个tuple #a = t[0] #b = t[1] n = n + 1 return &apos;done&apos; 用for循环调用generator时,如果拿不到generator的return语句的返回值,且又想要拿到返回值,那就需要捕获StopIteration错误,返回值包含在StopIteration的value中; &gt;&gt;&gt; g = fib(6) &gt;&gt;&gt; while True: ... try: ... x = next(g) ... print(&apos;g:&apos;, x) ... except StopIteration as e: ... print(&apos;Generator return value:&apos;, e.value) ... break ... g: 1 g: 1 g: 2 g: 3 g: 5 g: 8 Generator return value: done 小结在Python中,可以简单地把列表生成式改成generator,也可以通过函数实现复杂逻辑的generator.要理解generator的工作原理,它是在for循环的过程中不断计算出下一个元素,并在适当的条件结束for循环.对于函数改成的generator来说,遇到return语句或者执行到函数体最后一行语句,就是结束generator的指令,for循环随之结束. 迭代器直接作用于for循环的数据类型有以下几种：一类是集合数据类型,如list、tuple、dict、set、str等;一类是generator,包括生成器和带yield的generator function.这些可以直接作用于for循环的对象统称为可迭代对象:Iterable. &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance([], Iterable) True &gt;&gt;&gt; isinstance({}, Iterable) True &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) True &gt;&gt;&gt; isinstance((x for x in range(10)), Iterable) True &gt;&gt;&gt; isinstance(100, Iterable) False 生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出StopIteration错误表示无法继续返回下一个值了.可以被next()函数调用并不断返回下一个值的对象称为迭代器:Iterator.可以使用isinstance()判断一个对象是否是Iterator对象. &gt;&gt;&gt; from collections import Iterator &gt;&gt;&gt; isinstance((x for x in range(10)), Iterator) True &gt;&gt;&gt; isinstance([], Iterator) False &gt;&gt;&gt; isinstance({}, Iterator) False &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator) False 生成器都是Iterator对象,但list、dict、str虽然是Iterable(可迭代的),却不是Iterator(迭代器). 但是要把list、dict、str等Iterable变成Iterator可以使用iter()函数: &gt;&gt;&gt; isinstance(iter([]), Iterator) True &gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator) True 因为Python的Iterator对象表示的是一个数据流,Iterator对象可以被next()函数调用并不断返回下一个数据,直到没有数据时抛出StopIteration错误.可以把这个数据流看做是一个有序序列,但我们却不能提前知道序列的长度,只能不断通过next()函数实现按需计算下一个数据,所以Iterator的计算是惰性的,只有在需要返回下一个数据时它才会计算.Iterator甚至可以表示一个无限大的数据流,例如全体自然数.而使用list是永远不可能存储全体自然数的. 小结凡是可作用于for循环的对象都是Iterable类型;凡是可作用于next()函数的对象都是Iterator类型,它们表示一个惰性计算的序列;集合数据类型如list、dict、str等是Iterable但不是Iterator,不过可以通过iter()函数获得一个Iterator对象.Python的for循环本质上就是通过不断调用next()函数实现的,例如: for x in [1, 2, 3, 4, 5]: pass 等价于： # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break","raw":"---\ntitle: Python05\ndate: 2017-12-16 13:45:53\ncategories:\ntoc: ture\ntags:\n     - Python 高级特性\n---\n\n## 切片\n在很多编程语言中,针对字符串提供了很多各种截取函数（例如,substring）,其实目的就是对字符串切片.Python没有针对字符串的截取函数,只需要切片一个操作就可以完成,非常简单.\n\nPython针对所有需要截取的操作,统一都用切片操作来处理,比如对list,tuple元素的截取,对string的字符截取,都可以用切片操作来完成.\n\n     [1,2,3,4,5] [0:5]\n     (0, 1, 2, 3, 4, 5)[:3]\n     'string'[1:3]\n     \n<!--more-->\n\n## 迭代\n对于给定一个list或tuple,可以通过for循环来遍历这个list或tuple,这种遍历在被称为迭代（Iteration）.\n而Python OC Swift等语言支持 for ... in 循环遍历, Java 是 for  X : X 这种类型,其实本质上都一样,只是语言规则形式上的区别,而 C 语言中的迭代要溯源于for循环的下标循环\n \n     for (i=0; i<list.length; i++) \n     {\n         // 处理操作\n     }\n     \n在Python中,对于list和tuple这种带下标顺序的数据结构类型无疑是可以迭代的,Python同样支持无下标的一些数据结构比如Python中的dict, 其实意味着dict对于Python而言是一个可迭代的对象,OC和Swift以及Java其实对字典亦或是Map的操作处理都具有类似的迭代功能;\n\n而对于字符串处理的其他语言可能实现迭代较为繁琐,需要先转化一下在进行迭代操作,而Python有直接操作的兼容性,其实本质上都是做了转化处理;相反的Python反而想做下标循环遍历要比C/OC/Swift/Java等要困难;\n\n### 小结\n但是Python的思想是想告诉使用者,但凡遇到了一串,一堆的东西的时候,首先它都是可以当成一个容器的结构去处理的;\nPython对这些的处理总有一种化繁为简的操作,处理都使用同样的接口和同样的API来处理不同的数据结构;\n迭代的思想如此,切片的思想也是如此;   \n\n在Python中,任何可迭代对象都可以作用于for循环,包括自定义的数据类型,只要符合迭代条件,就可以使用for循环.\n\nTips:如何判断一个对象是可迭代对象?方法是通过collections模块的Iterable类型判断:\n     \n    >>> from collections import Iterable\n    >>> isinstance('abc', Iterable) # str是否可迭代\n    True\n    >>> isinstance([1,2,3], Iterable) # list是否可迭代\n    True\n    >>> isinstance(123, Iterable) # 整数是否可迭代\n    False\n\n## 列表生成式\nPython内置的非常简单却强大的可以用来创建list的生成式;\n例如:要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    >>> list(range(1, 11))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n例如:要生成[1x1, 2x2, 3x3, ..., 10x10];\n\n方法一:(用循环,但是比较繁琐)\n\n    >>> L = []\n    >>> for x in range(1, 11):\n    ...    L.append(x * x)\n    ...\n    >>> L\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]    \n  \n方法二:  \n  \n    >>> [x * x for x in range(1, 11)]\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \n写列表生成式时,把要生成的元素x * x放到前面,后面跟for循环,就可以把list创建出来.此外,for循环后面还可以加上if判断,这样我们就可以筛选出仅偶数的平方,比如\n     \n    >>> [x * x for x in range(1, 11) if x % 2 == 0]\n    [4, 16, 36, 64, 100]\n    \n还可以使用两层循环,可以生成全排列:\n\n    >>> [m + n for m in 'ABC' for n in 'XYZ']\n    ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n    \n列表生成式也可以使用两个变量来生成list:\n\n    >>> d = {'x': 'A', 'y': 'B', 'z': 'C' }\n    >>> [k + '=' + v for k, v in d.items()]\n    ['y=B', 'x=A', 'z=C']\n    \n最后把一个list中所有的字符串变成小写:\n\n    >>> L = ['Hello', 'World', 'IBM', 'apple']\n    >>> [s.lower() for s in L]\n    ['hello', 'world', 'ibm', 'apple']   \n     \n使用内建的isinstance函数可以判断一个变量是不是字符串:\n\n    >>> x = 'abc'\n    >>> y = 123\n    >>> isinstance(x, str)\n    True\n    >>> isinstance(y, str)\n    False    \n      \n### 小结\nPython的语法对矩阵的表示太友好了.  \n   \n## 生成器\n通过列表生成式,可以直接创建一个列表.但是,受到内存限制,列表容量肯定是有限.假如创建一个包含100万个元素的列表,不仅占用很大的存储空间,如果我们仅仅需要访问前面几个元素,那后面绝大多数元素占用的空间都白白浪费了.\n\n如果列表元素可以按照某种算法推算出来,那我们是否可以在循环的过程中不断推算出后续的元素呢?这样就不必创建完整的list,从而节省大量的空间.\n\n在Python中,这种一边循环一边计算的机制,称为生成器:generator.\n\n### 创建生成器方法\n方法一:有个简单的方法,把一个列表生成式的[]改成(),就创建了一个生成器\n\n    >>> L = [x * x for x in range(10)]\n    >>> L\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n    >>> g = (x * x for x in range(10))\n    >>> g\n    \n其中L是一个列表,而g是一个生成器;\n一般情况下,我们可以直接打印出List,而生成器要用何方法打印呢?可以用next()函数;\n\n    >>> next(g)\n    0\n    >>> next(g)\n    1\n    >>> next(g)\n    4\n    >>> next(g)\n    9\n    >>> next(g)\n    16\n    >>> next(g)\n    25\n    >>> next(g)\n    36\n    >>> next(g)\n    49\n    >>> next(g)\n    64\n    >>> next(g)\n    81\n    >>> next(g)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    StopIteration\n    \n为何每次都只打印一个值的原因是:generator保存的是算法,每次调用next(g),就计算出g的下一个元素的值,直到计算到最后一个元素,没有更多的元素时,抛出StopIteration的错误.所以是符合我们之前对generator的定义和最初要求的.\n\n当然逐个打印出来的方法显得略笨,同样可以用for循环来操作打印\n\n    >>> g = (x * x for x in range(10))\n    >>> for n in g:\n    ...     print(n)\n    ... \n    0\n    1\n    4\n    9\n    16\n    25\n    36\n    49\n    64\n    81\n    \n对于generator来说,如果推算的算法比较复杂,用类似列表生成式的for循环无法实现的时候,还可以用函数来实现.\n\n这里有个典型的例子:\n斐波拉契数列函数如下\n\n    def fib(max):\n        n, a, b = 0, 0, 1\n        while n < max:\n            print(b)\n            \n            a, b = b, a + b   #这一句相当于下面的注释的三句代码\n            #t = (b, a + b)   # t是一个tuple\n            #a = t[0]\n            #b = t[1]\n            \n            n = n + 1\n        return 'done'\n \nfib函数实际上是定义了斐波拉契数列的推算规则,可以从第一个元素开始,推算出后续任意的元素,这其实非常类似generator的思想,且达到了generator的意义;\n\n对于另一种生成器的创建方法就是:改写函数,当一个函数中含有关键字yield的时候,那么这个函数就不是一个普通函数,值得注意的是generator和函数的区别:函数是顺序执行,遇到return语句或者最后一行函数语句就返回.而generator函数,在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行.\n\n    def fib(max):\n            n, a, b = 0, 0, 1\n            while n < max:\n                yield b\n                \n                a, b = b, a + b   #这一句相当于下面的注释的三句代码\n                #t = (b, a + b)   # t是一个tuple\n                #a = t[0]\n                #b = t[1]\n                \n                n = n + 1\n            return 'done'\n \n用for循环调用generator时,如果拿不到generator的return语句的返回值,且又想要拿到返回值,那就需要捕获StopIteration错误,返回值包含在StopIteration的value中;\n\n    >>> g = fib(6)\n    >>> while True:\n    ...     try:\n    ...         x = next(g)\n    ...         print('g:', x)\n    ...     except StopIteration as e:\n    ...         print('Generator return value:', e.value)\n    ...         break\n    ...\n    g: 1\n    g: 1\n    g: 2\n    g: 3\n    g: 5\n    g: 8\n    Generator return value: done    \n    \n### 小结\n在Python中,可以简单地把列表生成式改成generator,也可以通过函数实现复杂逻辑的generator.\n要理解generator的工作原理,它是在for循环的过程中不断计算出下一个元素,并在适当的条件结束for循环.对于函数改成的generator来说,遇到return语句或者执行到函数体最后一行语句,就是结束generator的指令,for循环随之结束.\n\n\n## 迭代器\n直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型,如list、tuple、dict、set、str等;\n一类是generator,包括生成器和带yield的generator function.\n这些可以直接作用于for循环的对象统称为可迭代对象:Iterable.\n\n    >>> from collections import Iterable\n    >>> isinstance([], Iterable)\n    True\n    >>> isinstance({}, Iterable)\n    True\n    >>> isinstance('abc', Iterable)\n    True\n    >>> isinstance((x for x in range(10)), Iterable)\n    True\n    >>> isinstance(100, Iterable)\n    False\n\n生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出StopIteration错误表示无法继续返回下一个值了.\n可以被next()函数调用并不断返回下一个值的对象称为迭代器:Iterator.\n可以使用isinstance()判断一个对象是否是Iterator对象.\n\n    >>> from collections import Iterator\n    >>> isinstance((x for x in range(10)), Iterator)\n    True\n    >>> isinstance([], Iterator)\n    False\n    >>> isinstance({}, Iterator)\n    False\n    >>> isinstance('abc', Iterator)\n    False\n    \n生成器都是Iterator对象,但list、dict、str虽然是Iterable(可迭代的),却不是Iterator(迭代器).\n\n但是要把list、dict、str等Iterable变成Iterator可以使用iter()函数:\n\n    >>> isinstance(iter([]), Iterator)\n    True\n    >>> isinstance(iter('abc'), Iterator)\n    True\n    \n因为Python的Iterator对象表示的是一个数据流,Iterator对象可以被next()函数调用并不断返回下一个数据,直到没有数据时抛出StopIteration错误.可以把这个数据流看做是一个有序序列,但我们却不能提前知道序列的长度,只能不断通过next()函数实现按需计算下一个数据,所以Iterator的计算是惰性的,只有在需要返回下一个数据时它才会计算.\nIterator甚至可以表示一个无限大的数据流,例如全体自然数.而使用list是永远不可能存储全体自然数的.\n\n### 小结\n凡是可作用于for循环的对象都是Iterable类型;\n凡是可作用于next()函数的对象都是Iterator类型,它们表示一个惰性计算的序列;\n集合数据类型如list、dict、str等是Iterable但不是Iterator,不过可以通过iter()函数获得一个Iterator对象.\nPython的for循环本质上就是通过不断调用next()函数实现的,例如:\n\n    for x in [1, 2, 3, 4, 5]:\n        pass\n        \n等价于：  \n   \n    # 首先获得Iterator对象:\n    it = iter([1, 2, 3, 4, 5])\n    # 循环:\n    while True:\n        try:\n            # 获得下一个值:\n            x = next(it)\n        except StopIteration:\n            # 遇到StopIteration就退出循环\n            break  \n\n\n\n\n\n\n","updated":"2017-12-26T03:56:54.154Z","permalink":"http://yoursite.com/2017/12/16/Python05/","categories":[],"tags":[{"name":"Python 高级特性","slug":"Python-高级特性","permalink":"http://yoursite.com/tags/Python-高级特性/"}]},{"title":"Python04","date":"2017-12-15T08:55:18.000Z","path":"2017/12/15/Python04/","text":"递归函数在函数内部,可以调用其他函数.如果一个函数在内部调用自身本身,这个函数就是递归函数.递归函数的优点是定义简单,逻辑清晰.理论上,所有的递归函数都可以写成循环的方式,但循环的逻辑不如递归清晰.使用递归函数需要注意防止栈溢出.在计算机中,函数调用是通过栈（stack）这种数据结构实现的,每当进入一个函数调用,栈就会加一层栈帧,每当函数返回,栈就会减一层栈帧.由于栈的大小不是无限的,所以,递归调用的次数过多,会导致栈溢出.解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以,把循环看成是一种特殊的尾递归函数也是可以的.尾递归是指,在函数返回的时候,调用自身本身,并且,return语句不能包含表达式.这样,编译器或者解释器就可以把尾递归做优化,使递归本身无论调用多少次,都只占用一个栈帧,不会出现栈溢出的情况.尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出.使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.Python标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题. 示例计算: n! = 1 2 3 … n def factor(n): if n == 1: return 1 return n * factor(n-1) 上面这种写法虽然用递归处理了,但是优化不够,没有做尾递归优化,上面的factor(n)函数由于return n * factor(n - 1) 引入了乘法表达式,所以就不是尾递归了.要改成尾递归方式,需要多一点代码,主要是要把每一步的乘积传入到递归函数中,如下: def factor(n): return factor_iteration(n, 1) def factor_iteration(num, product): if num == 1: return product return factor_iteration(num - 1, num * product) 由于 return factor_iteration(num - 1, num product) 仅返回递归函数本身, num - 1和num product在函数调用前就会被计算,进而不影响函数调用. 尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出. 小结使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.Python标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题.","raw":"---\ntitle: Python04\ndate: 2017-12-15 16:55:18\ncategories:\ntoc: ture\ntags:\n     - Python 递归函数\n---\n\n# 递归函数\n在函数内部,可以调用其他函数.如果一个函数在内部调用自身本身,这个函数就是递归函数.\n递归函数的优点是定义简单,逻辑清晰.理论上,所有的递归函数都可以写成循环的方式,但循环的逻辑不如递归清晰.\n使用递归函数需要注意防止栈溢出.在计算机中,函数调用是通过栈（stack）这种数据结构实现的,每当进入一个函数调用,栈就会加一层栈帧,每当函数返回,栈就会减一层栈帧.由于栈的大小不是无限的,所以,递归调用的次数过多,会导致栈溢出.\n解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以,把循环看成是一种特殊的尾递归函数也是可以的.\n尾递归是指,在函数返回的时候,调用自身本身,并且,return语句不能包含表达式.这样,编译器或者解释器就可以把尾递归做优化,使递归本身无论调用多少次,都只占用一个栈帧,不会出现栈溢出的情况.\n尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出.\n使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.\n针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.\nPython标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题.\n\n<!--more-->\n\n## 示例\n计算: n! = 1 * 2 * 3 * ... * n \n     \n     def factor(n):\n        if n == 1:\n           return 1\n        return n * factor(n-1)\n\n上面这种写法虽然用递归处理了,但是优化不够,没有做尾递归优化,上面的factor(n)函数由于return n * factor(n - 1) 引入了乘法表达式,所以就不是尾递归了.要改成尾递归方式,需要多一点代码,主要是要把每一步的乘积传入到递归函数中,如下:\n   \n      def factor(n):\n         return factor_iteration(n, 1)\n        \n      def factor_iteration(num, product):\n         if num == 1:\n            return product\n         return factor_iteration(num - 1, num * product)          \n\n由于 return factor_iteration(num - 1, num * product) 仅返回递归函数本身, num - 1和num * product在函数调用前就会被计算,进而不影响函数调用.     \n\n尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出.   \n\n## 小结\n使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出.\n针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.\nPython标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题.\n\n","updated":"2017-12-26T03:56:39.009Z","permalink":"http://yoursite.com/2017/12/15/Python04/","categories":[],"tags":[{"name":"Python 递归函数","slug":"Python-递归函数","permalink":"http://yoursite.com/tags/Python-递归函数/"}]},{"title":"Python03","date":"2017-12-13T08:04:54.000Z","path":"2017/12/13/Python03/","text":"调用函数要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs,只有一个参数.调用函数的时候,如果传入的参数数量不对,会报TypeError的错误,并且Python会明确地告诉你:abs()有且仅有1个参数,但给出了两个.如果传入的参数数量是对的,但参数类型不能被函数所接受,也会报TypeError的错误,并且给出错误信息.Python在数据转换的时候,也可以用数据类型转换函数.函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,相当于给这个函数起了一个“别名”. 定义函数Python中,定义一个函数要使用def语句,依次写出函数名、括号、括号中的参数和冒号:,然后,在缩进块中编写函数体,函数的返回值用return语句返回.函数体内部的语句在执行时,一旦执行到return时,函数就执行完毕,并将结果返回.如果没有return语句,函数执行完毕后也会返回结果,只是结果为None,return None可以简写为return.如果想定义一个什么事也不做的空函数,可以用pass语句,pass语句什么都不做,那有什么用？实际上pass可以用来作为占位符,比如现在还没想好怎么写函数的代码,就可以先放一个pass,让代码能运行起来.缺少了pass，代码运行就会有语法错误.PS:此处的pass其实相当于别的语言里的空实现,OC/C/Cpp中的空实现,可以不写任何代码或者放任不管不执行,而Python为了达到这一目的,需要用关键词pass来处理. 参数检查调用函数时,如果参数个数不对,Python解释器会自动检查出来,并抛出TypeError.但是如果参数类型不对,Python解释器就无法检查.所以对参数类型做检查,例如只允许整数和浮点数类型的参数会给我们避免很多错误.数据类型检查可以用内置函数isinstance()实现. 返回多个值Python的函数返回多值其实就是返回一个tuple,按照参数位置顺序取值即可 小结定义函数时,需要确定函数名和参数个数;如果有必要,可以先对参数的数据类型做检查;函数体内部可以用return随时返回函数结果;函数执行完毕也没有return语句时,自动return None.函数可以同时返回多个值,但其实就是一个tuple. 函数的参数Python的函数定义非常简单,但灵活度却非常大.除了正常定义的必选参数外,还可以使用默认参数、可变参数和关键字参数,使得函数定义出来的接口,不但能处理复杂的参数,还可以简化调用者的代码. 位置参数power(x, n)函数有两个参数,x和n都是位置参数 默认参数def power(x, n=2): 这里的n是默认参数默认参数可以简化函数的调用.设置默认参数时,要注意:一是必选参数在前,默认参数在后,否则Python的解释器会报错;二当函数有多个参数时,把变化大的参数放前面,变化小的参数放后面.变化小的参数就可以作为默认参数.PS:默认参数必须指向不变对象.不变对象一旦创建,对象内部的数据就不能修改,这样就减少了由于修改数据导致的错误.此外,由于对象不变,多任务环境下同时读取对象不需要加锁,同时读一点问题都没有.我们在编写程序时,如果可以设计一个不变对象,那就尽量设计成不变对象. 可变参数&gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 *nums表示把nums这个list的所有元素作为可变参数传进去. 关键字参数可变参数允许传入0个或任意个参数,这些可变参数在函数调用时自动组装为一个tuple.而关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict.关键字参数有什么用？它可以扩展函数的功能. &gt;&gt;&gt; extra = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} &gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra) name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数,kw将获得一个dict,注意kw获得的dict是extra的一份拷贝,对kw的改动不会影响到函数外的extra. 命名关键字参数对于关键字参数,函数的调用者可以传入任意不受限制的关键字参数.至于到底传入了哪些,就需要在函数内部通过kw检查. def person(name, age, **kw): if &apos;city&apos; in kw: # 有city参数 pass if &apos;job&apos; in kw: # 有job参数 pass print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 如果要限制关键字参数的名字,就可以用命名关键字参数.和关键字参数**kw不同,命名关键字参数需要一个特殊分隔符*,*后面的参数被视为命名关键字参数. &gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;) Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数,后面跟着的命名关键字参数就不再需要一个特殊分隔符*了: def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名,这和位置参数不同.如果没有传入参数名,调用将报错. 使用命名关键字参数时,要特别注意,如果没有可变参数,就必须加一个*作为特殊分隔符.如果缺少*,Python解释器将无法识别位置参数和命名关键字参数 def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass 参数组合在Python中定义函数,可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数,这5种参数都可以组合使用.但是请注意,参数定义的顺序必须是:必选参数、默认参数、可变参数、命名关键字参数和关键字参数.所以,对于任意函数,都可以通过类似func(*args, **kw)的形式调用它,无论它的参数是如何定义的.虽然可以组合多达5种参数,但不要同时使用太多的组合,否则函数接口的可理解性很差. 小结Python的函数具有非常灵活的参数形态,既可以实现简单的调用,又可以传入非常复杂的参数.默认参数一定要用不可变对象,如果是可变对象,程序运行时会有逻辑错误!要注意定义可变参数和关键字参数的语法:*args是可变参数,args接收的是一个tuple;**kw是关键字参数,kw接收的是一个dict. 以及调用函数时如何传入可变参数和关键字参数的语法:可变参数既可以直接传入:func(1, 2, 3),又可以先组装list或tuple,再通过*args传入:func(*(1, 2, 3));关键字参数既可以直接传入:func(a=1, b=2),又可以先组装dict,再通过**kw传入：func(**{‘a’: 1, ‘b’: 2}). 使用*args和**kw是Python的习惯写法,当然也可以用其他参数名,但最好使用习惯用法.命名的关键字参数是为了限制调用者可以传入的参数名,同时可以提供默认值.定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*,否则定义的将是位置参数.","raw":"---\ntitle: Python03\ndate: 2017-12-13 16:04:54\ncategories:\ntoc: ture\ntags:\n     - Python 函数\n---\n\n## 调用函数\n要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs,只有一个参数.\n调用函数的时候,如果传入的参数数量不对,会报TypeError的错误,并且Python会明确地告诉你:abs()有且仅有1个参数,但给出了两个.\n如果传入的参数数量是对的,但参数类型不能被函数所接受,也会报TypeError的错误,并且给出错误信息.\nPython在数据转换的时候,也可以用数据类型转换函数.\n函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,相当于给这个函数起了一个“别名”.\n\n## 定义函数\nPython中,定义一个函数要使用def语句,依次写出函数名、括号、括号中的参数和冒号:,然后,在缩进块中编写函数体,函数的返回值用return语句返回.\n函数体内部的语句在执行时,一旦执行到return时,函数就执行完毕,并将结果返回.\n如果没有return语句,函数执行完毕后也会返回结果,只是结果为None,return None可以简写为return.\n如果想定义一个什么事也不做的空函数,可以用pass语句,pass语句什么都不做,那有什么用？实际上pass可以用来作为占位符,比如现在还没想好怎么写函数的代码,就可以先放一个pass,让代码能运行起来.\n缺少了pass，代码运行就会有语法错误.\nPS:此处的pass其实相当于别的语言里的空实现,OC/C/Cpp中的空实现,可以不写任何代码或者放任不管不执行,而Python为了达到这一目的,需要用关键词pass来处理.\n\n### 参数检查\n调用函数时,如果参数个数不对,Python解释器会自动检查出来,并抛出TypeError.但是如果参数类型不对,Python解释器就无法检查.所以对参数类型做检查,例如只允许整数和浮点数类型的参数会给我们避免很多错误.数据类型检查可以用内置函数isinstance()实现.\n\n### 返回多个值\nPython的函数返回多值其实就是返回一个tuple,按照参数位置顺序取值即可\n\n### 小结\n定义函数时,需要确定函数名和参数个数;\n如果有必要,可以先对参数的数据类型做检查;\n函数体内部可以用return随时返回函数结果;\n函数执行完毕也没有return语句时,自动return None.\n函数可以同时返回多个值,但其实就是一个tuple.\n\n\n\n<!--more-->\n\n\n\n## 函数的参数\nPython的函数定义非常简单,但灵活度却非常大.除了正常定义的必选参数外,还可以使用默认参数、可变参数和关键字参数,使得函数定义出来的接口,不但能处理复杂的参数,还可以简化调用者的代码.\n\n### 位置参数\npower(x, n)函数有两个参数,x和n都是位置参数\n### 默认参数\ndef power(x, n=2):   这里的n是默认参数\n默认参数可以简化函数的调用.设置默认参数时,要注意:\n一是必选参数在前,默认参数在后,否则Python的解释器会报错;\n二当函数有多个参数时,把变化大的参数放前面,变化小的参数放后面.变化小的参数就可以作为默认参数.\nPS:默认参数必须指向不变对象.不变对象一旦创建,对象内部的数据就不能修改,这样就减少了由于修改数据导致的错误.此外,由于对象不变,多任务环境下同时读取对象不需要加锁,同时读一点问题都没有.我们在编写程序时,如果可以设计一个不变对象,那就尽量设计成不变对象.\n\n### 可变参数\n\n    >>> nums = [1, 2, 3]\n    >>> calc(*nums)\n    14\n    \n*nums表示把nums这个list的所有元素作为可变参数传进去.\n\n### 关键字参数\n可变参数允许传入0个或任意个参数,这些可变参数在函数调用时自动组装为一个tuple.而关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict.关键字参数有什么用？它可以扩展函数的功能.\n\n    >>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n    >>> person('Jack', 24, **extra)\n    name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n    \n\\*\\*extra表示把extra这个dict的所有key-value用关键字参数传入到函数的\\*\\*kw参数,kw将获得一个dict,注意kw获得的dict是extra的一份拷贝,对kw的改动不会影响到函数外的extra.\n\n#### 命名关键字参数\n对于关键字参数,函数的调用者可以传入任意不受限制的关键字参数.至于到底传入了哪些,就需要在函数内部通过kw检查.\n    \n    def person(name, age, **kw):\n        if 'city' in kw:\n            # 有city参数\n            pass\n        if 'job' in kw:\n            # 有job参数\n            pass\n        print('name:', name, 'age:', age, 'other:', kw)\n    \n如果要限制关键字参数的名字,就可以用命名关键字参数.和关键字参数\\*\\*kw不同,命名关键字参数需要一个特殊分隔符\\*,\\*后面的参数被视为命名关键字参数.\n\n     >>> person('Jack', 24, city='Beijing', job='Engineer')\n     Jack 24 Beijing Engineer\n\n如果函数定义中已经有了一个可变参数,后面跟着的命名关键字参数就不再需要一个特殊分隔符*了:\n     \n     def person(name, age, *args, city, job):\n     print(name, age, args, city, job)\n     \n命名关键字参数必须传入参数名,这和位置参数不同.如果没有传入参数名,调用将报错.\n\n使用命名关键字参数时,要特别注意,如果没有可变参数,就必须加一个\\*作为特殊分隔符.如果缺少\\*,Python解释器将无法识别位置参数和命名关键字参数   \n     \n     def person(name, age, city, job):\n        # 缺少 *，city和job被视为位置参数\n        pass\n\n### 参数组合\n在Python中定义函数,可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数,这5种参数都可以组合使用.但是请注意,参数定义的顺序必须是:必选参数、默认参数、可变参数、命名关键字参数和关键字参数.所以,对于任意函数,都可以通过类似func(\\*args, \\*\\*kw)的形式调用它,无论它的参数是如何定义的.虽然可以组合多达5种参数,但不要同时使用太多的组合,否则函数接口的可理解性很差.\n\n### 小结\nPython的函数具有非常灵活的参数形态,既可以实现简单的调用,又可以传入非常复杂的参数.\n默认参数一定要用不可变对象,如果是可变对象,程序运行时会有逻辑错误!\n要注意定义可变参数和关键字参数的语法:\n\\*args是可变参数,args接收的是一个tuple;\n\\*\\*kw是关键字参数,kw接收的是一个dict.\n\n以及调用函数时如何传入可变参数和关键字参数的语法:\n可变参数既可以直接传入:func(1, 2, 3),又可以先组装list或tuple,再通过\\*args传入:func(\\*(1, 2, 3));\n关键字参数既可以直接传入:func(a=1, b=2),又可以先组装dict,再通过\\*\\*kw传入：func(\\*\\*{'a': 1, 'b': 2}).\n\n使用\\*args和\\*\\*kw是Python的习惯写法,当然也可以用其他参数名,但最好使用习惯用法.\n命名的关键字参数是为了限制调用者可以传入的参数名,同时可以提供默认值.\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符\\*,否则定义的将是位置参数.\n\n\n","updated":"2017-12-26T03:56:25.993Z","permalink":"http://yoursite.com/2017/12/13/Python03/","categories":[],"tags":[{"name":"Python 函数","slug":"Python-函数","permalink":"http://yoursite.com/tags/Python-函数/"}]},{"title":"Python02","date":"2017-12-05T07:47:13.000Z","path":"2017/12/05/Python02/","text":"list (列表)Python内置一种数据类型是列表:list,list是一种有序的集合,可以随时添加和删除其中的元素;其功效和作用和OC以及swift里的可变数组类似; 用len(xxxx)函数可以获得list元素的个数; 用索引来访问list中每一个位置的元素,索引是从0开始;当索引超出了范围时,Python会报一个IndexError错误,所以,要确保索引不要越界,最后一个元素的索引是len(xxxx) - 1;当用来倒数索引查找的时候,我们可以省略len(xxxx),直接写-1,-2,-3,以此类推; 用append(xxxxxxx)函数可以在list末尾追加元素; 用insert(index,xxxxxxx)函数可以在list中插入元素,且是指定位置插入; 用pop()函数可以删除list末尾的元素; 要删除指定位置的元素,用pop(i)方法,其中i是索引位置; 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置; list里面的元素的数据类型也可以不同; list元素也可以是另一个list; tuple (元组)Python内置另一种有序列表叫元组:tuple,tuple和list非常类似,但是tuple一旦初始化就不能修改;其功效和作用和OC以及swift里的不可变数组类似;tuple没有append()，insert()这样的方法,其他获取元素的方法和list是一样的;因为tuple不可变,所以代码更安全.如果可能,能用tuple代替list就尽量用tuple.当定义一个tuple时,在定义的时候tuple的元素就必须被确定下来;如果要定义一个空的tuple,可以写成();只有1个元素的tuple定义时必须加一个逗号,用来来消除歧义; t(1,) 条件判断elif是else if的缩写 if &lt;条件判断1&gt;: &lt;执行1&gt; elif &lt;条件判断2&gt;: &lt;执行2&gt; elif &lt;条件判断3&gt;: &lt;执行3&gt; else: &lt;执行4&gt; if语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else 循环for in 和 while ;while循环,只要条件满足,就不断循环,条件不满足时退出循环.在循环中,break语句可以提前退出循环.在循环过程中,可以通过continue语句,跳过当前的这次循环,直接开始下一次循环.continue的作用是提前结束本轮循环,并直接开始下一轮循环. dict (dictionary)Python内置了字典：dict的支持,dict全称dictionary,在其他语言中也称为map,使用键-值（key-value）存储,有极快的查找速度.由于一个key只能对应一个value,所以,多次对一个key放入value,后面的值会把前面的值冲掉;如果key不存在,dict就会报错;要避免key不存在的错误,有两种办法:一是通过in判断key是否存在;二是通过dict提供的get()方法,如果key不存在,可以返回None,或者自己指定的value;(返回None的时候Python的交互环境不显示结果)要删除一个key,用pop(key)方法,对应的value也会从dict中删除; 和list比较,dict有以下几个特点: 查找和插入的速度极快,不会随着key的增加而变慢;需要占用大量的内存,内存浪费多.而list相反:查找和插入的时间随着元素的增加而增加;占用空间小,浪费内存很少. 所以,dict是用空间来换取时间的一种方法. dict通过Key找Value的位置遵循的是哈希算法,所以同时也就要求了dict的Key必须具有唯一性,所以dict的Key是一个不可变对象且唯一,要保证hash的正确性,作为key的对象就不能变.在Python中,字符串、整数等都是不可变的,因此,可以放心地作为key.而list是可变的,就不能作为key; setset和dict类似,也是一组key的集合,但不存储value.由于key不能重复,所以,在set中,没有重复的key.通过add(key)方法可以添加元素到set中,可以重复添加,但不会有效果.通过remove(key)方法可以删除元素.set可以看成数学意义上的无序和无重复元素的集合,因此,两个set可以做数学意义上的交集/并集等操作(&amp; 取交集, | 取并集).","raw":"---\ntitle: Python02\ndate: 2017-12-05 15:47:13\ncategories:\ntoc: ture\ntags:\n     - Python 数据结构\n     - Python 条件判断循环\n---\n\n## list (列表)\nPython内置一种数据类型是列表:list,list是一种有序的集合,可以随时添加和删除其中的元素;\n其功效和作用和OC以及swift里的可变数组类似;\n\n用len(xxxx)函数可以获得list元素的个数;\n\n用索引来访问list中每一个位置的元素,索引是从0开始;当索引超出了范围时,Python会报一个IndexError错误,所以,要确保索引不要越界,最后一个元素的索引是len(xxxx) - 1;当用来倒数索引查找的时候,我们可以省略len(xxxx),直接写-1,-2,-3,以此类推;\n\n用append(xxxxxxx)函数可以在list末尾追加元素;\n\n用insert(index,xxxxxxx)函数可以在list中插入元素,且是指定位置插入;\n\n用pop()函数可以删除list末尾的元素;\n\n要删除指定位置的元素,用pop(i)方法,其中i是索引位置;\n\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置;\n\nlist里面的元素的数据类型也可以不同;\n\nlist元素也可以是另一个list;\n\n## tuple (元组)\nPython内置另一种有序列表叫元组:tuple,tuple和list非常类似,但是tuple一旦初始化就不能修改;\n其功效和作用和OC以及swift里的不可变数组类似;\ntuple没有append()，insert()这样的方法,其他获取元素的方法和list是一样的;\n因为tuple不可变,所以代码更安全.如果可能,能用tuple代替list就尽量用tuple.\n当定义一个tuple时,在定义的时候tuple的元素就必须被确定下来;\n如果要定义一个空的tuple,可以写成();\n只有1个元素的tuple定义时必须加一个逗号,用来来消除歧义;\n    \n    t(1,) \n    \n   \n   \n<!--more-->\n\n    \n## 条件判断\nelif是else if的缩写\n\n    if <条件判断1>:\n         <执行1>\n    elif <条件判断2>:\n         <执行2>\n    elif <条件判断3>:\n         <执行3>\n    else:\n         <执行4>\n    \nif语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else   \n\n## 循环\nfor in 和 while ;\nwhile循环,只要条件满足,就不断循环,条件不满足时退出循环.\n在循环中,break语句可以提前退出循环.\n在循环过程中,可以通过continue语句,跳过当前的这次循环,直接开始下一次循环.continue的作用是提前结束本轮循环,并直接开始下一轮循环.\n\n## dict (dictionary)\nPython内置了字典：dict的支持,dict全称dictionary,在其他语言中也称为map,使用键-值（key-value）存储,有极快的查找速度.\n由于一个key只能对应一个value,所以,多次对一个key放入value,后面的值会把前面的值冲掉;如果key不存在,dict就会报错;\n要避免key不存在的错误,有两种办法:\n一是通过in判断key是否存在;\n二是通过dict提供的get()方法,如果key不存在,可以返回None,或者自己指定的value;\n(返回None的时候Python的交互环境不显示结果)\n要删除一个key,用pop(key)方法,对应的value也会从dict中删除;\n\n和list比较,dict有以下几个特点:\n\n查找和插入的速度极快,不会随着key的增加而变慢;\n需要占用大量的内存,内存浪费多.\n而list相反:\n查找和插入的时间随着元素的增加而增加;\n占用空间小,浪费内存很少.\n\n所以,dict是用空间来换取时间的一种方法.\n\ndict通过Key找Value的位置遵循的是哈希算法,所以同时也就要求了dict的Key必须具有唯一性,所以dict的Key是一个不可变对象且唯一,要保证hash的正确性,作为key的对象就不能变.在Python中,字符串、整数等都是不可变的,因此,可以放心地作为key.而list是可变的,就不能作为key;\n\n## set\nset和dict类似,也是一组key的集合,但不存储value.由于key不能重复,所以,在set中,没有重复的key.\n通过add(key)方法可以添加元素到set中,可以重复添加,但不会有效果.\n通过remove(key)方法可以删除元素.\nset可以看成数学意义上的无序和无重复元素的集合,因此,两个set可以做数学意义上的交集/并集等操作\n(& 取交集, | 取并集).\n\n\n","updated":"2017-12-26T03:56:10.869Z","permalink":"http://yoursite.com/2017/12/05/Python02/","categories":[],"tags":[{"name":"Python 数据结构","slug":"Python-数据结构","permalink":"http://yoursite.com/tags/Python-数据结构/"},{"name":"Python 条件判断循环","slug":"Python-条件判断循环","permalink":"http://yoursite.com/tags/Python-条件判断循环/"}]},{"title":"Python01","date":"2017-11-29T03:22:20.000Z","path":"2017/11/29/Python01/","text":"Python基础Python的语法比较简单，采用缩进方式 实例: #这里是注释,可以写随便的内容,Python的注释采用# #Python的每一行都是一个语句,假如语句以:结尾,其后缩进的语句相当于代码块 #Python缩进多少个空格还是一个tab的长度呢,没有明确规定,但是约定俗成采用 4 个空格缩进 #为了方便在文本编辑器中，把Tab自动转换为4个空格，确保不混用Tab和空格,可以提高编写效率 #缩进的坏处就是“复制－粘贴”功能失效 #当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确 #此外，ide很难像格式化Java代码那样格式化Python代码 #PS:Python程序是大小写敏感的，是区分大小写的 a = 100 if a &gt;= 0: print(a) else: print(-a) 数据类型1.整数有正负,是精确值,即时是做除法运算也是精确值;2.浮点数,Python支持科学计数法,1.23x109和12.3x108是等同的,在Python上书写用e来代替进位10,也即1.23e9;3.字符串用一对双引号或者一对单引号,即’’或””;当字符串内部也包含’或者”的时候,和C语言一样,需要用转义字符; 如果字符串里面有很多字符都需要转义,就需要加很多\\,为了简化,Python还允许用r’’表示’’内部的字符串默认不转义; 如果字符串内部有很多换行,用\\n写在一行里不好阅读,为了简化,Python允许用’’’…’’’的格式表示多行内容; 注意在输入多行内容时,提示符由&gt;&gt;&gt;变为…,提示你可以接着上一行输入,注意…是提示符,不是代码的一部分;4.布尔值和布尔代数的表示完全一致,一个布尔值只有True、False两种值,要么是True,要么是False,在Python中,可以直接用True、False表示布尔值（请注意大小写）,也可以通过布尔运算计算出来; 布尔值可以用and、or和not运算,对应逻辑里的且或非;5.空值,空值是Python里一个特殊的值,用None表示; 变量语言中的变量的含义和中学课本中的变量的含义表示的内容和意义是一致的;同时变量类型本身不固定的语言多称为动态语言;但是这并不是100%的界定固定的东西,OC和Java在表面上都是静态语言,它们都同时符合静态语言的规定特征,但是OC和Java其实本质上都是动态语言,这是跟具体的语言特性还有关系,OC的Runtime Programming和Java的反射机制; PS:常量常量的本质是不变的变量; 小结:Python在处理整数的时候,它的可精确表达范围要比C语言还大,因为本质上Python直接是用比long long还要大的范围来进行二进制操作的,而对于浮点数而言,所有语言都一样,这是有限内存运算和无限无理数之间的战争 字符编码在最新的Python 3版本中,字符串是以Unicode编码的,也就是说,Python的字符串支持多语言. 格式化Python中,采用的格式化方式和C语言是一致的,用%实现. &gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos; &apos;Hello, world&apos; &gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) &apos;Hi, Michael, you have $1000000.&apos; 有几个%?占位符,后面就跟几个变量或者值,顺序要对应好.如果只有一个%?,括号可以省略.","raw":"---\ntitle: Python01\ndate: 2017-11-29 11:22:20\ncategories:\ntoc: ture\ntags:\n     - Python 基础\n---\n\n# Python基础\n## Python的语法比较简单，采用缩进方式\n 实例:\n    \n    #这里是注释,可以写随便的内容,Python的注释采用#\n    #Python的每一行都是一个语句,假如语句以:结尾,其后缩进的语句相当于代码块\n    #Python缩进多少个空格还是一个tab的长度呢,没有明确规定,但是约定俗成采用 4 个空格缩进\n    #为了方便在文本编辑器中，把Tab自动转换为4个空格，确保不混用Tab和空格,可以提高编写效率\n    #缩进的坏处就是“复制－粘贴”功能失效\n    #当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确\n    #此外，ide很难像格式化Java代码那样格式化Python代码\n    #PS:Python程序是大小写敏感的，是区分大小写的\n    \n    a = 100\n    if a >= 0:\n        print(a)\n    else:\n        print(-a)\n\n\n<!--more-->\n\n\n## 数据类型        \n1.整数有正负,是精确值,即时是做除法运算也是精确值;\n2.浮点数,Python支持科学计数法,1.23x109和12.3x108是等同的,在Python上书写用e来代替进位10,也即1.23e9;\n3.字符串用一对双引号或者一对单引号,即''或\"\";当字符串内部也包含'或者\"的时候,和C语言一样,需要用转义字符;\n  如果字符串里面有很多字符都需要转义,就需要加很多\\,为了简化,Python还允许用r''表示''内部的字符串默认不转义;\n  如果字符串内部有很多换行,用\\n写在一行里不好阅读,为了简化,Python允许用'''...'''的格式表示多行内容;\n  注意在输入多行内容时,提示符由>>>变为...,提示你可以接着上一行输入,注意...是提示符,不是代码的一部分;\n4.布尔值和布尔代数的表示完全一致,一个布尔值只有True、False两种值,要么是True,要么是False,在Python中,可以直接用True、False表示布尔值（请注意大小写）,也可以通过布尔运算计算出来;\n  布尔值可以用and、or和not运算,对应逻辑里的且或非;\n5.空值,空值是Python里一个特殊的值,用None表示;\n\n## 变量\n语言中的变量的含义和中学课本中的变量的含义表示的内容和意义是一致的;\n同时变量类型本身不固定的语言多称为动态语言;\n但是这并不是100%的界定固定的东西,OC和Java在表面上都是静态语言,它们都同时符合静态语言的规定特征,但是OC和Java其实本质上都是动态语言,这是跟具体的语言特性还有关系,OC的Runtime Programming和Java的反射机制;\n\nPS:常量\n常量的本质是不变的变量;\n\n小结:\nPython在处理整数的时候,它的可精确表达范围要比C语言还大,因为本质上Python直接是用比long long还要大的范围来进行二进制操作的,而对于浮点数而言,所有语言都一样,这是有限内存运算和无限无理数之间的战争\n\n\n## 字符编码\n在最新的Python 3版本中,字符串是以Unicode编码的,也就是说,Python的字符串支持多语言.\n\n## 格式化\nPython中,采用的格式化方式和C语言是一致的,用%实现.\n\n    >>> 'Hello, %s' % 'world'\n    'Hello, world'\n    >>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n    'Hi, Michael, you have $1000000.'\n    \n有几个%?占位符,后面就跟几个变量或者值,顺序要对应好.如果只有一个%?,括号可以省略.\n\n\n\n\n        \n\n","updated":"2017-12-26T03:54:58.387Z","permalink":"http://yoursite.com/2017/11/29/Python01/","categories":[],"tags":[{"name":"Python 基础","slug":"Python-基础","permalink":"http://yoursite.com/tags/Python-基础/"}]},{"title":"我能做些什么和我打算做些什么","date":"2017-11-27T08:55:01.000Z","path":"2017/11/27/我能做些什么和我打算做些什么/","text":"周末，就着3.0版本上架空档期，也感谢组织没有给我额外的任务，让我愉快的放松了两天，其实这两天陪姑娘逛杭州的时候，心里一直在思忖着：我能做些什么和我打算做些什么。 其实说实话，蛮多的感慨，因为我跟团队大部分人可能并不那么特别相似，其实2月份决定来放弃所有的合肥其他的offer来飞修更大的原因是项目的可行性和项目的公益性，项目可行我们已经用这么长的时间进行了验证，可能你们都没想到我会说项目的公益性，我觉得一个项目的公益性在于，假如我们做大了，我们可以给更多的人带来福利，这是做实业，是在建设和谐的社会主义不是么？会让你在跟别人聊天的时候，从你身上透露着你在兼善天下的牛逼感。 我觉得做好一个东西并不容易，日复一日的为此付出除了实现个人的财务自由挣票子之后，更多的是兴趣和热情的驱动，没有诚挚赤裸的心，是没法做成一件事的，只能浮于表面最终消亡。 那天中午，乐一歪着头问我：面试不用拘谨你抽烟的吧，来一根。 我笑着接过烟点上。 我心里多多少少明白，一个乐于跟你分享的领导，不论他以后变得怎样，但是起码现在不坏，如果你觉得跟他干没意义，可以先干着以后再走。这是我第一感觉。 他说我们在做一个维修项目，要整合合肥维修市场，我们拿到了老乡鸡的投资了，暂时有钱，只要能活过第二年，其他都没问题，包括给你双休。 我说挺好，能开到税后8K么，乐一说他要是不行的话，自己拿工资贴。（最后不用猜，绝对是狗白和小智拒绝了我的税后8K的要求。）即使后来给我电话讲：要是税前8K不能接受的话，那可能不行了，我们团队都是这个薪资，其他人不能同意。 说真的，那个时候我只用一个理由说服了我自己：行吧，离我姑娘很近，并不是所有的公司都能离我姑娘只有500米不到的距离。 所以我曾多次问过我自己，如果我在外漂泊，在最要奋斗的年纪，为了家庭来到合肥，如果是这辈子最正确的一件事，那么来到飞修也终将是一个以后能津津乐道的缘分。 我不曾抱着最大的恶意揣测任何人，也不曾有意诋毁任何人的能力，那是因为当你一开始用一种有缘，年轻，轻松，是件有意义的事来到一个团队的时候，你难免会对自己也好，对和你配合的人员也好，有种过高的期许，所以不可避免说了挺多比较没太给面子的话，我偶尔想想我是不是年纪越往后走，耐心变得是足够了，但是是不是期许也变得越来越大了，还是说这个团队还有很长的路要走，我们还需要更多的相互了解。我希望我这么久以来战斗而来的东西，都是有意义而被后来接手人能更好的利用，而不是像我，舔着刀口行走。 而作为一个客户端开发者，直接跟UI/产品/其他技术团队直接打交到且对配合人员期许较高的时候，之前难免会有点小摩擦，今天得空深刻总结反省，有幸是这些变化都让我们配合的更佳好，矛盾也能及时解决，这令我感到倍感欣慰，会让你觉得你既往所付出的心血，都如此值得，也能笑着为此开心。 今天是我来飞修整整9个月时间，9个月我觉得乐一让我从单休变成了单双休，兑现了他当初跟我讲的让我双休的一半，趁我还是在能加得动班的年纪，我觉这个老板还不坏，也想说这个朋友还不坏，即便哪天不再是老板和员工的关系，也能成为很好的朋友，能遇到一个守信的老板，且和你年纪一样的时候，你要想的是他身上有哪些闪光的东西是你能学的，并为此遇见感到高兴。 9个月的时间里，我只做了一点点卑微的工作，将飞修的客户端从1.0跌代到3.0，没有骄人的成绩，也没有突出的贡献，遵守本分，唯一觉得心里高兴的无非就是赶进度的同时，也能交的出去一份不算质量低的代码；如果需要我给我这9个月的工作打分，我能打9分，最后的1分我保留给刘欢，如果能在接下来的半年里带出来另一个娴熟的客户端开发的话，我觉得，那个时候我的工作是能打10分的，打10分意味着，我对得起老板给我创造的所有优秀的环境，给我发的每一分钱薪水。 从11月初，我就在问自己：假如有一天你能放下所有的事情，真去做一件事情不考虑薪水，不考虑环境的话，你愿意做什么？我想我可能会去做一个科学家研究那些年想做的物理课题研究。那么除了这个呢？做算法吧。 这些年还能激荡起心中热情的二件事，我庆幸还没有变。 飞修团队越来越大，每个岗位上的螺丝钉都要拧紧，然后尽自己最大的能力做好自己的份内的事情，要么被替换，要么收拾行囊离开，每天不虚度时光而过的有意义，你且需要的就是把自己最大热情度能投入的事情和你的工作相结合，如果刚刚好公司也是需要的，那么恭喜你，能成为一个快乐工作的人。 接下来我想试着往数据分析这个方向走一走，能走多远走多专业不知道，适不适合也不了解，但是唯一能让我感到开心和有信心的是：我还有很大的热忱和兴趣。 基于我现在对数据分析的行业了解：数据分析有两种，一种类似产品经理，类似产品经理向更加注重业务，对业务能力要求比较高；一种偏向数据挖掘，数据挖掘向更加注重技术，对算法代码能力要求比较高。 二者共同需要的技术的入门标准都是： SQL。 统计学基础。 Python或者R的基础。 二者有区别的技能树是： A.产品经理向：需要对业务感知能力强，对数据十分敏感，掌握常用的一些业务分析模型套路。为公司的业务负责的方向有：商业分析、数据运营、用户研究、策略分析等等。 B.数据挖掘向：需要牢固的底层基础，编程语言基础、算法、数据结构、统计学知识样样不能少。 于我而言，我是乐于专向数据挖掘方向的，但是这里有会有一个矛盾的点，我可能要一遍兼顾iOS的同时，也要学习新的领域的东西，对于我而言也是一个挑战。 其实我对自己的期许并不是做到一个数据分析师就行了，我对自己的要求是做到战略型数据分析师，能站在数据的角度引领公司整体战略。通过数据分析对公司业务以及行业前景进行预判，为公司制定战略的时候，给出科学的分析依据。进而推动公司战略发展，且能符合投资人的期望值。 然而我个人觉得，我的其他条件中有一个很重要的条件符合这个岗位：喜欢演讲。 乐于把你捕获的信息释法出去，用“人话”说给别人听，且让人听懂，这是一个重要的能力，一个好的数据分析师及时分析能力超群，不能把分析的结果用言语打动老板，让老板相信你跟你走，那么也是一个形同虚设。 以上这些，是我这二天出去玩的时候思考的结果。也有诸多的感慨，唯一能感受到的就是时间过的真快。昨日之事，历历在目。 此贴留为纪念，日后且看今日决策是否正确如预期。 愿诸君不忘初心，砥砺前行，与君共勉。 有时候想跟你们说：我爱你们，爱你们就像爱生命。（妈卖批，是假的哦！） new APlayer({ element: document.getElementById(\"aplayer1\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"爱你就像爱生命\", author: \"房东的猫\", url: \"http://ozwoorjfp.bkt.clouddn.com/%E6%88%BF%E4%B8%9C%E7%9A%84%E7%8C%AB%20-%20%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD.mp3\", pic: \"\", } });","raw":"---\ntitle: 我能做些什么和我打算做些什么\ndate: 2017-11-27 16:55:01\ncategories:\ntoc: false\ntags:\n    - Essays\n---\n\n周末，就着3.0版本上架空档期，也感谢组织没有给我额外的任务，让我愉快的放松了两天，其实这两天陪姑娘逛杭州的时候，心里一直在思忖着：我能做些什么和我打算做些什么。\n\n其实说实话，蛮多的感慨，因为我跟团队大部分人可能并不那么特别相似，其实2月份决定来放弃所有的合肥其他的offer来飞修更大的原因是项目的可行性和项目的公益性，项目可行我们已经用这么长的时间进行了验证，可能你们都没想到我会说项目的公益性，我觉得一个项目的公益性在于，假如我们做大了，我们可以给更多的人带来福利，这是做实业，是在建设和谐的社会主义不是么？会让你在跟别人聊天的时候，从你身上透露着你在兼善天下的牛逼感。\n\n<!--more-->\n\n我觉得做好一个东西并不容易，日复一日的为此付出除了实现个人的财务自由挣票子之后，更多的是兴趣和热情的驱动，没有诚挚赤裸的心，是没法做成一件事的，只能浮于表面最终消亡。\n\n那天中午，乐一歪着头问我：面试不用拘谨你抽烟的吧，来一根。\n\n我笑着接过烟点上。\n\n我心里多多少少明白，一个乐于跟你分享的领导，不论他以后变得怎样，但是起码现在不坏，如果你觉得跟他干没意义，可以先干着以后再走。这是我第一感觉。\n\n他说我们在做一个维修项目，要整合合肥维修市场，我们拿到了老乡鸡的投资了，暂时有钱，只要能活过第二年，其他都没问题，包括给你双休。\n\n我说挺好，能开到税后8K么，乐一说他要是不行的话，自己拿工资贴。（最后不用猜，绝对是狗白和小智拒绝了我的税后8K的要求。）即使后来给我电话讲：要是税前8K不能接受的话，那可能不行了，我们团队都是这个薪资，其他人不能同意。\n\n说真的，那个时候我只用一个理由说服了我自己：行吧，离我姑娘很近，并不是所有的公司都能离我姑娘只有500米不到的距离。\n\n所以我曾多次问过我自己，如果我在外漂泊，在最要奋斗的年纪，为了家庭来到合肥，如果是这辈子最正确的一件事，那么来到飞修也终将是一个以后能津津乐道的缘分。\n\n我不曾抱着最大的恶意揣测任何人，也不曾有意诋毁任何人的能力，那是因为当你一开始用一种有缘，年轻，轻松，是件有意义的事来到一个团队的时候，你难免会对自己也好，对和你配合的人员也好，有种过高的期许，所以不可避免说了挺多比较没太给面子的话，我偶尔想想我是不是年纪越往后走，耐心变得是足够了，但是是不是期许也变得越来越大了，还是说这个团队还有很长的路要走，我们还需要更多的相互了解。我希望我这么久以来战斗而来的东西，都是有意义而被后来接手人能更好的利用，而不是像我，舔着刀口行走。\n\n而作为一个客户端开发者，直接跟UI/产品/其他技术团队直接打交到且对配合人员期许较高的时候，之前难免会有点小摩擦，今天得空深刻总结反省，有幸是这些变化都让我们配合的更佳好，矛盾也能及时解决，这令我感到倍感欣慰，会让你觉得你既往所付出的心血，都如此值得，也能笑着为此开心。\n\n今天是我来飞修整整9个月时间，9个月我觉得乐一让我从单休变成了单双休，兑现了他当初跟我讲的让我双休的一半，趁我还是在能加得动班的年纪，我觉这个老板还不坏，也想说这个朋友还不坏，即便哪天不再是老板和员工的关系，也能成为很好的朋友，能遇到一个守信的老板，且和你年纪一样的时候，你要想的是他身上有哪些闪光的东西是你能学的，并为此遇见感到高兴。\n\n9个月的时间里，我只做了一点点卑微的工作，将飞修的客户端从1.0跌代到3.0，没有骄人的成绩，也没有突出的贡献，遵守本分，唯一觉得心里高兴的无非就是赶进度的同时，也能交的出去一份不算质量低的代码；如果需要我给我这9个月的工作打分，我能打9分，最后的1分我保留给刘欢，如果能在接下来的半年里带出来另一个娴熟的客户端开发的话，我觉得，那个时候我的工作是能打10分的，打10分意味着，我对得起老板给我创造的所有优秀的环境，给我发的每一分钱薪水。\n\n从11月初，我就在问自己：假如有一天你能放下所有的事情，真去做一件事情不考虑薪水，不考虑环境的话，你愿意做什么？我想我可能会去做一个科学家研究那些年想做的物理课题研究。那么除了这个呢？做算法吧。\n\n这些年还能激荡起心中热情的二件事，我庆幸还没有变。\n\n飞修团队越来越大，每个岗位上的螺丝钉都要拧紧，然后尽自己最大的能力做好自己的份内的事情，要么被替换，要么收拾行囊离开，每天不虚度时光而过的有意义，你且需要的就是把自己最大热情度能投入的事情和你的工作相结合，如果刚刚好公司也是需要的，那么恭喜你，能成为一个快乐工作的人。\n\n接下来我想试着往数据分析这个方向走一走，能走多远走多专业不知道，适不适合也不了解，但是唯一能让我感到开心和有信心的是：我还有很大的热忱和兴趣。\n\n基于我现在对数据分析的行业了解：数据分析有两种，一种类似产品经理，类似产品经理向更加注重业务，对业务能力要求比较高；一种偏向数据挖掘，数据挖掘向更加注重技术，对算法代码能力要求比较高。\n\n\n二者共同需要的技术的入门标准都是：\n  1. SQL。\n  2. 统计学基础。\n  3. Python或者R的基础。\n\n\n二者有区别的技能树是：\n  A.产品经理向：需要对业务感知能力强，对数据十分敏感，掌握常用的一些业务分析模型套路。为公司的业务负责的方向有：商业分析、数据运营、用户研究、策略分析等等。\n  B.数据挖掘向：需要牢固的底层基础，编程语言基础、算法、数据结构、统计学知识样样不能少。\n\n\n于我而言，我是乐于专向数据挖掘方向的，但是这里有会有一个矛盾的点，我可能要一遍兼顾iOS的同时，也要学习新的领域的东西，对于我而言也是一个挑战。\n\n其实我对自己的期许并不是做到一个数据分析师就行了，我对自己的要求是做到战略型数据分析师，能站在数据的角度引领公司整体战略。通过数据分析对公司业务以及行业前景进行预判，为公司制定战略的时候，给出科学的分析依据。进而推动公司战略发展，且能符合投资人的期望值。\n\n然而我个人觉得，我的其他条件中有一个很重要的条件符合这个岗位：喜欢演讲。\n\n乐于把你捕获的信息释法出去，用“人话”说给别人听，且让人听懂，这是一个重要的能力，一个好的数据分析师及时分析能力超群，不能把分析的结果用言语打动老板，让老板相信你跟你走，那么也是一个形同虚设。\n\n以上这些，是我这二天出去玩的时候思考的结果。也有诸多的感慨，唯一能感受到的就是时间过的真快。昨日之事，历历在目。\n\n此贴留为纪念，日后且看今日决策是否正确如预期。\n\n愿诸君不忘初心，砥砺前行，与君共勉。\n\n有时候想跟你们说：我爱你们，爱你们就像爱生命。（妈卖批，是假的哦！）\n\n\n\n{% aplayer \"爱你就像爱生命\" \"房东的猫\" \"http://ozwoorjfp.bkt.clouddn.com/%E6%88%BF%E4%B8%9C%E7%9A%84%E7%8C%AB%20-%20%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD.mp3\" \"\" \"autoplay\" %}\n\n\n\n\n","updated":"2017-12-15T14:30:27.579Z","permalink":"http://yoursite.com/2017/11/27/我能做些什么和我打算做些什么/","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"钱塘二渡","date":"2017-11-24T16:21:02.000Z","path":"2017/11/25/钱塘二渡/","text":"对杭州的冲动，不在于贪恋江南小家闺秀的气质。 西湖断桥苏白堤，孤山城中楼外楼。于我而言，一无过往，二无艳羡。 我感兴趣的是每个城市的人，和我相似的人们，是怎样的活着，根本上来讲还是在追寻自己活的最佳方式的过程中，想要寻找一些借鉴，这是我旅行的第一要点，所以美景其实是附属，西溪湿地也好，西湖断桥也罢，都是锦上添花的东西，并不是特别重要。第二要点是共同经历，姑娘说她没有和我去很多地方，我想现在大抵上还是年轻，走一走还是要的，且把时间拉后，倘若一旦为家庭操劳，这些皆是奢求，都只能是心头念。 这次吃了两顿杭帮菜，感觉自己可能并不是由衷的热爱，但是好像也没那么坏，我觉得杭帮菜蛮适合我，不至于吃得太多因为太腻歪；摇橹船的大叔让我别去楼外楼了，他说味道并不会太好，只是吃个名气，没啥意思。我在想，但凡这个世上所有的事情都听人劝，自己不去经历，那还有什么意义，别人的建议永远不会充耳不闻，但也不会照搬俗套，问自己想不想就行了。想吗？那就去哇！有意义吗？那还去干嘛？！我觉得能满足自己的想，就是最大的意义啊。 我跟人开玩笑讲：你在西溪湿地和西湖闲逛的时候，一个晃神，你还以为自己在汤池的相思林和金汤湖水库上逛。于苏杭本地人而言，楼外楼外养鱼塘西湖，此般小家碧玉的景致，自不能让人热血沸腾，唯恐是个虚名罢了，自然比不上广阔的天地宏伟的景观，可让人短暂抛却烦心事，也不算太差。 10月中旬，公司安排参加云栖大会，四天繁忙的交流讲座学习，时间甚是紧迫，外加阴雨绵绵，姑娘讨厌雨天，所以那次杭州的偷闲得空的游逛也随之搁浅。 云栖大会让我想起了早些年在深圳隔月的“深圳巅峰技术交流会”，跟荣杰蹭饭聚会的同时，和立华他们吹着牛逼，聊着好多想做却能力不够做不了的事情，那个时候感觉我们这些人都是互联网的希望，我们想做智能家居，我们想做很多东西，想解决最后一公里的需求，想创业想挣票子，想泡妞，这些大抵是那个时候的想法。 那个时候聊天的内容，很多东西上次在云栖大会上都见到了，仅仅是过了3-4年而已，我们吹的牛逼已经被这些互联网大佬变现了，我们要搞的无人机快递，我们要搞的人工智能汽车，我们要搞的人工智能家居，我们聊到的神经网络算法的应用于方方面面的同时，还有神经网络对超参数的各种优化，子模函数超模函数的概念，提高了精确度和算法速度的同时极大程度上缩短了神经网络算法参数的确定时间，也就实现了快速获取神经网络算法模型，举个简单的例子用人话来说就是：现在的技术可以达到用高速运行的相机拍照或者录制视频的同时，就可以进行同步识别了。 而3-4年前我们在深圳吹逼闲聊的时候说的要做实时的监控识别的想法，最大的技术门槛就是在于实时识别的反馈结果。那次我在听云栖的技术报告交流的时候，最大的感慨并不是这些大厂好厉害，这些学者好牛逼，而是感叹道：时间过的真尼玛快，好想回到那些年轻的岁月，多做那些有意义的事情。 我庆幸现在在很多事情上的努力有所回馈，也感谢自己的年轻，好多可以做的事情还有机会去做，除了庆幸就是感恩，感谢生命里遇到了这么多有意思的事和那些年已遇的奇迹。 经历放在纵向的意义上来看就会显得尤其的突出和重要，平行时间里的经历，永远都是未知的啊，经历只有有用的时候才会是经历，不然你会觉得是虚度。 经历了人和事，阅千重山行万里路，丰富生命的宽度，让自己在遇到的时候不会惊慌失措，不会变的无畏无知，而是从容淡然，想热血的时候热血，想激动的时候激动，这才是极佳的。 大抵上如此，日子慢悠悠的过。忙的时候疯狂陷入一种状态固然是充实的，但是还是要多走动多陪陪身边的人。注意休息注意身体健康，世间事，除死无大事，能活着，健康的活着比什么都强。 贪恋啊，红尘太过于美好，生活即便残酷，也还有精彩之处。 所以决定给博客开个新的板块。这也是城南旧事存在的意义。","raw":"---\ntitle: 钱塘二渡\ndate: 2017-11-25 00:21:02\ncategories:\ntoc: false\ntags:\n     - Travel\n     - 杭州\n---\n\n\n对杭州的冲动，不在于贪恋江南小家闺秀的气质。\n\n\n西湖断桥苏白堤，孤山城中楼外楼。于我而言，一无过往，二无艳羡。\n\n\n我感兴趣的是每个城市的人，和我相似的人们，是怎样的活着，根本上来讲还是在追寻自己活的最佳方式的过程中，想要寻找一些借鉴，这是我旅行的第一要点，所以美景其实是附属，西溪湿地也好，西湖断桥也罢，都是锦上添花的东西，并不是特别重要。第二要点是共同经历，姑娘说她没有和我去很多地方，我想现在大抵上还是年轻，走一走还是要的，且把时间拉后，倘若一旦为家庭操劳，这些皆是奢求，都只能是心头念。\n\n\n<!--more-->\n\n\n这次吃了两顿杭帮菜，感觉自己可能并不是由衷的热爱，但是好像也没那么坏，我觉得杭帮菜蛮适合我，不至于吃得太多因为太腻歪；摇橹船的大叔让我别去楼外楼了，他说味道并不会太好，只是吃个名气，没啥意思。我在想，但凡这个世上所有的事情都听人劝，自己不去经历，那还有什么意义，别人的建议永远不会充耳不闻，但也不会照搬俗套，问自己想不想就行了。想吗？那就去哇！有意义吗？那还去干嘛？！我觉得能满足自己的想，就是最大的意义啊。\n\n\n我跟人开玩笑讲：你在西溪湿地和西湖闲逛的时候，一个晃神，你还以为自己在汤池的相思林和金汤湖水库上逛。于苏杭本地人而言，楼外楼外养鱼塘西湖，此般小家碧玉的景致，自不能让人热血沸腾，唯恐是个虚名罢了，自然比不上广阔的天地宏伟的景观，可让人短暂抛却烦心事，也不算太差。\n\n\n10月中旬，公司安排参加云栖大会，四天繁忙的交流讲座学习，时间甚是紧迫，外加阴雨绵绵，姑娘讨厌雨天，所以那次杭州的偷闲得空的游逛也随之搁浅。\n\n\n云栖大会让我想起了早些年在深圳隔月的“深圳巅峰技术交流会”，跟荣杰蹭饭聚会的同时，和立华他们吹着牛逼，聊着好多想做却能力不够做不了的事情，那个时候感觉我们这些人都是互联网的希望，我们想做智能家居，我们想做很多东西，想解决最后一公里的需求，想创业想挣票子，想泡妞，这些大抵是那个时候的想法。\n\n\n那个时候聊天的内容，很多东西上次在云栖大会上都见到了，仅仅是过了3-4年而已，我们吹的牛逼已经被这些互联网大佬变现了，我们要搞的无人机快递，我们要搞的人工智能汽车，我们要搞的人工智能家居，我们聊到的神经网络算法的应用于方方面面的同时，还有神经网络对超参数的各种优化，子模函数超模函数的概念，提高了精确度和算法速度的同时极大程度上缩短了神经网络算法参数的确定时间，也就实现了快速获取神经网络算法模型，举个简单的例子用人话来说就是：现在的技术可以达到用高速运行的相机拍照或者录制视频的同时，就可以进行同步识别了。\n\n\n而3-4年前我们在深圳吹逼闲聊的时候说的要做实时的监控识别的想法，最大的技术门槛就是在于实时识别的反馈结果。那次我在听云栖的技术报告交流的时候，最大的感慨并不是这些大厂好厉害，这些学者好牛逼，而是感叹道：时间过的真尼玛快，好想回到那些年轻的岁月，多做那些有意义的事情。\n\n\n我庆幸现在在很多事情上的努力有所回馈，也感谢自己的年轻，好多可以做的事情还有机会去做，除了庆幸就是感恩，感谢生命里遇到了这么多有意思的事和那些年已遇的奇迹。\n\n\n经历放在纵向的意义上来看就会显得尤其的突出和重要，平行时间里的经历，永远都是未知的啊，经历只有有用的时候才会是经历，不然你会觉得是虚度。\n\n\n经历了人和事，阅千重山行万里路，丰富生命的宽度，让自己在遇到的时候不会惊慌失措，不会变的无畏无知，而是从容淡然，想热血的时候热血，想激动的时候激动，这才是极佳的。\n\n\n大抵上如此，日子慢悠悠的过。忙的时候疯狂陷入一种状态固然是充实的，但是还是要多走动多陪陪身边的人。注意休息注意身体健康，世间事，除死无大事，能活着，健康的活着比什么都强。\n\n\n贪恋啊，红尘太过于美好，生活即便残酷，也还有精彩之处。\n\n\n所以决定给博客开个新的板块。这也是城南旧事存在的意义。\n\n\n","updated":"2017-11-27T11:59:31.992Z","permalink":"http://yoursite.com/2017/11/25/钱塘二渡/","categories":[],"tags":[{"name":"Travel","slug":"Travel","permalink":"http://yoursite.com/tags/Travel/"},{"name":"杭州","slug":"杭州","permalink":"http://yoursite.com/tags/杭州/"}]},{"title":"weak singleton模式在iOS中的应用","date":"2017-07-19T07:44:41.000Z","path":"2017/07/19/weak-singleton模式在iOS中的应用/","text":"关于weak要了解的基本内容： weak的使用场景: weak 的常见场景是在 delegate,block,NSTimer 中使用,我们经常用weak来避免以上场景中易产生的循环引用的问题. weak的实际作用是:弱引用,在对象释放后置为 nil,避免错误的内存访问.也就是说:weak 可以在不增加对象的引用计数的同时,又使得指针的访问是安全的. 单例模式在OC和Swift这经常会被用到,好用的小模块工具类、很多SDK的初始化等等.但是这些单例的使用场景里都有一个共同的毛病,单例在被创建之后会伴随着进程一直存活,有时候我们的业务需求,特别是对于前端来说的话,很多单例模式的使用都是为了方便,所以我们其实很想在这些单例不必要存在的时候将它们释放掉,因为这些单例在一定程度上是有内存浪费的. 一个简单的例子:比如登陆模块的 LoginInstance 单例,我们在登陆之后除非需要二次登陆,不然就可能再也用不到这个单例了,我们最好的处理方式是将这个单例释放掉在登陆之后,而在登陆的过程当中我们随时随地的获取和使用这个单例,似乎这样的应用场景在前端开发中显得更多以及更常用,也似乎更佳的合理,更好的符合前端的性能尽可能的高的这种默认标准. 可是常规的单例模式无法实现上述需求,我们只能做到随时随地的获取使用这个单例,而无法释法这个单例. 那么,用weak试一下吧. 弱单例模式的 weak singleton 的具体实现代码如下+ (id)sharedInstance { static __weak ASingletonClass *instance; ASingletonClass *strongInstance = instance; @synchronized(self) { if (strongInstance == nil) { strongInstance = [[[self class] alloc] init]; instance = strongInstance; } } return strongInstance; } 这种特殊的单例有一个有意思的特性:在所有使用该单例的对象都释放后,单例对象本身也会自己释放. 如果 viewController A、B、C 三个视图控制器都调用了上面所描述的这种弱引用的弱单例模式.并且 viewController A、B、C 都持有 ASingletonClass 的强引用,一旦 A，B，C 都销毁后,这个单例就跟着销毁,而这个就跟我们之前的单例模式不一样了,它不会是从创建后就只能一直存在,无法释放. 这样我们再一次回到上述的登陆模块的时候,当我们的登陆控制器在棧里被释放掉之后,登陆的LoginInstance 单例也会随即释放,这样就达到了我们想要的效果. 此外重要的是:当 LoginInstance 再次被调用时,LoginInstance 又会重新被创建.这样二次登陆的时候,LoginInstance 还是一个单例. 然而我们会发现:weak singleton 这种弱单例模式中的 weak ,有着很漂亮的作用,巧妙的利用了weak的作用来设计了一种我们很想要的效果的模式,从而也看出来,对于关键词weak而言,还有很多能发现的美.","raw":"---\ntitle: weak singleton模式在iOS中的应用\ndate: 2017-07-19 15:44:41\ncategories:\ntoc: true\ntags:\n     - iOS\n     - weak\n     - weak singleton\n     - 弱单例模式\n---\n\n# 关于weak要了解的基本内容：\n***\nweak的使用场景: weak 的常见场景是在 delegate,block,NSTimer 中使用,我们经常用weak来避免以上场景中易产生的循环引用的问题.\n\nweak的实际作用是:弱引用,在对象释放后置为 nil,避免错误的内存访问.也就是说:weak 可以在不增加对象的引用计数的同时,又使得指针的访问是安全的.\n***\n\n单例模式在OC和Swift这经常会被用到,好用的小模块工具类、很多SDK的初始化等等.但是这些单例的使用场景里都有一个共同的毛病,单例在被创建之后会伴随着进程一直存活,有时候我们的业务需求,特别是对于前端来说的话,很多单例模式的使用都是为了方便,所以我们其实很想在这些单例不必要存在的时候将它们释放掉,因为这些单例在一定程度上是有内存浪费的.\n\n一个简单的例子:比如登陆模块的 LoginInstance 单例,我们在登陆之后除非需要二次登陆,不然就可能再也用不到这个单例了,我们最好的处理方式是将这个单例释放掉在登陆之后,而在登陆的过程当中我们随时随地的获取和使用这个单例,似乎这样的应用场景在前端开发中显得更多以及更常用,也似乎更佳的合理,更好的符合前端的性能尽可能的高的这种默认标准.\n\n可是常规的单例模式无法实现上述需求,我们只能做到随时随地的获取使用这个单例,而无法释法这个单例.\n\n那么,用weak试一下吧.\n\n<!--more-->\n\n# 弱单例模式的 weak singleton 的具体实现代码如下\n\n    + (id)sharedInstance {\n       static __weak ASingletonClass *instance;\n       ASingletonClass *strongInstance = instance;\n       @synchronized(self) {\n          if (strongInstance == nil) {\n            strongInstance = [[[self class] alloc] init];\n            instance = strongInstance;\n          }\n       }\n       return strongInstance;\n    }\n\n这种特殊的单例有一个有意思的特性:在所有使用该单例的对象都释放后,单例对象本身也会自己释放.\n\n如果 viewController A、B、C 三个视图控制器都调用了上面所描述的这种弱引用的弱单例模式.并且 viewController A、B、C 都持有 ASingletonClass 的强引用,一旦 A，B，C 都销毁后,这个单例就跟着销毁,而这个就跟我们之前的单例模式不一样了,它不会是从创建后就只能一直存在,无法释放.\n\n这样我们再一次回到上述的登陆模块的时候,当我们的登陆控制器在棧里被释放掉之后,登陆的LoginInstance 单例也会随即释放,这样就达到了我们想要的效果.\n\n此外重要的是:当 LoginInstance 再次被调用时,LoginInstance 又会重新被创建.这样二次登陆的时候,LoginInstance 还是一个单例.\n\n然而我们会发现:weak singleton 这种弱单例模式中的 weak ,有着很漂亮的作用,巧妙的利用了weak的作用来设计了一种我们很想要的效果的模式,从而也看出来,对于关键词weak而言,还有很多能发现的美.\n\n\n","updated":"2017-12-15T14:26:56.812Z","permalink":"http://yoursite.com/2017/07/19/weak-singleton模式在iOS中的应用/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"weak","slug":"weak","permalink":"http://yoursite.com/tags/weak/"},{"name":"weak singleton","slug":"weak-singleton","permalink":"http://yoursite.com/tags/weak-singleton/"},{"name":"弱单例模式","slug":"弱单例模式","permalink":"http://yoursite.com/tags/弱单例模式/"}]},{"title":"别管以后将如何结束，冷暖自愿尝透","date":"2017-03-31T16:16:31.000Z","path":"2017/04/01/别管以后将如何结束，冷暖自愿尝透/","text":"今天晚上9点多写代码的时候，隔壁的后端用电脑放了一首《萍聚》，霎那间被旋律带出了些许的难受。 很感谢尚且足够年轻的自己，感谢自己拥有一个每天爬起来都充满干劲的自己。我仔细的回忆了一下，我已经将近有3年的时间，不曾惶惶度日，从那一刻感到考研复习学习的时间不够的大四开始，我就每天都在舔着刀口数着时间过日子。 虽然有挺多时候熬夜特别幸苦，感到胸闷呼吸不够舒畅，但是好在身体并无大碍，我知道我亏欠年轻的自己太多，所以我好想爬的足够快，快到我自己可以为自己所做的事情开心。 我深感自己的平凡，但心里总会充满了对平庸的不甘和对庸俗的愤怒，但你却不得不承认，一个人的能力很有限。但是每次挫败的时候，我都在问自己做的够好不。 自从心里想好好写代码到现在，无时无刻不深感自己的无力，不是所有的事情都和学习成长般简单，你认识到了这世间还有事情是花时间是不够的。编程像一个无底深渊，没有最好，只有更好，一个没有极限的东西，你穷极所有时间，最后只会换来筋疲力竭的妥协。然后臭骂自己一句：你还是那么没用，毫无是处。 现如今二十多岁，不用多久就三十岁了，好可怕，我瞧瞧我自己，我的确很没用。而立之年，何立？我深知自己的现状，所以我从想好好努力活个让自己喜欢的人样开始，一直过的很煎熬，我挣扎的这一二三年里时间都过的好快，快的我措手不及，让我愈发慌乱。 所以我想对你们说的是我并不是不想好好陪你们，是我自己疯了，太心急想一口吃一个胖子，是我还没有好好沉下心来，做足够好的自己，是我太自负，自负到我以为很多事情很简单就能过去，往往比预期漫长得太多。 我平时开玩笑对你们说的那些我真没用的话，是真的是发自内心的。但是我这个人好贱的，我不希望别人说我没用，包括你。我只知道这个世界上，有些你越在乎的人，肆无忌惮的说挺多话都是伤人的，但是好贱的你却要原谅他们。这些碎言碎语，往往会让我想很多，想很久。你看我就是这么矫情的傻逼，那又能怎么办？ 我觉得我始终是个不负责任的人，妄想用年轻的所有精力来对未来好好负责，往往过不好当下。一个不懂得照顾自己的人，不懂得生活的人，不注重身体健康的人，的确有可嫌之处。也难为你们老说我是个傻逼，大抵说的都对，没有错。 我不愿意我在乎的人说要去乞讨来过好生活，或者为了满足自己的某些物质生活。我可以自己活的没尊严，但是不愿意我心里的你们活的比我难堪。倘若生活中的你们因为遇到我而变得如此艰辛，我愿意远离你们，我愿承担所有的不幸，只想你们能活的很快乐。 假如生活是一场旅行，我愿意做那个留下的人，当我们不足以两个人一起上路的时候，我会囊倾所有，祝你一臂之力。所以这次小长假里，我写代码累了，或者我睡前翻朋友圈，能看到照片中你们的笑脸，我想我做出的这些努力，总是能过自己这一关的。这世上最难尽之事不就是让自己想通么？ 我做的事情不完美，但是我只做我能力范围内能做到的足够的完美，这是我跟你们相处，跟家人相爱，所能做的最大的事。所以如果你让我连聚精会神专注做事最后这点仅有的快乐你都不允许的话，那我怎么面对生活如此艰辛？怎么麻痹自己？怎么让自己觉得还有希望？难道要让我苟且的做事，蝼蚁一样的生活？抱歉，我真的做不到了。我想这无论是我用来麻痹自己，还是我想难变中寻求突变，唯一可以让自己还能仅仅感觉到的甜头和动力。 大学四年打了快上万盘的dota，放了整整一年多没玩，2016年年初我跟自己说：等你闲下来，你要趁自己年轻，还有心思，去参加一次线下活动，上海一年一度的亚洲邀请赛就在你眼前。就需要一次，带上你的朋友一起，和那些年一起玩游戏的小伙伴一起。4月1日开始的线下8强亚洲邀请赛又在上海举办了。而这次一如既往的没时间了。想想还是算了，要回去看看父母了，还有代码没写完。 我想这些年我都没参与过那些大型歌舞演唱会和线下大型比赛，也不知道面对人山人海两兄弟，我会做出怎样恰当的表情。我好佩服老甲，在很忙的时候也有勇气拿起吉他玩起来。 2015年国庆的时候跟自己说2016年的国庆要去一次西藏，每次把手机备忘录打开，还能看到那条没做的愿望我就好难过，我向生活妥协了，我是个没原则的人。后来受不了自己，偷偷又把那条备忘录删掉了。 我想这些年我都没有做过什么也不干，就单独背个包去走一走，浪一浪，和陌生人坐在一个桌子上吃顿饭，在旅途中给老大爷散根烟，一起聊聊风俗乡土，一起聊聊流水光阴里别人奋斗的故事。 唉。 所以别管以后将如何，冷暖自愿尝透。 今天又是愚人节，但是我说的话又有多少是真的呢，对自己说的都是假的，对你而言都是真的。 你们明日，若是去了远方，踏上火车，望住窗外，飞越过几十个小镇，几千里土地，几千万个人。你不要怀疑，你的一生里，唯一可以相遇的机会，不在目的地，而在起点，那个愿意等你人往往是心甘情愿送你走的人。 别管以后将如何结束 至少我们曾经相聚过 却也等候只因你 冷暖自愿尝透","raw":"---\ntitle: 别管以后将如何结束，冷暖自愿尝透\ndate: 2017-04-01 00:16:31\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n今天晚上9点多写代码的时候，隔壁的后端用电脑放了一首《萍聚》，霎那间被旋律带出了些许的难受。\n\n很感谢尚且足够年轻的自己，感谢自己拥有一个每天爬起来都充满干劲的自己。我仔细的回忆了一下，我已经将近有3年的时间，不曾惶惶度日，从那一刻感到考研复习学习的时间不够的大四开始，我就每天都在舔着刀口数着时间过日子。\n\n虽然有挺多时候熬夜特别幸苦，感到胸闷呼吸不够舒畅，但是好在身体并无大碍，我知道我亏欠年轻的自己太多，所以我好想爬的足够快，快到我自己可以为自己所做的事情开心。\n\n我深感自己的平凡，但心里总会充满了对平庸的不甘和对庸俗的愤怒，但你却不得不承认，一个人的能力很有限。但是每次挫败的时候，我都在问自己做的够好不。\n\n自从心里想好好写代码到现在，无时无刻不深感自己的无力，不是所有的事情都和学习成长般简单，你认识到了这世间还有事情是花时间是不够的。编程像一个无底深渊，没有最好，只有更好，一个没有极限的东西，你穷极所有时间，最后只会换来筋疲力竭的妥协。然后臭骂自己一句：你还是那么没用，毫无是处。\n\n<!--more-->\n\n现如今二十多岁，不用多久就三十岁了，好可怕，我瞧瞧我自己，我的确很没用。而立之年，何立？我深知自己的现状，所以我从想好好努力活个让自己喜欢的人样开始，一直过的很煎熬，我挣扎的这一二三年里时间都过的好快，快的我措手不及，让我愈发慌乱。\n\n所以我想对你们说的是我并不是不想好好陪你们，是我自己疯了，太心急想一口吃一个胖子，是我还没有好好沉下心来，做足够好的自己，是我太自负，自负到我以为很多事情很简单就能过去，往往比预期漫长得太多。\n\n我平时开玩笑对你们说的那些我真没用的话，是真的是发自内心的。但是我这个人好贱的，我不希望别人说我没用，包括你。我只知道这个世界上，有些你越在乎的人，肆无忌惮的说挺多话都是伤人的，但是好贱的你却要原谅他们。这些碎言碎语，往往会让我想很多，想很久。你看我就是这么矫情的傻逼，那又能怎么办？\n\n我觉得我始终是个不负责任的人，妄想用年轻的所有精力来对未来好好负责，往往过不好当下。一个不懂得照顾自己的人，不懂得生活的人，不注重身体健康的人，的确有可嫌之处。也难为你们老说我是个傻逼，大抵说的都对，没有错。\n\n我不愿意我在乎的人说要去乞讨来过好生活，或者为了满足自己的某些物质生活。我可以自己活的没尊严，但是不愿意我心里的你们活的比我难堪。倘若生活中的你们因为遇到我而变得如此艰辛，我愿意远离你们，我愿承担所有的不幸，只想你们能活的很快乐。\n\n假如生活是一场旅行，我愿意做那个留下的人，当我们不足以两个人一起上路的时候，我会囊倾所有，祝你一臂之力。所以这次小长假里，我写代码累了，或者我睡前翻朋友圈，能看到照片中你们的笑脸，我想我做出的这些努力，总是能过自己这一关的。这世上最难尽之事不就是让自己想通么？\n\n我做的事情不完美，但是我只做我能力范围内能做到的足够的完美，这是我跟你们相处，跟家人相爱，所能做的最大的事。所以如果你让我连聚精会神专注做事最后这点仅有的快乐你都不允许的话，那我怎么面对生活如此艰辛？怎么麻痹自己？怎么让自己觉得还有希望？难道要让我苟且的做事，蝼蚁一样的生活？抱歉，我真的做不到了。我想这无论是我用来麻痹自己，还是我想难变中寻求突变，唯一可以让自己还能仅仅感觉到的甜头和动力。\n\n大学四年打了快上万盘的dota，放了整整一年多没玩，2016年年初我跟自己说：等你闲下来，你要趁自己年轻，还有心思，去参加一次线下活动，上海一年一度的亚洲邀请赛就在你眼前。就需要一次，带上你的朋友一起，和那些年一起玩游戏的小伙伴一起。4月1日开始的线下8强亚洲邀请赛又在上海举办了。而这次一如既往的没时间了。想想还是算了，要回去看看父母了，还有代码没写完。\n\n我想这些年我都没参与过那些大型歌舞演唱会和线下大型比赛，也不知道面对人山人海两兄弟，我会做出怎样恰当的表情。我好佩服老甲，在很忙的时候也有勇气拿起吉他玩起来。\n\n2015年国庆的时候跟自己说2016年的国庆要去一次西藏，每次把手机备忘录打开，还能看到那条没做的愿望我就好难过，我向生活妥协了，我是个没原则的人。后来受不了自己，偷偷又把那条备忘录删掉了。\n\n我想这些年我都没有做过什么也不干，就单独背个包去走一走，浪一浪，和陌生人坐在一个桌子上吃顿饭，在旅途中给老大爷散根烟，一起聊聊风俗乡土，一起聊聊流水光阴里别人奋斗的故事。\n\n唉。\n\n所以别管以后将如何，冷暖自愿尝透。\n\n今天又是愚人节，但是我说的话又有多少是真的呢，对自己说的都是假的，对你而言都是真的。\n\n你们明日，若是去了远方，踏上火车，望住窗外，飞越过几十个小镇，几千里土地，几千万个人。你不要怀疑，你的一生里，唯一可以相遇的机会，不在目的地，而在起点，那个愿意等你人往往是心甘情愿送你走的人。\n\n\n>别管以后将如何结束 至少我们曾经相聚过\n\n>却也等候只因你 冷暖自愿尝透\n\n\n\n\n\n\n","updated":"2017-11-24T06:49:28.860Z","permalink":"http://yoursite.com/2017/04/01/别管以后将如何结束，冷暖自愿尝透/","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"JavaScript05","date":"2017-03-03T04:05:27.000Z","path":"2017/03/03/JavaScript05/","text":"HTML DOM （文档对象模型） 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 从目前我了解的情况来看，JS可以做到以下几点： 1.JavaScript 能够改变页面中的所有 HTML 元素 2.JavaScript 能够改变页面中的所有 HTML 属性 3.JavaScript 能够改变页面中的所有 CSS 样式 4.JavaScript 能够对页面中的所有事件做出反应 对于JavaScript而言，更加关心的是如何找到 HTML 元素，要是找不到 HTML 元素的话，就没法实施操作，而JS中给我们提供了三种方法去找HTML 元素： 1.通过 id 找到 HTML 元素 2.通过标签名找到 HTML 元素 3.通过类名找到 HTML 元素 ①通过 id 查找 HTML 元素 例:查找id为”intro”的元素 var x = document.getElementById(&quot;intro&quot;); ②通过标签名查找 HTML 元素 例:查找 id=”main” 的元素，然后查找 “main” 中的所有 元素 var x = document.getElementById(&quot;main&quot;); var y = x.getElementsByTagName(&quot;p&quot;); ③通过类名查找 HTML 元素在 IE 5,6,7,8 中无效。 在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。但是不要在文档加载之后使用 document.write()。这会覆盖该文档。 改变 HTML 内容: 修改 HTML 内容的最简单的方法时使用 innerHTML 属性。如需改变 HTML 元素的内容，怎么用下面的语句： document.getElementById(id).innerHTML = new HTML","raw":"---\ntitle: JavaScript05\ndate: 2017-03-03 12:05:27\ncategories:\ntoc: false\ntags:\n     - JavaScript\n     - JavaScript HTML DOM\n     - JavaScript HTML\n---\n\nHTML DOM （文档对象模型）\n\n当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。\n\nHTML DOM 模型被构造为对象的树。\n\n\n![JavaScript02](http://olnzmhc4r.bkt.clouddn.com/JavaScript02.png)\n\n\n从目前我了解的情况来看，JS可以做到以下几点：\n\n1.JavaScript 能够改变页面中的所有 HTML 元素\n\n2.JavaScript 能够改变页面中的所有 HTML 属性\n\n3.JavaScript 能够改变页面中的所有 CSS 样式\n\n4.JavaScript 能够对页面中的所有事件做出反应\n\n<!--more-->\n***\n\n对于JavaScript而言，更加关心的是如何找到 HTML 元素，要是找不到 HTML 元素的话，就没法实施操作，而JS中给我们提供了三种方法去找HTML 元素：\n\n1.通过 id 找到 HTML 元素\n\n2.通过标签名找到 HTML 元素\n\n3.通过类名找到 HTML 元素\n\n\n①通过 id 查找 HTML 元素\n\n例:查找id为\"intro\"的元素\n\n    var x = document.getElementById(\"intro\");\n    \n②通过标签名查找 HTML 元素\n\n例:查找 id=\"main\" 的元素，然后查找 \"main\" 中的所有 <p> 元素\n\n    var x = document.getElementById(\"main\");\n    var y = x.getElementsByTagName(\"p\");\n    \n\n③通过类名查找 HTML 元素在 IE 5,6,7,8 中无效。\n\n\n***\n\n在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。但是不要在文档加载之后使用 document.write()。这会覆盖该文档。\n\n改变 HTML 内容:\n\n修改 HTML 内容的最简单的方法时使用 innerHTML 属性。如需改变 HTML 元素的内容，怎么用下面的语句：\n\n    document.getElementById(id).innerHTML = new HTML \n    \n    \n","updated":"2017-11-24T06:58:03.856Z","permalink":"http://yoursite.com/2017/03/03/JavaScript05/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript HTML DOM","slug":"JavaScript-HTML-DOM","permalink":"http://yoursite.com/tags/JavaScript-HTML-DOM/"},{"name":"JavaScript HTML","slug":"JavaScript-HTML","permalink":"http://yoursite.com/tags/JavaScript-HTML/"}]},{"title":"JavaScript04","date":"2017-03-03T02:53:36.000Z","path":"2017/03/03/JavaScript04/","text":"JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。 常见的 JavaScript 验证的这些典型的表单数据有： 用户是否已填写表单中的必填项目？ 用户输入的邮件地址是否合法？ 用户是否在数据域 (numeric field) 中输入了文本？ function validate_required(field,alerttxt) { with (field) { if (value == null || value == &quot;&quot;) { alert(alerttxt); return false; } else { return true; } } } 有个经典的关于邮箱地址的验证： function validate_email(field,alerttxt) { with (field) { apos = value.indexOf(&quot;@&quot;) dotpos = value.lastIndexOf(&quot;.&quot;) if (apos&lt;1||dotpos-apos&lt;2) { alert(alerttxt); return false; } else { return true; } } } 一开始对上面的函数并不陌生，但是仔细一瞅发现中间多了一个 with（field） 查阅资料看了一下JS中的with语句的用法： with语句为一个或一组语句指定默认对象。 with语句可以方便地用来引用某个特定对象中已有的属性，不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。 with的语句结构： with(object instance) { //代码块 } 对比下面二段代码会发现功能是一样的，但是明显有with语句的代码可读性更强，并且易于理解。 x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10); y = Math.tan(14 * Math.E); with (Math) { x = cos(3 * PI) + sin(LN10); y = tan(14 * E); } PS：但是with语句即使带来了很多方便的地方，它也有不好的之处：with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。 除了with有引用对象的作用，在JS中另一个this语句也很常见。 this 对象 是返回“当前”对象。在不同的地方，this代表不同的对象。如果在 JavaScript 的“主程序”中（不在任何 function 中，不在任何事件处理程序中）使用 this，它就代表 window 对象；如果在 with 语句块中使用 this，它就代表 with 所指定的对象；如果在事件处理程序中使用 this，它就代表发生事件的对象。 this的这个浅层意思和OC语言中的self很类似。当然这里仅仅只是用于类比理解。 下面有个this常见的用法，用于立刻检测表单输入的有效性。 &lt;script&gt; ... function check(formObj) { ... } ... &lt;/script&gt; &lt;body ...&gt; ... &lt;form ...&gt; ... &lt;input type=&quot;text&quot; ... onchange=&quot;check(this.form)&quot;&gt; ... &lt;/form&gt; ... &lt;/body&gt;","raw":"---\ntitle: JavaScript04\ndate: 2017-03-03 10:53:36\ncategories:\ntoc: false\ntags:\n     - JavaScript\n     - JavaScript 表单验证\n     - JavaScript with语句\n     - JavaScript this语句\n---\n\nJavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。\n\n>常见的 JavaScript 验证的这些典型的表单数据有：\n>\n>用户是否已填写表单中的必填项目？\n>\n>用户输入的邮件地址是否合法？\n>\n>用户是否在数据域 (numeric field) 中输入了文本？\n\n\n    function validate_required(field,alerttxt) \n    {\n       with (field) \n       {\n         if (value == null || value == \"\")\n         {\n\t         alert(alerttxt);\n\t         return false;\n         }\n         else \n         {\n\t         return true;\n         }\n       }\n    }\n\n\n有个经典的关于邮箱地址的验证：\n\n     function validate_email(field,alerttxt)\n     {\n       with (field)\n       {\n         apos = value.indexOf(\"@\")\n         dotpos = value.lastIndexOf(\".\")\n         if (apos<1||dotpos-apos<2) \n         {\n           alert(alerttxt);\n           return false;\n         }\n         else \n         {\n           return true;\n         }\n        }\n      }\n      \n<!--more-->\n\n一开始对上面的函数并不陌生，但是仔细一瞅发现中间多了一个\n\n    with（field）\n    \n查阅资料看了一下JS中的with语句的用法：\n\nwith语句为一个或一组语句指定默认对象。\n\n>with语句可以方便地用来引用某个特定对象中已有的属性，不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  \n\nwith的语句结构：\n\n    with(object instance) \n    {  \n        //代码块 \n    }  \n\n对比下面二段代码会发现功能是一样的，但是明显有with语句的代码可读性更强，并且易于理解。\n\n    x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10);\n    y = Math.tan(14 * Math.E);\n    \n    \n***\n    \n    with (Math) \n    {\n      x = cos(3 * PI) + sin(LN10);\n      y = tan(14 * E);\n    }\n    \n    \n\n>PS：但是with语句即使带来了很多方便的地方，它也有不好的之处：with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。 \n\n\n除了with有引用对象的作用，在JS中另一个this语句也很常见。\n\nthis 对象 是返回“当前”对象。在不同的地方，this代表不同的对象。如果在 JavaScript 的“主程序”中（不在任何 function 中，不在任何事件处理程序中）使用 this，它就代表 window 对象；如果在 with 语句块中使用 this，它就代表 with 所指定的对象；如果在事件处理程序中使用 this，它就代表发生事件的对象。\n\nthis的这个浅层意思和OC语言中的self很类似。当然这里仅仅只是用于类比理解。\n\n下面有个this常见的用法，用于立刻检测表单输入的有效性。\n\n\n    <script>\n    ...\n    function check(formObj) {\n    ...\n    }\n    ...\n    </script>\n    <body ...>\n    ...\n    <form ...>\n    ...\n    <input type=\"text\" ... onchange=\"check(this.form)\">\n    ...\n    </form>\n    ...\n    </body>\n\n","updated":"2017-11-24T06:57:46.182Z","permalink":"http://yoursite.com/2017/03/03/JavaScript04/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 表单验证","slug":"JavaScript-表单验证","permalink":"http://yoursite.com/tags/JavaScript-表单验证/"},{"name":"JavaScript with语句","slug":"JavaScript-with语句","permalink":"http://yoursite.com/tags/JavaScript-with语句/"},{"name":"JavaScript this语句","slug":"JavaScript-this语句","permalink":"http://yoursite.com/tags/JavaScript-this语句/"}]},{"title":"JavaScript03","date":"2017-03-02T09:04:23.000Z","path":"2017/03/02/JavaScript03/","text":"JavaScript的 try/catch/throw 语句的用法: 做iOS开发的时候，调试的时候也会用到这些内容，由于之前开发用这些比较少，所以先来重温一下OC的相关语句，大同小异。 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 在OC中，经常用到下面的代码块来捕捉异常 @try { // 可能会出现崩溃的代码 } @catch (NSException *exception) { // 捕获到的异常exception } @finally { // 结果处理 } 下面有个比较详细的OC调试的过程的代码： @try { // 1 [self tryTwo]; } @catch (NSException *exception) { // 2 NSLog(@&quot;%s\\n%@&quot;, __FUNCTION__, exception); // @throw exception; // 这里不能再抛异常 } @finally { // 3 NSLog(@&quot;我一定会执行&quot;); } // 4 // 这里一定会执行 NSLog(@&quot;try&quot;); - (void)tryTwo { @try { // 5 NSString *str = @&quot;abc&quot;; [str substringFromIndex:111]; // 程序到这里会崩 } @catch (NSException *exception) { // 6 // @throw exception; // 抛出异常，即由上一级处理 // 7 NSLog(@&quot;%s\\n%@&quot;, __FUNCTION__, exception); } @finally { // 8 NSLog(@&quot;tryTwo - 我一定会执行&quot;); } // 9 // 如果抛出异常，那么这段代码则不会执行 NSLog(@&quot;如果这里抛出异常，那么这段代码则不会执行&quot;); } 如果6抛出异常，那么执行顺序为：1-&gt;5-&gt;6-&gt;8-&gt;3-&gt;4 如果6没抛出异常，那么执行顺序为：1-&gt;5-&gt;7-&gt;8-&gt;9-&gt;3-&gt;4 Objective-C将可能出现异常的代码放在@try块中，所有的异常处理逻辑放在@catch块中，最后用@finally块来回收资源。 @作为OC语言最大的标志之一，所以相对于JavaScript来说的话，以上的三个语句的用法其实和OC基本一致，仅仅只是格式和书写上的差别。 try { //在这里运行代码 } catch(err) { //在这里处理错误 } throw 语句允许创建自定义错误。 语句如下： throw exception 对于JavaScript的异常可以是：JavaScript 的 字符串、数字、逻辑值或对象。","raw":"---\ntitle: JavaScript03\ndate: 2017-03-02 17:04:23\ncategories:\ntoc: true\ntags:\n     - JavaScript\n     - JavaScript try语句\n     - JavaScript catch语句\n     - JavaScript throw语句\n---\n\n# JavaScript的 try/catch/throw 语句的用法:\n\n>做iOS开发的时候，调试的时候也会用到这些内容，由于之前开发用这些比较少，所以先来重温一下OC的相关语句，大同小异。\n\ntry 语句测试代码块的错误。\n\ncatch 语句处理错误。\n\nthrow 语句创建自定义错误。\n\n在OC中，经常用到下面的代码块来捕捉异常\n\n    @try {\n       // 可能会出现崩溃的代码\n    }\n    @catch (NSException *exception) {\n\t   // 捕获到的异常exception\n\t }\n\t @finally {\n\t   // 结果处理\n\t }\n\n\n<!--more-->\n\n\n下面有个比较详细的OC调试的过程的代码：\n\n\n\t    @try {\n\t    // 1\n\t    [self tryTwo];\n\t    }\n\t    @catch (NSException *exception) {\n\t    // 2\n\t    NSLog(@\"%s\\n%@\", __FUNCTION__, exception);\n\t    //   @throw exception; // 这里不能再抛异常\n\t    }\n\t    @finally {\n\t    // 3\n\t    NSLog(@\"我一定会执行\");\n\t    }\n\t    // 4\n\t    // 这里一定会执行\n\t    NSLog(@\"try\");\n    \n    \n  ***  \n    \n    - (void)tryTwo {\n\t    @try {\n\t        // 5\n\t        NSString *str = @\"abc\";\n\t        [str substringFromIndex:111]; // 程序到这里会崩\n\t    }\n\t    @catch (NSException *exception) {\n\t        // 6\n\t        // @throw exception; // 抛出异常，即由上一级处理\n\t        // 7\n\t        NSLog(@\"%s\\n%@\", __FUNCTION__, exception);\n\t    }\n\t    @finally {\n\t        // 8\n\t        NSLog(@\"tryTwo - 我一定会执行\");\n\t    }\n\t     \n\t\t    // 9\n\t\t    // 如果抛出异常，那么这段代码则不会执行\n\t\t    NSLog(@\"如果这里抛出异常，那么这段代码则不会执行\");\n    }\n\n如果6抛出异常，那么执行顺序为：1->5->6->8->3->4\n\n如果6没抛出异常，那么执行顺序为：1->5->7->8->9->3->4\n\nObjective-C将可能出现异常的代码放在@try块中，所有的异常处理逻辑放在@catch块中，最后用@finally块来回收资源。\n \n\n@作为OC语言最大的标志之一，所以相对于JavaScript来说的话，以上的三个语句的用法其实和OC基本一致，仅仅只是格式和书写上的差别。\n\n    try\n    {\n    //在这里运行代码\n    }\n    catch(err)\n    {\n    //在这里处理错误\n    }\n\nthrow 语句允许创建自定义错误。\n\n语句如下：\n\n    throw exception\n    \n    \n对于JavaScript的异常可以是：JavaScript 的 字符串、数字、逻辑值或对象。    \n","updated":"2017-11-24T06:57:23.466Z","permalink":"http://yoursite.com/2017/03/02/JavaScript03/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript try语句","slug":"JavaScript-try语句","permalink":"http://yoursite.com/tags/JavaScript-try语句/"},{"name":"JavaScript catch语句","slug":"JavaScript-catch语句","permalink":"http://yoursite.com/tags/JavaScript-catch语句/"},{"name":"JavaScript throw语句","slug":"JavaScript-throw语句","permalink":"http://yoursite.com/tags/JavaScript-throw语句/"}]},{"title":"JavaScript02","date":"2017-03-02T05:33:19.000Z","path":"2017/03/02/JavaScript02/","text":"1、JavaScript关于对象的理解 关于JavaScript的对象性有很多种不同的说话，部分说法是JavaScript是面向对象的语言，还有一部的说法是JavaScript不是面向对象的语言，而是基于对象的语言。面向对象是object-oriented，基于对象是Object-Based，二者有着本质上的差别。但是大部分人认同JavaScript语言是基于对象的（Object-Based），而不是面向对象的（object-oriented）。之所以说它是一门基于对象的语言，主要是因为它没有提供象抽象、继承、重载等有关面向对象语言的许多功能。而是把其它语言所创建的复杂对象统一起来，从而形成一个非常强大的对象系统。虽然JavaScript语言是一门基于对象的，但它还是具有一些面向对象的基本特征。它可以根据需要创建自己的对象，从而进一步扩大JavaScript的应用范围，增强编写功能强大的Web文档。 从上面分析的情况来看，无论是基于对象还是面向对象，对于JavaScript的对象的研究，还是重中之重的一点。 JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。在 JavaScript 中，对象是拥有属性和方法的数据。 例如：现在有一个人对象 var person; person = new Object(); 属性: person.name = &quot;YanCey&quot;; person.age = 25; person.weight = 87; 方法: person.eat() person.run() person.sleep() 2、JavaScript的函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数在多数语言中被理解为函数或方法,所以JavaScript的函数概念和其他语言是类似的。 因为每种语言的格式书写差异很大，所以对于JavaScript函数的格式，要注意它有如下基本的格式： function functionname() { //这里是要执行的代码 } 前面使用了关键词 function PS:JavaScript 对大小写是敏感的。规定关键词 function 必须是小写，并且必须以与函数名称相同的大小写来调用函数。 当我们想调用一个函数需要带参数的时候，在（）内增加参数即可，如下： function myFunction(var1, var2) { //这里是要执行的代码 } 有时，我们会希望函数将值返回调用它的地方。通过使用 return 语句就可以实现。在使用 return 语句时，函数会停止执行，并返回指定的值。 function myFunction() { var x=5; return x; } 有时候，想要返回值是基于传递到函数中的参数： function myFunction(a, b) { return a * b; } 从以上的四种情况来看，JavaScript的函数的特性和C语言函数的情况相类似：无参无返，有参无返，无参有返，有参有返四种大的类型。但是必须要有关键词小写的 function 来修饰函数。 PS：了解完JavaScript的函数之后，避免不了的需要知道和函数有关的全局变量以及局部变量。在JS中对于全局变量和局部变量JS的规定和C语言又不谋而合的类似。 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。 您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。 只要函数运行完毕，本地变量就会被删除。 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。 如果把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。 personName = &quot;YanCeyMichael&quot;; 即使该变量是在函数内执行，也是全局变量。 3、JavaScript的运算符JavaScript的算术运算符和赋值运算符和C以及OC或者其他语言是基本类似的，这里不再赘述。 JavaScript有自己特殊功能的运算符： 用于字符串的”+”运算符: “+” 运算符用于把文本值或字符串变量加起来（连接起来) var txt1 = &quot;What a very&quot;; var txt2 = &quot;nice day&quot;; var txt3 = txt1 + txt2; txt3打印的显示结果就是: What a verynice day 据我了解: Java和.net以及Python都支持 + 来做字符串的拼接。 txt1=&quot;What a very&quot;; txt2=&quot;nice day&quot;; txt3=txt1+&quot; &quot;+txt2; 和下面的把空格放到txt1尾巴或者txt2的开头的作用是一样的。 txt1 = &quot;What a very &quot;; txt2 = &quot;nice day&quot;; txt3 = txt1 + txt2; 有时候对字符串和数字进行加法运算 x = 5 + 5; document.write(x); x = &quot;5&quot; + &quot;5&quot;; document.write(x); x = 5 + &quot;5&quot;; document.write(x); x = &quot;5&quot; + 5; document.write(x); 如果把数字与字符串相加，结果将成为字符串。 JavaScript的比较运算符和逻辑运算符以及条件运算符和C以及OC还有其他语言的语法是基本类似的,这里不再赘述。 4、JavaScript的判断语句JavaScript的判断语句和其他语言的判断语句基本一致，这里不再赘述（if语句/if-else语句/if-elseif-…-else语句/switch语句）。 5、JavaScript的for循环while循环以及break语句和continue语句这些语句和C语言或OC以及其他语言类似，这里不再赘述。","raw":"---\ntitle: JavaScript02\ndate: 2017-03-02 13:33:19\ncategories:\ntoc: true\ntags:\n     - JavaScript\n     - JavaScript 对象\n     - JavaScript 函数\n     - JavaScript 运算符\n     - JavaScript 判断语句\n     - JavaScript 循环语句\n---\n\n# 1、JavaScript关于对象的理解\n\n>关于JavaScript的对象性有很多种不同的说话，部分说法是JavaScript是面向对象的语言，还有一部的说法是JavaScript不是面向对象的语言，而是基于对象的语言。面向对象是object-oriented，基于对象是Object-Based，二者有着本质上的差别。但是大部分人认同JavaScript语言是基于对象的（Object-Based），而不是面向对象的（object-oriented）。之所以说它是一门基于对象的语言，主要是因为它没有提供象抽象、继承、重载等有关面向对象语言的许多功能。而是把其它语言所创建的复杂对象统一起来，从而形成一个非常强大的对象系统。虽然JavaScript语言是一门基于对象的，但它还是具有一些面向对象的基本特征。它可以根据需要创建自己的对象，从而进一步扩大JavaScript的应用范围，增强编写功能强大的Web文档。\n\n\n从上面分析的情况来看，无论是基于对象还是面向对象，对于JavaScript的对象的研究，还是重中之重的一点。\n\nJavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。\n在 JavaScript 中，对象是拥有属性和方法的数据。\n\n例如：现在有一个人对象\n\n    var person;\n    person = new Object();\n    \n属性:\n \n    person.name = \"YanCey\";\n    person.age = 25;\n    person.weight = 87;\n    \n方法:\n\n    person.eat()\n    person.run()\n    person.sleep()   \n    \n<!--more-->\n\n# 2、JavaScript的函数\n\n函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数在多数语言中被理解为函数或方法,所以JavaScript的函数概念和其他语言是类似的。\n\n因为每种语言的格式书写差异很大，所以对于JavaScript函数的格式，要注意它有如下基本的格式：\n\n    function functionname()\n    {\n\t  //这里是要执行的代码\n\t }\n\t \n前面使用了关键词 function\n\nPS:JavaScript 对大小写是敏感的。规定关键词 function 必须是小写，并且必须以与函数名称相同的大小写来调用函数。\n\n当我们想调用一个函数需要带参数的时候，在（）内增加参数即可，如下：\n\n    function myFunction(var1, var2)\n    {\n\t //这里是要执行的代码\n\t }\n\n有时，我们会希望函数将值返回调用它的地方。通过使用 return 语句就可以实现。在使用 return 语句时，函数会停止执行，并返回指定的值。\n\n\tfunction myFunction()\n\t{\n\tvar x=5;\n\treturn x;\n\t}\n\n有时候，想要返回值是基于传递到函数中的参数：\n\n    function myFunction(a, b)\n\t{\n\t  return a * b;\n\t}\n\n从以上的四种情况来看，JavaScript的函数的特性和C语言函数的情况相类似：无参无返，有参无返，无参有返，有参有返四种大的类型。但是必须要有关键词小写的 function 来修饰函数。\n\n***\n\n>PS：了解完JavaScript的函数之后，避免不了的需要知道和函数有关的全局变量以及局部变量。在JS中对于全局变量和局部变量JS的规定和C语言又不谋而合的类似。\n\n>在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。\n\n>您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。\n\n>只要函数运行完毕，本地变量就会被删除。\n\n>在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。\n\n>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。\n\n>如果把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。\n\n>     personName = \"YanCeyMichael\";\n\n>即使该变量是在函数内执行，也是全局变量。\n\n\n***\n\n# 3、JavaScript的运算符\n\nJavaScript的算术运算符和赋值运算符和C以及OC或者其他语言是基本类似的，这里不再赘述。\n\nJavaScript有自己特殊功能的运算符：\n\n>>用于字符串的\"+\"运算符:\n\n\"+\" 运算符用于把文本值或字符串变量加起来（连接起来)\n\n    var txt1 = \"What a very\";\n    var txt2 = \"nice day\";\n    var txt3 = txt1 + txt2;\n\ntxt3打印的显示结果就是:  What a verynice day\n\n据我了解: Java和.net以及Python都支持 + 来做字符串的拼接。  \n\n    txt1=\"What a very\";\n    txt2=\"nice day\";\n    txt3=txt1+\" \"+txt2;\n    \n和下面的把空格放到txt1尾巴或者txt2的开头的作用是一样的。\n\n    txt1 = \"What a very \";\n    txt2 = \"nice day\";\n    txt3 = txt1 + txt2;  \n      \n有时候对字符串和数字进行加法运算\n\n    x = 5 + 5;\n    document.write(x);\n\n    x = \"5\" + \"5\";\n    document.write(x);\n\n    x = 5 + \"5\";\n    document.write(x);\n\n    x = \"5\" + 5;\n    document.write(x);\n    \n如果把数字与字符串相加，结果将成为字符串。 \n\nJavaScript的比较运算符和逻辑运算符以及条件运算符和C以及OC还有其他语言的语法是基本类似的,这里不再赘述。\n\n\n# 4、JavaScript的判断语句\n\nJavaScript的判断语句和其他语言的判断语句基本一致，这里不再赘述（if语句/if-else语句/if-elseif-...-else语句/switch语句）。\n\n# 5、JavaScript的for循环while循环以及break语句和continue语句\n\n这些语句和C语言或OC以及其他语言类似，这里不再赘述。\n","updated":"2017-11-24T06:56:52.461Z","permalink":"http://yoursite.com/2017/03/02/JavaScript02/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 对象","slug":"JavaScript-对象","permalink":"http://yoursite.com/tags/JavaScript-对象/"},{"name":"JavaScript 函数","slug":"JavaScript-函数","permalink":"http://yoursite.com/tags/JavaScript-函数/"},{"name":"JavaScript 运算符","slug":"JavaScript-运算符","permalink":"http://yoursite.com/tags/JavaScript-运算符/"},{"name":"JavaScript 判断语句","slug":"JavaScript-判断语句","permalink":"http://yoursite.com/tags/JavaScript-判断语句/"},{"name":"JavaScript 循环语句","slug":"JavaScript-循环语句","permalink":"http://yoursite.com/tags/JavaScript-循环语句/"}]},{"title":"JavaScript01","date":"2017-03-02T04:09:30.000Z","path":"2017/03/02/JavaScript01/","text":"JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。 1、JavaScript的输出： 假如需从JavaScript访问某个HTML元素，可以使用document.getElementById(id) 方法。使用 “id” 属性来标识 HTML 元素： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;My First Web Page&lt;/h1&gt; &lt;p id = &quot;demo&quot;&gt;My First Paragraph&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JavaScript 由 web 浏览器来执行。在这种情况下，浏览器将访问 id=”demo” 的 HTML 元素，并把它的内容（innerHTML）替换为 “My First JavaScript”。 使用 document.write() 仅仅向文档输出写内容。如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 2、JavaScript的语句：语句； 例如这样的代码块： &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;hello!&quot;); &lt;/script&gt; 其中的： alert(&quot;hello!&quot;); 就是就是一个JavaScript语句。 一行的结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束。 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;I&quot;); document.write(&quot;love&quot;); document.write(&quot;you&quot;); &lt;/script&gt; 像这个代码块，就有三条语句，每句结束后都有”;”，需要强调的是这三条语句是按顺序执行的。 和其他的基本语言一样，语句的末尾的逗号是英文状态下的逗号。注意: “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。 3、JavaScript的注释：和很多其他语言注释方法是一样的，在此不在赘述。 4、JavaScript的变量：定义JavaScript的变量用到关键词var，语法如下： var 变量名 JavaScript的变量名的命名规则如下: 1.变量必须使用字母、下划线(_)或者美元符($)开始。 2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 3.不能使用JavaScript关键词与JavaScript保留字。 1）JavaScript的变量要先声明再赋值； 2）JavaScript的变量可以重复赋值； PS： 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。 5、JavaScript的数据类型：字符串、数字、布尔、数组、对象、Null、Undefined ①.字符串: 字符串是存储字符（比如 “YanCey Michael”）的变量。 字符串可以是引号中的任意文本。可以使用单引号或双引号： var myName = &quot;YanCey Michael&quot;; var myName = &apos;YanCey Michael&apos;; 二者等价。 也可以在字符串中使用引号，只要不匹配包围字符串的引号即可： var answer = &quot;Nice to meet you!&quot;; var answer = &quot;He is called &apos;Bill&apos;&quot;; var answer = &apos;He is called &quot;Bill&quot;&apos;; ②.数字： JavaScript 只有一种数字类型。数字可以带小数点，也可以不带： var x1 = 34.00; //使用小数点来写 var x2 = 34; //不使用小数点来写 var y = 123e5; // 12300000 var z = 123e-5; // 0.00123 ③.布尔： 布尔（逻辑）只能有两个值：true 或 false。 var x = true var y = false ④.数组： 下面的代码创建名为 students 的数组： var students = new Array(); students[0] = &quot;Michael&quot;; students[1] = &quot;Jane&quot;; students[2] = &quot;Maria&quot;; 或者 (condensed array): var students = new Array(&quot;Michael&quot;,&quot;Jane&quot;,&quot;Maria&quot;); 或者 (literal array): var students = [&quot;Michael&quot;,&quot;Jane&quot;,&quot;Maria&quot;]; ⑤.对象： 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person = {firstname:&quot;YanCey&quot;, lastname:&quot;Michael&quot;, id:1208}; PS：JS中的对象有点类似于OC中的字典。当然这里已经不能说就是字典了，只是个人作为一个iOS的软件工程师，我用来对比记忆。 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 当然有时候为了美观好看，也可以这样做书写格式的空格和转行 var person = { firstname: &quot;YanCey&quot;, lastname : &quot;Michael&quot;, id : 1208 }; 对象属性有两种寻址方式： var name = person.lastname; var name = person[&quot;lastname&quot;]; ⑥.Undefined 和 Null Undefined 这个值表示变量不含有值。 可以通过将变量的值设置为 null 来清空变量。 var person; person = null; 6、对于JavaScript的变量声明变量类型注意：声明新变量时，可以使用关键词 “new” 来声明其类型： var carname = new String; var x = new Number; var y = new Boolean; var cars = new Array; var person = new Object; JavaScript的变量均为对象。当声明一个变量时，就创建了一个新的对象。","raw":"---\ntitle: JavaScript01\ndate: 2017-03-02 12:09:30\ncategories:\ntoc: true\ntags:\n     - JavaScript\n     - JavaScript 输出\n     - JavaScript 语句\n     - JavaScript 注释\n     - JavaScript 变量 \n     - JavaScript 数据类型\n     - JavaScript 声明变量类型\n---\n\nJavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。\n\n\n\n# 1、JavaScript的输出：\n\n>假如需从JavaScript访问某个HTML元素，可以使用document.getElementById(id) 方法。使用 \"id\" 属性来标识 HTML 元素：\n\n\n    <!DOCTYPE html>\n    <html>\n    <body>\n\n    <h1>My First Web Page</h1>\n\n    <p id = \"demo\">My First Paragraph</p>\n\n    <script>\n        document.getElementById(\"demo\").innerHTML=\"My First JavaScript\";\n    </script>\n\n    </body>\n    </html>\n\n\nJavaScript 由 web 浏览器来执行。在这种情况下，浏览器将访问 id=\"demo\" 的 HTML 元素，并把它的内容（innerHTML）替换为 \"My First JavaScript\"。\n\n\n使用 document.write() 仅仅向文档输出写内容。\n如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。\n\n\n<!--more-->\n\n# 2、JavaScript的语句：\n    \n    语句；\n     \n例如这样的代码块：\n\n    <script type=\"text/javascript\">\n       alert(\"hello!\");\n    </script>\n     \n其中的：\n    \n    alert(\"hello!\");\n    \n就是就是一个JavaScript语句。\n\n\n一行的结束就被认定为语句的结束，通常在结尾加上一个分号\";\"来表示语句的结束。\n\n    <script type=\"text/javascript\">\n\t   document.write(\"I\");\n\t   document.write(\"love\");\n\t   document.write(\"you\");\n\t</script>\n\t\n像这个代码块，就有三条语句，每句结束后都有\";\"，需要强调的是这三条语句是按顺序执行的。\n\n和其他的基本语言一样，语句的末尾的逗号是英文状态下的逗号。注意:\n\n1. “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。\n\n2. 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。 \n\n\n# 3、JavaScript的注释：\n和很多其他语言注释方法是一样的，在此不在赘述。\n\n\n# 4、JavaScript的变量：\n定义JavaScript的变量用到关键词var，语法如下：\n\n    var 变量名\n    \nJavaScript的变量名的命名规则如下:\n\n    1.变量必须使用字母、下划线(_)或者美元符($)开始。\n    2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。\n    3.不能使用JavaScript关键词与JavaScript保留字。 \n    \n1）JavaScript的变量要先声明再赋值；\n\n2）JavaScript的变量可以重复赋值； \n\nPS：\n\n1. 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。\n2. 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。\n      \n      \n      \n# 5、JavaScript的数据类型：\n\n字符串、数字、布尔、数组、对象、Null、Undefined\n\n***\n\n>>①.字符串:\n\n字符串是存储字符（比如 \"YanCey Michael\"）的变量。\n\n字符串可以是引号中的任意文本。可以使用单引号或双引号：\n\n\tvar myName = \"YanCey Michael\";\n\tvar myName = 'YanCey Michael';\n    \n二者等价。\n\n也可以在字符串中使用引号，只要不匹配包围字符串的引号即可：\n\n\tvar answer = \"Nice to meet you!\";\n\tvar answer = \"He is called 'Bill'\";\n\tvar answer = 'He is called \"Bill\"';\n\n***\n\n>>②.数字：\n\t\t\nJavaScript 只有一种数字类型。数字可以带小数点，也可以不带：\n\n\tvar x1 = 34.00;     //使用小数点来写\n\tvar x2 = 34;        //不使用小数点来写\n\tvar y = 123e5;      // 12300000\n\tvar z = 123e-5;     // 0.00123\t\n\t\t\n***\n\n>>③.布尔：\n\n布尔（逻辑）只能有两个值：true 或 false。\t\t\n\n\tvar x = true\n\tvar y = false\t\n\n***\n\t\t\n>>④.数组：\n\n下面的代码创建名为 students 的数组：\n\n\tvar students = new Array();\n\tstudents[0] = \"Michael\";\n\tstudents[1] = \"Jane\";\n\tstudents[2] = \"Maria\";\n\t\t\n或者 (condensed array):\n\n\tvar students = new Array(\"Michael\",\"Jane\",\"Maria\");\n\t\t\n或者 (literal array):\n\n\tvar students = [\"Michael\",\"Jane\",\"Maria\"];\n\t\t\n***\n\n>>⑤.对象：\n\n对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：\n\n    var person = {firstname:\"YanCey\", lastname:\"Michael\", id:1208};\n    \nPS：JS中的对象有点类似于OC中的字典。当然这里已经不能说就是字典了，只是个人作为一个iOS的软件工程师，我用来对比记忆。\n\n上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 \n\n当然有时候为了美观好看，也可以这样做书写格式的空格和转行\n\n    var person = \n    {\n\t    firstname: \"YanCey\", \n\t    lastname : \"Michael\", \n\t    id       : 1208\n    }; \n    \n\t\n对象属性有两种寻址方式：\n\n\tvar name = person.lastname;\n\tvar name = person[\"lastname\"];\n\n***\n\t\n>>⑥.Undefined 和 Null\n\nUndefined 这个值表示变量不含有值。\n\n可以通过将变量的值设置为 null 来清空变量。\t\n\n    var person;\n    person = null;\n    \n# 6、对于JavaScript的变量声明变量类型   \n \n注意：声明新变量时，可以使用关键词 \"new\" 来声明其类型：\n\n    var carname = new String;\n    var x       = new Number;\n    var y       = new Boolean;\n    var cars    = new Array;\n    var person  = new Object;\n    \nJavaScript的变量均为对象。当声明一个变量时，就创建了一个新的对象。    \n     \n\t\t\t\t\n\n\t\t\n\n\n","updated":"2017-11-29T03:25:50.928Z","permalink":"http://yoursite.com/2017/03/02/JavaScript01/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 输出","slug":"JavaScript-输出","permalink":"http://yoursite.com/tags/JavaScript-输出/"},{"name":"JavaScript 语句","slug":"JavaScript-语句","permalink":"http://yoursite.com/tags/JavaScript-语句/"},{"name":"JavaScript 注释","slug":"JavaScript-注释","permalink":"http://yoursite.com/tags/JavaScript-注释/"},{"name":"JavaScript 变量","slug":"JavaScript-变量","permalink":"http://yoursite.com/tags/JavaScript-变量/"},{"name":"JavaScript 数据类型","slug":"JavaScript-数据类型","permalink":"http://yoursite.com/tags/JavaScript-数据类型/"},{"name":"JavaScript 声明变量类型","slug":"JavaScript-声明变量类型","permalink":"http://yoursite.com/tags/JavaScript-声明变量类型/"}]},{"title":"给blog添加一个相册，先把JS干掉","date":"2017-03-02T03:18:18.000Z","path":"2017/03/02/给blog添加一个相册，先把JS干掉/","text":"废话写在前面：这个博客没有相册，这会儿刚好不是特别的忙，所以也有点精力来整理一下blog。音乐播放器加了，还差一个相册。为了整个相册出来，我还是要摸一下前端的内容的，也许方向不是特别的对，但是还是先从JS入手吧。 我对JS不是特别了解的，在iOS这边原生的框架开发做的时间用不了多久，就会遇到JS的交互问题，在iOS这边有个UI控件叫UIWebView，它是专门用来承载html内容的一个控件（通俗的来说：这个控件是用来加载网页的）。只有简单的代理方法，所以很多时候，iOS这边想要和web前端做一些交互的时候，难免要用到JS。 JS简介： JS即JavaScript，一般这么解释它：JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 目前所有主流浏览器都支持JavaScript，并且很多的网站的网页都用JavaScript来做一些动态功能，当然还可以用其他的脚本语言来丰富网页的动态效果也不仅仅就是JavaScript。 那么这个开篇的JavaScript的内容就简单介绍一些基本的关于JavaScript的基本概念。 从JavaScript的基本概念介绍看来JavaScript这门语言可用于HTML和Web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。所以它的代码怎么书写，怎么使用，怎么调用等问题是我所关心的。 JavaScript是可插入HTML页面的编程代码。 Q1:怎么在HTML文件内容中写JS代码？ &lt;script&gt;&lt;/script&gt; 使用标签在HTML网页中插入JavaScript代码，这种标签和H5的其他标签一样都是成对存在，JavaScript代码是写在标签中间的。 有时会遇到这样的一对标签 &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 这是表示这对标签之间的内容是文本类型(text)，javascript是为了告诉浏览器里面的文本是属于JavaScript语言。 Q2:JS代码只能写在HTML文件中吗？ 在很多复杂的项目中，一般会遇到把JS的内容单独抽离出来，并不写在HTML的文件中。把HTML文件和JS代码分开，并单独创建一个JavaScript文件(简称JS文件)，其文件后缀通常为.js，然后将JS代码直接写在JS文件中。这样也是可以的。 PS:1）在JS文件中， &lt;script&gt;&lt;/script&gt; 像这样的成对的标签就不再需要了，而是直接在JS文件中编写JavaScript代码就可以了。 2）但是新的问题又出现了，以上抽离部分的JS代码的JS文件并不能直接被运行，它需嵌入到HTML文件中执行，所以需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 相当于告诉浏览器，当你执行到这里的时候，就要去JS文件跑JS代码了。 Q3:JS代码在文件中的位置在哪里？ 我们可以将JavaScript代码放在html文件中任何位置，但是一般放在网页的head或者body部分。 1）放在head部分： 最常用的方式是在页面中head部分放置script元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。 2）放在body部分： JavaScript代码在网页读取到该语句的时候就会执行。 PS: JavaScript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。如下图：","raw":"---\ntitle: 给blog添加一个相册，先把JS干掉\ndate: 2017-03-02 11:18:18\ncategories:\ntoc: false\ntags:\n     - JavaScript\n     - JavaScript 简介\n     - JavaScript 基本概念\n---\n>废话写在前面：这个博客没有相册，这会儿刚好不是特别的忙，所以也有点精力来整理一下blog。音乐播放器加了，还差一个相册。为了整个相册出来，我还是要摸一下前端的内容的，也许方向不是特别的对，但是还是先从JS入手吧。\n>\n>我对JS不是特别了解的，在iOS这边原生的框架开发做的时间用不了多久，就会遇到JS的交互问题，在iOS这边有个UI控件叫UIWebView，它是专门用来承载html内容的一个控件（通俗的来说：这个控件是用来加载网页的）。只有简单的代理方法，所以很多时候，iOS这边想要和web前端做一些交互的时候，难免要用到JS。\n\n\nJS简介：\n\nJS即JavaScript，一般这么解释它：JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。\n\n\n目前所有主流浏览器都支持JavaScript，并且很多的网站的网页都用JavaScript来做一些动态功能，当然还可以用其他的脚本语言来丰富网页的动态效果也不仅仅就是JavaScript。\n\n\n那么这个开篇的JavaScript的内容就简单介绍一些基本的关于JavaScript的基本概念。\n\n\n<!--more-->\n\n***\n\n从JavaScript的基本概念介绍看来JavaScript这门语言可用于HTML和Web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。所以它的代码怎么书写，怎么使用，怎么调用等问题是我所关心的。\n\n\nJavaScript是可插入HTML页面的编程代码。\n\n\nQ1:怎么在HTML文件内容中写JS代码？\n\n    <script></script>\n    \n使用标签在HTML网页中插入JavaScript代码，这种标签和H5的其他标签一样都是成对存在，JavaScript代码是写在标签中间的。\n\n有时会遇到这样的一对标签\n\n    <script type=\"text/javascript\"></script>\n    \n这是表示这对标签之间的内容是文本类型(text)，javascript是为了告诉浏览器里面的文本是属于JavaScript语言。\n\n***\n\nQ2:JS代码只能写在HTML文件中吗？\n\n在很多复杂的项目中，一般会遇到把JS的内容单独抽离出来，并不写在HTML的文件中。把HTML文件和JS代码分开，并单独创建一个JavaScript文件(简称JS文件)，其文件后缀通常为.js，然后将JS代码直接写在JS文件中。这样也是可以的。\n\nPS:1）在JS文件中，\n\n       <script></script>\n       \n像这样的成对的标签就不再需要了，而是直接在JS文件中编写JavaScript代码就可以了。\n\n2）但是新的问题又出现了，以上抽离部分的JS代码的JS文件并不能直接被运行，它需嵌入到HTML文件中执行，所以需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。\n\n    <script src=\"script.js\"></script>\n    \n相当于告诉浏览器，当你执行到这里的时候，就要去JS文件跑JS代码了。\n\n***\n\nQ3:JS代码在文件中的位置在哪里？\n\n我们可以将JavaScript代码放在html文件中任何位置，但是一般放在网页的head或者body部分。\n\n1）放在head部分：\n\n最常用的方式是在页面中head部分放置script元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。\n\n2）放在body部分：\n\nJavaScript代码在网页读取到该语句的时候就会执行。\n\nPS: JavaScript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。如下图：\n\n![JavaScript01](http://olnzmhc4r.bkt.clouddn.com/JavaScript01.png)\n\n\n","updated":"2017-11-24T07:01:13.624Z","permalink":"http://yoursite.com/2017/03/02/给blog添加一个相册，先把JS干掉/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript 简介","slug":"JavaScript-简介","permalink":"http://yoursite.com/tags/JavaScript-简介/"},{"name":"JavaScript 基本概念","slug":"JavaScript-基本概念","permalink":"http://yoursite.com/tags/JavaScript-基本概念/"}]},{"title":"阳光正好","date":"2017-02-27T04:48:55.000Z","path":"2017/02/27/阳光正好/","text":"我回来了，比自己想象中的要快好多。离职，收拾行李，落脚合肥。前后只用了2天时间。雾总二天前给我电话说我走的好快啊，一不留神就走了。仓促，慌张。 回来的第二天上午又去面试了一个创业团队，产品跟我说：我们的iOS为了女朋友去上海了，所以缺个人。一个萝卜一个坑这种说法在某种意义上是成立的。和他聊的比较投缘。一个挺有想法的同龄人。 我放弃了那个目前在合肥算高薪的offer，我跟那边的老板说：倘若最终没来你这边，不是薪资的问题，只是单纯的不适合。一晃从我离开合肥庐江，到现如今我回到合肥生活，前前后后有快6年的时间了。6年里我做了很多的选择，每次都考虑的比这次要久。可是适合自己的抉择并不多。 有时候能做到适合自己好难。 一直追随的都是当下的最好也许并不是一件坏事，但是不见得能让自己快乐。之前我问过我自己眼下这几年我需要什么：稳定，安静，舒适，积淀。我从没有像现在这样渴望这些东西。 昨天花了3个小时找到了房子。今天上午把行李拎过来，把地板拖干净之后去天台看了一下，视野挺开阔。整个空的屋子，有点破旧的卫生间好像和这个像模像样的小区有点冲突。我觉得住的地方凑合着就可以了。况且像今天的日子，有这么好的阳光，大抵已经满足了我。 礼拜六晚因吃饭比较晚，错过了南峰子的MVCS框架以及数据通信层梳理的直播，可能要再抽个时间好好的整理一下。我从知乎上翻到了他的技术博客地址：南峰子的技术博客。知乎上他的最后的活跃状态还是三年前的答案。我有时候好想知道这些技术大牛到底都是在干嘛。 用MacDown写东西更新的频次要是不高的话，下次再想写点东西的时候，都好碍事，很多标签语法不记得，还要重头翻过。更新博客遇到心情差的时候就觉得好累，因为你有很多想写的都被这些东西挡着。 即便诸多不便，可是内心对干净的地儿的诉求一直欲求不满。觉得有一块地儿自己耕种的感觉挺好的，比微博空间写东西要好的多，微信挺棒的，但是里面发长内容好麻烦，可我又偏偏是一个不喜欢发碎片的怪胎，往往丢一个链接要让我省很多事儿。讲真，七牛云做博客的图床加载速度真是快的让我惊叹。 日头和阳光挺好的，想出去跑跑步了。离上次开始想跑步日子已经过去差不多一年了，这一年一直在路上，现在我换了一个地方继续跑。 老友们：平时不忙的时候，可以约一发哟～","raw":"---\ntitle: 阳光正好\ndate: 2017-02-27 12:48:55\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n我回来了，比自己想象中的要快好多。离职，收拾行李，落脚合肥。前后只用了2天时间。雾总二天前给我电话说我走的好快啊，一不留神就走了。仓促，慌张。\n\n\n回来的第二天上午又去面试了一个创业团队，产品跟我说：我们的iOS为了女朋友去上海了，所以缺个人。一个萝卜一个坑这种说法在某种意义上是成立的。和他聊的比较投缘。一个挺有想法的同龄人。\n\n\n我放弃了那个目前在合肥算高薪的offer，我跟那边的老板说：倘若最终没来你这边，不是薪资的问题，只是单纯的不适合。一晃从我离开合肥庐江，到现如今我回到合肥生活，前前后后有快6年的时间了。6年里我做了很多的选择，每次都考虑的比这次要久。可是适合自己的抉择并不多。\n\n\n有时候能做到适合自己好难。\n\n\n一直追随的都是当下的最好也许并不是一件坏事，但是不见得能让自己快乐。之前我问过我自己眼下这几年我需要什么：稳定，安静，舒适，积淀。我从没有像现在这样渴望这些东西。\n\n\n<!--more-->\n\n\n昨天花了3个小时找到了房子。今天上午把行李拎过来，把地板拖干净之后去天台看了一下，视野挺开阔。整个空的屋子，有点破旧的卫生间好像和这个像模像样的小区有点冲突。我觉得住的地方凑合着就可以了。况且像今天的日子，有这么好的阳光，大抵已经满足了我。\n\n\n![newlife1](http://olnzmhc4r.bkt.clouddn.com/newlife1.jpg)\n\n礼拜六晚因吃饭比较晚，错过了南峰子的MVCS框架以及数据通信层梳理的直播，可能要再抽个时间好好的整理一下。我从知乎上翻到了他的技术博客地址：[南峰子的技术博客](https://southpeak.github.io/)。知乎上他的最后的活跃状态还是三年前的答案。我有时候好想知道这些技术大牛到底都是在干嘛。\n\n\n用MacDown写东西更新的频次要是不高的话，下次再想写点东西的时候，都好碍事，很多标签语法不记得，还要重头翻过。更新博客遇到心情差的时候就觉得好累，因为你有很多想写的都被这些东西挡着。\n\n即便诸多不便，可是内心对干净的地儿的诉求一直欲求不满。觉得有一块地儿自己耕种的感觉挺好的，比微博空间写东西要好的多，微信挺棒的，但是里面发长内容好麻烦，可我又偏偏是一个不喜欢发碎片的怪胎，往往丢一个链接要让我省很多事儿。讲真，七牛云做博客的图床加载速度真是快的让我惊叹。\n\n日头和阳光挺好的，想出去跑跑步了。离上次开始想跑步日子已经过去差不多一年了，这一年一直在路上，现在我换了一个地方继续跑。\n\n老友们：平时不忙的时候，可以约一发哟～\n","updated":"2017-11-24T06:49:40.638Z","permalink":"http://yoursite.com/2017/02/27/阳光正好/","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]},{"title":"基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器","date":"2017-02-22T08:13:47.000Z","path":"2017/02/22/基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器/","text":"有时候偶尔写东西的时候少音乐挺没劲的。 音乐也是有毒，难以让人专注去做好一件事。 我不知道我添加一个音乐播放器的意义是什么。 纠结那么多好像也没那么多的意义。 所以不管了，文章都开了，还是个音乐播放器吧。 别问我为啥不给移动端加一个，就是不加。 准备工作：一个网易云音乐账号 + 一个网易云音乐歌单 这个音乐播放器是在网易云音乐官网的个人主页里的任意一个歌单中，通过歌单的 生成外链播放器 来生成的一个 iframe 插件。 将原生的代码段： &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=0&amp;id=609175973&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 粘贴到themes/yilia/layout/_partial/left-col.ejs文件的第二行，并作如下的修改之后，将和我现在的博客的音乐布局是一样的。修改一下： &lt;iframe style=&quot;position:absolute;top: 0px;z-index: 100;&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=0&amp;id=609175973&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 添加的部分是设置播放器的相对位置布局，也是很简单的代码就能搞定。 为了适配屏幕把原来的固定width修改成100%。 当然你可以通过检测博客的网页，通过浏览器的布局个人喜欢的位置。","raw":"---\ntitle: 基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器\ndate: 2017-02-22 16:13:47\ncategories:\ntoc: false\ntags:\n     - Hexo+Yilia\n     - PC端\n     - 音乐播放器\n---\n>有时候偶尔写东西的时候少音乐挺没劲的。\n>\n>音乐也是有毒，难以让人专注去做好一件事。\n>\n>我不知道我添加一个音乐播放器的意义是什么。\n>\n>纠结那么多好像也没那么多的意义。\n>\n>所以不管了，文章都开了，还是个音乐播放器吧。\n>\n>别问我为啥不给移动端加一个，就是不加。\n\n***\n\n准备工作：一个网易云音乐账号 + 一个网易云音乐歌单\n\n***\n\n<!--more-->\n\n这个音乐播放器是在网易云音乐官网的个人主页里的任意一个歌单中，通过歌单的 生成外链播放器 来生成的一个 iframe 插件。\n\n将原生的代码段：\n\n\n    <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=0&id=609175973&auto=1&height=32\"></iframe>\n    \n    \n粘贴到themes/yilia/layout/_partial/left-col.ejs文件的第二行，并作如下的修改之后，将和我现在的博客的音乐布局是一样的。    \n修改一下：\n\n     <iframe style=\"position:absolute;top: 0px;z-index: 100;\" frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=52 src=\"//music.163.com/outchain/player?type=0&id=609175973&auto=1&height=32\"></iframe>\n     \n \n添加的部分是设置播放器的相对位置布局，也是很简单的代码就能搞定。\n\n为了适配屏幕把原来的固定width修改成100%。\n\n当然你可以通过检测博客的网页，通过浏览器的布局个人喜欢的位置。\n\n\n\n\n","updated":"2017-11-24T07:00:28.696Z","permalink":"http://yoursite.com/2017/02/22/基于Hexo+Yilia的PersonalBlog的PC端添加音乐播放器/","categories":[],"tags":[{"name":"Hexo+Yilia","slug":"Hexo-Yilia","permalink":"http://yoursite.com/tags/Hexo-Yilia/"},{"name":"PC端","slug":"PC端","permalink":"http://yoursite.com/tags/PC端/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"http://yoursite.com/tags/音乐播放器/"}]},{"title":"OpenCV之CascadeClassifier(一)","date":"2017-02-20T06:23:58.000Z","path":"2017/02/20/OpenCV之CascadeClassifier(一)/","text":"","raw":"---\ntitle: OpenCV之CascadeClassifier(一)\ndate: 2017-02-20 14:23:58\ncategories:\ntoc: true\ntags:\n     - C++\n     - OpenCV\n---\n","updated":"2017-11-24T03:18:19.231Z","permalink":"http://yoursite.com/2017/02/20/OpenCV之CascadeClassifier(一)/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"OpenCV之Mat(一)","date":"2017-02-20T05:43:01.000Z","path":"2017/02/20/OpenCV之Mat(一)/","text":"废话内容，写在前面： Mat是个什么玩意? 2015年下半年我在深圳的时候，一边看C++的入门，一边敲一点点和工作有关的代码。有一天飞哥和勇哥终于按耐不住觉得我总是测试光学打光做电子元器件可能就真的要废了，便让我用Visual Studio把一张图片用窗口显示出来，然后对图片进行二值化处理，提取特征值。 我印象特别深刻，方法函数里面涉及到了好多Mat，如今开始动OpenCV第一个碰到的东西就是Mat，在这里把研读的关于Mat类，记录一下。 OpenCV官方文档是这样界定Mat的：基本的图像容器。 处理一张图片为何要用到图像的容器这种定义的概念？没有《图像处理技术》基础知识的人可能不太能懂图像为何需要一个基本的图像容器去处理。我本科学的《图像处理技术》的基础内容现在也不太记得，脑海中只有一些隐约的印象：图像是很多像素点构成，每个像素点有具体的像素值(0~255)，一张二维平面上的图片，它上面所有的点平面坐标位置，有点像《线性代数》里的矩阵，处理一张图片就是处理图片上所包含的像素值的信息，所以图片的处理，就可以转换成矩阵运算。 正如OpenCV官方文档上说到的：如何获取并存储这些像素值由我们的需求而定，最终在计算机世界里所有图像都可以简化为数值矩以及矩阵信息。作为一个计算机视觉库， OpenCV 其主要目的就是通过处理和操作这些信息，来获取更高级的信息。因此，OpenCV如何存储并操作图像是你首先要学习的。 Mat的发展情况： 在2001年刚刚出现的时候，OpenCV基于C语言接口而建。为了在内存（memory）中存放图像，当时采用名为IplImage的C语言结构体，时至今日这仍出现在大多数的旧版教程和教学材料。但这种方法必须接受C语言所有的不足，这其中最大的不足要数手动内存管理，其依据是用户要为开辟和销毁内存负责。虽然对于小型的程序来说手动管理内存不是问题，但一旦代码开始变得越来越庞大，你需要越来越多地纠缠于这个问题，而不是着力解决你的开发目标。 幸运的是，C++出现了，并且带来类的概念，这给用户带来另外一个选择：自动的内存管理（不严谨地说）。这是一个好消息，如果C++完全兼容C的话，这个变化不会带来兼容性问题。为此，OpenCV在2.0版本中引入了一个新的C++接口，利用自动内存管理给出了解决问题的新方法。使用这个方法，你不需要纠结在管理内存上，而且你的代码会变得简洁（少写多得）。但C++接口唯一的不足是当前许多嵌入式开发系统只支持C语言。所以，当目标不是这种开发平台时，没有必要使用旧方法（除非你是自找麻烦的受虐狂码农）。 关于 Mat ，首先要知道的是你不必再手动地（1）为其开辟空间（2）在不需要时立即将空间释放。但手动地做还是可以的：大多数OpenCV函数仍会手动地为输出数据开辟空间。当传递一个已经存在的 Mat 对象时，开辟好的矩阵空间会被重用。也就是说，我们每次都使用大小正好的内存来完成任务。 基本上讲 Mat 是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸，存储方法，存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建拷贝时，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是家常便饭。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，我们不应该拷贝 大 的图像，因为这会降低程序速度。 为了搞定这个问题，OpenCV使用引用计数机制。其思路是让每个 Mat 对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则 只拷贝信息头和矩阵指针 ，而不拷贝矩阵。 关于 Mat 内存管理的问题： 如果矩阵属于多个 Mat 对象，那么当不再需要它时谁来负责清理？简单的回答是：最后一个使用它的对象。通过引用计数机制来实现。无论什么时候有人拷贝了一个 Mat 对象的信息头，都会增加矩阵的引用次数；反之当一个头被释放之后，这个计数被减一；当计数值为零，矩阵会被清理。但某些时候你仍会想拷贝矩阵本身(不只是信息头和矩阵指针)，这时可以使用函数 clone() 或者 copyTo() 。 1.OpenCV函数中输出图像的内存分配是自动完成的（如果不特别指定的话）。 2.使用OpenCV的C++接口时不需要考虑内存释放问题。 3.赋值运算符和拷贝构造函数（ ctor ）只拷贝信息头。 4.使用函数 clone() 或者 copyTo() 来拷贝一副图像的矩阵。 以上是对图像以及 Mat类发展，以及OpenCV在处理图像时的内存管理的一个简单的了解。 接下来要了解一下OpenCV是如何存储图像的： 这里讲述如何存储像素值。需要指定颜色空间和数据类型。颜色空间是指对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间，只处理黑色和白色，对它们进行组合可以产生不同程度的灰色。 对于 彩色 方式则有更多种类的颜色空间，但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。RGB颜色空间是最常用的一种颜色空间，这归功于它也是人眼内部构成颜色的方式。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素 alpha (A)。 有很多的颜色系统，各有自身优势： 1.RGB是最常见的，这是因为人眼采用相似的工作机制，它也被显示设备所采用。 2.HSV和HLS把颜色分解成色调、饱和度和亮度/明度。这是描述颜色更自然的方式，比如可以通过抛弃最后一个元素，使算法对输入图像的光照条件不敏感。 3.YCrCb在JPEG图像格式中广泛使用。 4.CIE L a b *是一种在感知上均匀的颜色空间，它适合用来度量两个颜色之间的距离。 每个组成元素都有其自己的定义域，取决于其数据类型。如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ，占一个字节或者8位，可以是有符号型（0到255之间）或无符号型（-127到+127之间）。尽管使用三个 char 型元素已经可以表示1600万种可能的颜色（使用RGB颜色空间），但若使用float（4字节，32位）或double（8字节，64位）则能给出更加精细的颜色分辨能力。但同时也要切记增加元素的尺寸也会增加了图像所占的内存空间。 关于Mat类的创建，具体的代码和内容可以查阅OpenCV中文网里的相关入门教学，当然还要具备一点点基础的C++入门知识。 待续以后会更新相关内容，等我把C++入门摸一下。","raw":"---\ntitle: OpenCV之Mat(一)\ndate: 2017-02-20 13:43:01\ncategories:\ntoc: false\ntags:\n     - C++\n     - OpenCV\n---\n\n***\n>废话内容，写在前面：\n>\n>Mat是个什么玩意?\n>\n>2015年下半年我在深圳的时候，一边看C++的入门，一边敲一点点和工作有关的代码。有一天飞哥和勇哥终于按耐不住觉得我总是测试光学打光做电子元器件可能就真的要废了，便让我用Visual Studio把一张图片用窗口显示出来，然后对图片进行二值化处理，提取特征值。\n>\n>我印象特别深刻，方法函数里面涉及到了好多Mat，如今开始动OpenCV第一个碰到的东西就是Mat，在这里把研读的关于Mat类，记录一下。\n\n***\n\n>OpenCV官方文档是这样界定Mat的：基本的图像容器。\n\n>处理一张图片为何要用到图像的容器这种定义的概念？没有《图像处理技术》基础知识的人可能不太能懂图像为何需要一个基本的图像容器去处理。我本科学的《图像处理技术》的基础内容现在也不太记得，脑海中只有一些隐约的印象：图像是很多像素点构成，每个像素点有具体的像素值(0~255)，一张二维平面上的图片，它上面所有的点平面坐标位置，有点像《线性代数》里的矩阵，处理一张图片就是处理图片上所包含的像素值的信息，所以图片的处理，就可以转换成矩阵运算。\n>\n>正如OpenCV官方文档上说到的：如何获取并存储这些像素值由我们的需求而定，最终在计算机世界里所有图像都可以简化为数值矩以及矩阵信息。作为一个计算机视觉库， OpenCV 其主要目的就是通过处理和操作这些信息，来获取更高级的信息。因此，OpenCV如何存储并操作图像是你首先要学习的。\n\n***\n\n<!--more-->\n\nMat的发展情况：\n\n在2001年刚刚出现的时候，OpenCV基于C语言接口而建。为了在内存（memory）中存放图像，当时采用名为IplImage的C语言结构体，时至今日这仍出现在大多数的旧版教程和教学材料。但这种方法必须接受C语言所有的不足，这其中最大的不足要数手动内存管理，其依据是用户要为开辟和销毁内存负责。虽然对于小型的程序来说手动管理内存不是问题，但一旦代码开始变得越来越庞大，你需要越来越多地纠缠于这个问题，而不是着力解决你的开发目标。\n\n幸运的是，C++出现了，并且带来类的概念，这给用户带来另外一个选择：自动的内存管理（不严谨地说）。这是一个好消息，如果C++完全兼容C的话，这个变化不会带来兼容性问题。为此，OpenCV在2.0版本中引入了一个新的C++接口，利用自动内存管理给出了解决问题的新方法。使用这个方法，你不需要纠结在管理内存上，而且你的代码会变得简洁（少写多得）。但C++接口唯一的不足是当前许多嵌入式开发系统只支持C语言。所以，当目标不是这种开发平台时，没有必要使用旧方法（除非你是自找麻烦的受虐狂码农）。\n\n***\n\n关于 Mat ，首先要知道的是你不必再手动地（1）为其开辟空间（2）在不需要时立即将空间释放。但手动地做还是可以的：大多数OpenCV函数仍会手动地为输出数据开辟空间。当传递一个已经存在的 Mat 对象时，开辟好的矩阵空间会被重用。也就是说，我们每次都使用大小正好的内存来完成任务。\n\n基本上讲 Mat 是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸，存储方法，存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针。矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建拷贝时，大的开销是由矩阵造成的，而不是信息头。OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是家常便饭。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，我们不应该拷贝 大 的图像，因为这会降低程序速度。\n\n为了搞定这个问题，OpenCV使用引用计数机制。其思路是让每个 Mat 对象有自己的信息头，但共享同一个矩阵。这通过让矩阵指针指向同一地址而实现。而拷贝构造函数则 只拷贝信息头和矩阵指针 ，而不拷贝矩阵。\n\n***\n\n关于 Mat 内存管理的问题：\n\n如果矩阵属于多个 Mat 对象，那么当不再需要它时谁来负责清理？简单的回答是：最后一个使用它的对象。通过引用计数机制来实现。无论什么时候有人拷贝了一个 Mat 对象的信息头，都会增加矩阵的引用次数；反之当一个头被释放之后，这个计数被减一；当计数值为零，矩阵会被清理。但某些时候你仍会想拷贝矩阵本身(不只是信息头和矩阵指针)，这时可以使用函数 clone() 或者 copyTo() 。\n\n***\n\n1.OpenCV函数中输出图像的内存分配是自动完成的（如果不特别指定的话）。\n\n2.使用OpenCV的C++接口时不需要考虑内存释放问题。\n\n3.赋值运算符和拷贝构造函数（ ctor ）只拷贝信息头。\n\n4.使用函数 clone() 或者 copyTo() 来拷贝一副图像的矩阵。\n\n***\n\n以上是对图像以及 Mat类发展，以及OpenCV在处理图像时的内存管理的一个简单的了解。\n\n\n\n接下来要了解一下OpenCV是如何存储图像的：\n\n这里讲述如何存储像素值。需要指定颜色空间和数据类型。颜色空间是指对一个给定的颜色，如何组合颜色元素以对其编码。最简单的颜色空间要属灰度级空间，只处理黑色和白色，对它们进行组合可以产生不同程度的灰色。\n\n对于 彩色 方式则有更多种类的颜色空间，但不论哪种方式都是把颜色分成三个或者四个基元素，通过组合基元素可以产生所有的颜色。RGB颜色空间是最常用的一种颜色空间，这归功于它也是人眼内部构成颜色的方式。它的基色是红色、绿色和蓝色，有时为了表示透明颜色也会加入第四个元素 alpha (A)。\n\n有很多的颜色系统，各有自身优势：\n\n1.RGB是最常见的，这是因为人眼采用相似的工作机制，它也被显示设备所采用。\n\n2.HSV和HLS把颜色分解成色调、饱和度和亮度/明度。这是描述颜色更自然的方式，比如可以通过抛弃最后一个元素，使算法对输入图像的光照条件不敏感。\n\n3.YCrCb在JPEG图像格式中广泛使用。\n\n4.CIE L * a * b *是一种在感知上均匀的颜色空间，它适合用来度量两个颜色之间的距离。\n\n每个组成元素都有其自己的定义域，取决于其数据类型。如何存储一个元素决定了我们在其定义域上能够控制的精度。最小的数据类型是 char ，占一个字节或者8位，可以是有符号型（0到255之间）或无符号型（-127到+127之间）。尽管使用三个 char 型元素已经可以表示1600万种可能的颜色（使用RGB颜色空间），但若使用float（4字节，32位）或double（8字节，64位）则能给出更加精细的颜色分辨能力。但同时也要切记增加元素的尺寸也会增加了图像所占的内存空间。\n\n***\n\n关于Mat类的创建，具体的代码和内容可以查阅[OpenCV中文网](http://www.opencv.org.cn/)里的相关入门教学，当然还要具备一点点基础的C++入门知识。\n\n***\n待续以后会更新相关内容，等我把C++入门摸一下。\n","updated":"2017-11-24T06:59:32.082Z","permalink":"http://yoursite.com/2017/02/20/OpenCV之Mat(一)/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"}]},{"title":"人脸识别01","date":"2017-02-20T02:01:22.000Z","path":"2017/02/20/人脸识别01/","text":"废话内容，写在前面: 2016年上半年在上海面试的时候。徐汇区有一家做社交的互联网公司开始打算做人脸识别，由此我了解了深圳脸萌科技的FaceU这款超级激萌的App。很有意思的是徐汇区那家社交公司面试我的时候跟我说的很明确：你做一个类似FaceU的demo给我，我就给你发Offer。有时候我在想一份工作好简单啊，只要你会做人脸识别添加贴纸贴片，一碗饭就来了。 回去之后，我对比了iOS框架自带的人脸识别框架识别的精度不够高，侧脸极其难识别，我只好放弃转而奔向科大讯飞人脸识别的框架去做。 那一个礼拜的时间里，我看科大讯飞的人脸识别SDK和官方Demo，在做识别的过程中想加贴片装饰品的时候，遇到了二个代理方法的冲突，导致某个识别状态始终无法修改。所以那次的demo最终是没有做出来。 时隔快一年，我想人脸识别功能我该动一动了，恰好个人技术博客刚开张，也应该来一点技术干货。同时不一样的是，这次我也不打算用科大讯飞的框架，我想从OpenCV的开源库着手，多多少少还可以学点C++的函数也还不错。 由此我想把研究人脸识别的过程记录下来。所以这个系列是一个不懂C++的iOS开发小白的学习过程。 本系列文章，所有测试内容以及demo的环境如下： 1）Xcode Version 8.2.1 2）OpenCV for iOS 3.2.0 准备工作： 1）先去OpenCV官网下载最新的OpenCV For iOS的视觉库。 2）Xcode创建一个新的项目，把下载的OpenCV库导入工程，并在工程的Building phase里面添加 opencv2.framework。 如果对OpenCV有所了解的会知道，OpenCV的代码是基于C++编写的。因此，想要在Xcode项目中运行C++代码，你需要把文件名后缀名由.m改成.mm即可（当然最好把OpenCV的功能函数写一层OC的API封装，这样可能会比较安全，也会少很多不必要的错误麻烦，也更符合开发需求。）。 注意：OpenCV 声明了命名空间 cv，因此 OpenCV 的类的前面会有个 cv:: 前缀，就像 cv::Mat、 cv::Algorithm 等等。你也可以在 .mm 文件中使用 using namespace cv 来避免在一堆类名前使用 cv:: 前缀。 但是，在某些类名前你必须使用命名空间前缀，比如 cv::Rect 和 cv::Point，因为它们会跟定义在 MacTypes.h 中的 Rect 和 Point 相冲突。尽管这只是个人偏好问题，个人偏向在任何地方都使用 cv:: 以保持一致性。 C++ 命名空间namespace的作用和使用: 命名空间是ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。其作用就是规定该文件中使用的标准库函数都是在标准命名空间std中定义的。通常来说，在C++中，命名空间（namespace）的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个全局命名空间（global namespace），全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用::member的形式表示）。 在C语言中定义了3个层次的作用域，即文件(编译单元)、函数和复合语句。C++在C的基础上又引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。 在导入 opencv2.framework 之后，把你需要加入OpenCV代码的文件的.m文件后缀由.m改成.mm 引入头文件 #import &lt; opencv2/opencv.hpp&gt; #import &lt;opencv2/imgproc/types_c.h&gt; #import &lt;opencv2/imgcodecs/ios.h&gt; 编译运行。 PS:我编译的时候，有二个报错。经过查阅资料做了具体的修改调整之后可以正常运行，分别是OpenCV库的 blenders.hpp 文件 enum { NO, FEATHER, MULTI_BAND }; 修改成： enum { NO_EXPOSURE_COMPENSATOR, FEATHER, MULTI_BAND }; 和 exposure_compensate.hpp 文件 enum { NO, GAIN, GAIN_BLOCKS }; 修改成： enum { NO_EXPOSURE_COMPENSATOR, GAIN, GAIN_BLOCKS }; 先来试试OpenCV的入门内容，把一张彩色图片变成灰色的 在控制器的.mm文件中引入Mat类 @interface ViewController () { cv::Mat cvImage; } @end 关于Mat类:详见另一篇Blog：OpenCV之Mat(一) 图像处理的代码块如下： if(!cvImage.empty()){ cv::Mat gray; // 将图像转换为灰度显示 cv::cvtColor(cvImage,gray,CV_RGB2GRAY); // 应用高斯滤波器去除小的边缘 cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2); // 计算与画布边缘 cv::Mat edges; cv::Canny(gray, edges, 0, 50); // 使用白色填充 cvImage.setTo(cv::Scalar::all(225)); // 修改边缘颜色 cvImage.setTo(cv::Scalar(0,128,255,255),edges); // 将Mat转换为Xcode的UIImageView显示 self.testImgView1.image = MatToUIImage(cvImage); } 如果你和我一样运行Xcode之后能得到下图的处理后的照片内容的话，图像的灰度显示算是完成了。 也就是说OpenCV的第一个代码块已经完成了。 如果还有兴趣的话，可以接着玩玩—–人脸识别 现在在你的.mm控制器里引入CascadeClassifier类 @interface ViewController () { cv::CascadeClassifier faceDetector; } @end 关于CascadeClassifier类的调研:详见另一篇Blog：OpenCV之CascadeClassifier(一) 人脸识别核心代码如下: NSString *cascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt&quot; ofType:@&quot;xml&quot;]; faceDetector.load([cascadePath UTF8String]); cv::Mat faceImage; UIImageToMat(image, faceImage); // 转为灰度 cv::Mat gray; cvtColor(faceImage, gray, CV_BGR2GRAY); // 检测人脸并储存 std::vector&lt;cv::Rect&gt;faces; faceDetector.detectMultiScale(gray, faces,1.1,2,0|CV_HAAR_SCALE_IMAGE,cv::Size(30,30)); // 在每个人脸上画一个红色四方形 for(unsigned int i= 0;i &lt; faces.size();i++) { const cv::Rect&amp; face = faces[i]; cv::Point tl(face.x,face.y); cv::Point br = tl + cv::Point(face.width,face.height); // 四方形的画法 cv::Scalar magenta = cv::Scalar(255, 0, 255); cv::rectangle(faceImage, tl, br, magenta, 4, 8, 0); } self.testImgView2.image = MatToUIImage(faceImage); 补充:haarcascade_frontalface_alt.xml该文件是专门用来训练cv::CascadeClassifier函数的资源文件 为什么一定要添加xml文件呢？ 其实这个xml文件就是对人脸识别的初始化（初始化数据by Paul Viola and later extended by Rainer Lienhart），现在已经成为一种人脸识别的标准了。 为了能够把xml文件成功倒入，我们需要把NSString object 转化为 std::string（使用UTF8String） 经过以上的准备工作后我们就可以使用方法detectMultiScale进行人脸检测了。 方法detectMultiScale有四个参数。分别为： scaleFactor ：制定循环递减的图片尺寸 minNeighbors ：制定保留数据的矩形大小 CV_HAAR_SCALE_IMAGE ：这是一个标志，它指定算法缩放图像，而不是检测器。它有助于实现最佳的性能 minSize ：该参数指定最小可能的面部尺寸 如果可以得到下图(imageView重新布局了)，第三张图片里的每个人脸上都有正方形的框，表示已经找到了人脸位置。 到此时，静态图片的人脸识别算是初步完成。","raw":"---\ntitle: 人脸识别01\ndate: 2017-02-20  10:01:22\ncategories:\ntoc: false\ntags:\n     - C++\n     - 人脸识别\n     - OpenCV   \n---\n\n>废话内容，写在前面:\n>\n>2016年上半年在上海面试的时候。徐汇区有一家做社交的互联网公司开始打算做人脸识别，由此我了解了深圳脸萌科技的FaceU这款超级激萌的App。很有意思的是徐汇区那家社交公司面试我的时候跟我说的很明确：你做一个类似FaceU的demo给我，我就给你发Offer。有时候我在想一份工作好简单啊，只要你会做人脸识别添加贴纸贴片，一碗饭就来了。\n>\n>回去之后，我对比了iOS框架自带的人脸识别框架识别的精度不够高，侧脸极其难识别，我只好放弃转而奔向科大讯飞人脸识别的框架去做。\n>\n>那一个礼拜的时间里，我看科大讯飞的人脸识别SDK和官方Demo，在做识别的过程中想加贴片装饰品的时候，遇到了二个代理方法的冲突，导致某个识别状态始终无法修改。所以那次的demo最终是没有做出来。\n>\n>时隔快一年，我想人脸识别功能我该动一动了，恰好个人技术博客刚开张，也应该来一点技术干货。同时不一样的是，这次我也不打算用科大讯飞的框架，我想从OpenCV的开源库着手，多多少少还可以学点C++的函数也还不错。\n>\n>由此我想把研究人脸识别的过程记录下来。所以这个系列是一个不懂C++的iOS开发小白的学习过程。\n\n>本系列文章，所有测试内容以及demo的环境如下：\n>\n>1）Xcode Version 8.2.1\n>\n>2）OpenCV for iOS 3.2.0 \n>\n\n\n<!--more-->\n\n准备工作：\n\n1）先去[OpenCV官网](http://opencv.org/)下载最新的OpenCV For iOS的视觉库。\n\n2）Xcode创建一个新的项目，把下载的OpenCV库导入工程，并在工程的Building phase里面添加 opencv2.framework。\n\n\n如果对OpenCV有所了解的会知道，OpenCV的代码是基于C++编写的。因此，想要在Xcode项目中运行C++代码，你需要把文件名后缀名由.m改成.mm即可（当然最好把OpenCV的功能函数写一层OC的API封装，这样可能会比较安全，也会少很多不必要的错误麻烦，也更符合开发需求。）。\n\n注意：OpenCV 声明了命名空间 cv，因此 OpenCV 的类的前面会有个 cv:: 前缀，就像 cv::Mat、 cv::Algorithm 等等。你也可以在 .mm 文件中使用 using namespace cv 来避免在一堆类名前使用 cv:: 前缀。\n\n但是，在某些类名前你必须使用命名空间前缀，比如 cv::Rect 和 cv::Point，因为它们会跟定义在 MacTypes.h 中的 Rect 和 Point 相冲突。尽管这只是个人偏好问题，个人偏向在任何地方都使用 cv:: 以保持一致性。\n\n\n>C++ 命名空间namespace的作用和使用:\n>\n>命名空间是ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。其作用就是规定该文件中使用的标准库函数都是在标准命名空间std中定义的。通常来说，在C++中，命名空间（namespace）的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个全局命名空间（global namespace），全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用::member的形式表示）。\n>\n>在C语言中定义了3个层次的作用域，即文件(编译单元)、函数和复合语句。C++在C的基础上又引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。\n\n在导入  opencv2.framework  之后，把你需要加入OpenCV代码的文件的.m文件后缀由.m改成.mm\n\n引入头文件\n\n    #import < opencv2/opencv.hpp>\n    #import <opencv2/imgproc/types_c.h>\n    #import <opencv2/imgcodecs/ios.h>\n    \n编译运行。\n\nPS:我编译的时候，有二个报错。经过查阅资料做了具体的修改调整之后可以正常运行，分别是OpenCV库的 \n\n blenders.hpp 文件\n\n    enum { NO, FEATHER, MULTI_BAND };\n      \n修改成：\n\n    enum { NO_EXPOSURE_COMPENSATOR, FEATHER, MULTI_BAND };\n      \n和  exposure_compensate.hpp  文件\n\n    enum { NO, GAIN, GAIN_BLOCKS };   \n    \n修改成：\n    \n    enum { NO_EXPOSURE_COMPENSATOR, GAIN, GAIN_BLOCKS };\n    \n    \n先来试试OpenCV的入门内容，把一张彩色图片变成灰色的\n\n在控制器的.mm文件中引入Mat类\n\n    @interface ViewController ()\n\t{\n\t   cv::Mat cvImage;\n\t}\n\t@end\n\t\n>关于Mat类:\n>详见另一篇Blog：[OpenCV之Mat(一)](/2017/02/20/OpenCV之Mat-一/)\n\n图像处理的代码块如下：\n\n    if(!cvImage.empty()){\n        cv::Mat gray;\n        // 将图像转换为灰度显示\n        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);\n        // 应用高斯滤波器去除小的边缘\n        cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2);\n        // 计算与画布边缘\n        cv::Mat edges;\n        cv::Canny(gray, edges, 0, 50);\n        // 使用白色填充\n        cvImage.setTo(cv::Scalar::all(225));\n        // 修改边缘颜色\n        cvImage.setTo(cv::Scalar(0,128,255,255),edges);\n        // 将Mat转换为Xcode的UIImageView显示\n        self.testImgView1.image = MatToUIImage(cvImage);\n    }\n\n如果你和我一样运行Xcode之后能得到下图的处理后的照片内容的话，图像的灰度显示算是完成了。 \n\n![ opencvtest1 ](http://olnzmhc4r.bkt.clouddn.com/opencvtest1.png) \n\n\n也就是说OpenCV的第一个代码块已经完成了。\n\n\n如果还有兴趣的话，可以接着玩玩-----人脸识别 \n \n现在在你的.mm控制器里引入CascadeClassifier类\n\n    @interface ViewController ()\n    {\n        cv::CascadeClassifier faceDetector;\n    }\n    @end\n\n>关于CascadeClassifier类的调研:\n>详见另一篇Blog：[OpenCV之CascadeClassifier(一)](/2017/02/20/OpenCV之CascadeClassifier-一/)\n\n人脸识别核心代码如下:\n    \n    NSString *cascadePath = [[NSBundle mainBundle]\n                             pathForResource:@\"haarcascade_frontalface_alt\"\n                             ofType:@\"xml\"];\n    faceDetector.load([cascadePath UTF8String]);\n    \n    cv::Mat faceImage;\n    UIImageToMat(image, faceImage);\n    \n    // 转为灰度\n    cv::Mat gray;\n    cvtColor(faceImage, gray, CV_BGR2GRAY);\n    \n    // 检测人脸并储存\n    std::vector<cv::Rect>faces;\n    faceDetector.detectMultiScale(gray, faces,1.1,2,0|CV_HAAR_SCALE_IMAGE,cv::Size(30,30));\n    \n    // 在每个人脸上画一个红色四方形\n    for(unsigned int i= 0;i < faces.size();i++)\n    {\n        const cv::Rect& face = faces[i];\n        cv::Point tl(face.x,face.y);\n        cv::Point br = tl + cv::Point(face.width,face.height);\n        \n        // 四方形的画法\n        cv::Scalar magenta = cv::Scalar(255, 0, 255);\n        cv::rectangle(faceImage, tl, br, magenta, 4, 8, 0);\n    }\n    self.testImgView2.image = MatToUIImage(faceImage);\n\n补充:haarcascade_frontalface_alt.xml该文件是专门用来训练cv::CascadeClassifier函数的资源文件\n\n>为什么一定要添加xml文件呢？\n>\n>其实这个xml文件就是对人脸识别的初始化（初始化数据by Paul Viola and later extended by Rainer Lienhart），现在已经成为一种人脸识别的标准了。\n>\n>为了能够把xml文件成功倒入，我们需要把NSString object 转化为 std::string（使用UTF8String）\n>\n>经过以上的准备工作后我们就可以使用方法detectMultiScale进行人脸检测了。\n>\n>方法detectMultiScale有四个参数。分别为：\n>\n>scaleFactor ：制定循环递减的图片尺寸\n>\n>minNeighbors ：制定保留数据的矩形大小\n\n>CV_HAAR_SCALE_IMAGE ：这是一个标志，它指定算法缩放图像，而不是检测器。它有助于实现最佳的性能\n\n>minSize ：该参数指定最小可能的面部尺寸\n\n如果可以得到下图(imageView重新布局了)，第三张图片里的每个人脸上都有正方形的框，表示已经找到了人脸位置。\n\n![ opencvtest2](http://olnzmhc4r.bkt.clouddn.com/opencvtest2.png)   \n\n到此时，静态图片的人脸识别算是初步完成。\n\n\n","updated":"2017-11-27T10:08:29.295Z","permalink":"http://yoursite.com/2017/02/20/人脸识别01/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"}]},{"title":"要尝试逃离上广深了么？","date":"2017-02-19T13:53:20.000Z","path":"2017/02/19/要尝试逃离上广深了么？/","text":"2017年2月19日了，这天比预期的时间晚来了30天，30天前我告诉自己，要弄一个个人站点，不管这个站点的Theme是从哪个大牛手里偷的，都要先用着。 本来在现有的Hexo成熟的框架条件下，个人博客最多20分钟就可以弄好，但是我却花了比我预期多的多的时间。这些事件都耗费在哪了？耗费在不够专注：上班修改优化项目零碎的时间里，Hexo安装错误，一波接着一波的安装卸载，GitHub Pages删了又重新添加，全是无用之功。 2月17日那天一天跑了四个面试，Cisco上海的技术面问了我很多基础的东西，26分钟后从大厦出来，从没有如此草率的面试，毫无准备，必然不会受到太高的待见。可是为啥我要把自己的实力不足归咎于准备不充分呢？没有什么台阶要给自己下的。自己的无能是原罪。下午在浦东张江高科，那个逆向开发公司的技术面和我聊了20多分钟，问我最近研究什么，问我最近开发上的难点有哪些，我一五一十的说着：搭建个人站点，研究夜间模式以及多主题设计思路和优化方案。后来问我：你会给iPhone越狱嘛？我说我没做过的时候他合起了他的Mac。我想这已经终结聊天了。我原本也是抱着试试的态度来的，iOS开发的汇编底层我知道暂时没那个能力去做，不被待见显而易见。但是这还是我第一次面试像别人展示自己的时候和别人想获取的信息完全不在同一个频道上，难免感到话题有点难聊，让我感觉空气里到处弥漫着尴尬。 46分钟之后我离开了那家逆向开发公司，打车去找老甲，我坐在老甲公司楼下的台阶上吹冷风，手机没电我打开Mac给它喂奶。我告诉自己都会好的，就像春天来了，柳絮会飘，秋天过来，柿子会熟。少年，你不能太着急的哟。我安慰自己，你可以的，这个世界本来就给你留好了位置，你还没遇到最好的自己。可是那天的风好大，吹的我鼻子好难受，鼻子好酸，眼角都湿得一直没干。自我安慰的那些屁话，肯定没有老甲带我去吃的那顿热气腾腾的麻辣烫管用。张江高科消费好贵啊，0.8公斤的料，48块钱，温饱了那天傍晚我饥饿的灵魂。 晚上回来之后想想，大概是太过于急功近利。技术需要沉淀的，一点点去学，代码要慢慢的打磨，一行行的敲。这个膨胀的社会却不给年轻人那么多时间去沉淀，膨胀的自己也不给自己那么多机会去尝试。 2016年的每一天我都掰开着用，这一年我都没时间去做噩梦，忙得让我很少在半夜里会醒来，往往都是半夜才睡。那个时候我告诉自己，你要努力，你现在多累些，当下就少求别人一点。下半年项目加班加点，干过40多个小时没合眼，我也不曾抱怨，因为毕竟自己菜，只能用时间来弥补，我把别人喝咖啡的时候都用来写项目了。我庆幸我足够的年轻，年轻到身体严重负荷的时候，仅仅只是胸口有点痛而已。一觉醒来，代码还可以撸的飞起。 TinyTian说代码是我大老婆，她是小三，满是哀怨的时候我只能咧开嘴笑，的确我欠她太多的时间。有时候我在想，幸福的日子就是有一个人成了你这一生唯一的软肋，遇事再也不莽撞，即使丢掉激情你也不会觉得后悔。好寡淡的时光啊，可就是这么心安理得的欢喜。 有时候很多事情来的莫名其妙，中午在地铁上打瞌睡打盹点开Boss聊了一个，后来才知道那是合肥的一家美容公司。紧接着下午就视讯通话面试过了，傍晚给我发了Offer，在合肥，试用期税前9K，转正11K。可是我不知道为啥高兴不起来呢，是我过于贪恋一线城市夜晚的霓虹灯么？总是在心里告诉自己一线城市机会多，技术提升快？可是迟早终究要回到那个城市的，为何不早做打算，非要漫无目的的幻想么？ 现在这个机会就摆在我的面前了，我却踌躇满志，迈不开步子。可这又算什么呢？反正我的时间又不值钱，可以大把的浪费大把的挥霍。 年轻就是这样的吧，都不确定，都在准备呢。试试又不是一个坏事。 何况又不是最惨的时候。 毕竟还有那么多希望。","raw":"---\ntitle: 要尝试逃离上广深了么？\ndate: 2017-2-19 21:53:20\ncategories:\ntoc: false\ntags:\n     - Essays\n---\n\n2017年2月19日了，这天比预期的时间晚来了30天，30天前我告诉自己，要弄一个个人站点，不管这个站点的Theme是从哪个大牛手里偷的，都要先用着。\n\n\n本来在现有的Hexo成熟的框架条件下，个人博客最多20分钟就可以弄好，但是我却花了比我预期多的多的时间。这些事件都耗费在哪了？耗费在不够专注：上班修改优化项目零碎的时间里，Hexo安装错误，一波接着一波的安装卸载，GitHub Pages删了又重新添加，全是无用之功。\n\n\n2月17日那天一天跑了四个面试，Cisco上海的技术面问了我很多基础的东西，26分钟后从大厦出来，从没有如此草率的面试，毫无准备，必然不会受到太高的待见。可是为啥我要把自己的实力不足归咎于准备不充分呢？没有什么台阶要给自己下的。自己的无能是原罪。下午在浦东张江高科，那个逆向开发公司的技术面和我聊了20多分钟，问我最近研究什么，问我最近开发上的难点有哪些，我一五一十的说着：搭建个人站点，研究夜间模式以及多主题设计思路和优化方案。后来问我：你会给iPhone越狱嘛？我说我没做过的时候他合起了他的Mac。我想这已经终结聊天了。我原本也是抱着试试的态度来的，iOS开发的汇编底层我知道暂时没那个能力去做，不被待见显而易见。但是这还是我第一次面试像别人展示自己的时候和别人想获取的信息完全不在同一个频道上，难免感到话题有点难聊，让我感觉空气里到处弥漫着尴尬。\n\n\n<!--more-->\n46分钟之后我离开了那家逆向开发公司，打车去找老甲，我坐在老甲公司楼下的台阶上吹冷风，手机没电我打开Mac给它喂奶。我告诉自己都会好的，就像春天来了，柳絮会飘，秋天过来，柿子会熟。少年，你不能太着急的哟。我安慰自己，你可以的，这个世界本来就给你留好了位置，你还没遇到最好的自己。可是那天的风好大，吹的我鼻子好难受，鼻子好酸，眼角都湿得一直没干。自我安慰的那些屁话，肯定没有老甲带我去吃的那顿热气腾腾的麻辣烫管用。张江高科消费好贵啊，0.8公斤的料，48块钱，温饱了那天傍晚我饥饿的灵魂。\n\n\n晚上回来之后想想，大概是太过于急功近利。技术需要沉淀的，一点点去学，代码要慢慢的打磨，一行行的敲。这个膨胀的社会却不给年轻人那么多时间去沉淀，膨胀的自己也不给自己那么多机会去尝试。\n\n\n2016年的每一天我都掰开着用，这一年我都没时间去做噩梦，忙得让我很少在半夜里会醒来，往往都是半夜才睡。那个时候我告诉自己，你要努力，你现在多累些，当下就少求别人一点。下半年项目加班加点，干过40多个小时没合眼，我也不曾抱怨，因为毕竟自己菜，只能用时间来弥补，我把别人喝咖啡的时候都用来写项目了。我庆幸我足够的年轻，年轻到身体严重负荷的时候，仅仅只是胸口有点痛而已。一觉醒来，代码还可以撸的飞起。\n\n\nTinyTian说代码是我大老婆，她是小三，满是哀怨的时候我只能咧开嘴笑，的确我欠她太多的时间。有时候我在想，幸福的日子就是有一个人成了你这一生唯一的软肋，遇事再也不莽撞，即使丢掉激情你也不会觉得后悔。好寡淡的时光啊，可就是这么心安理得的欢喜。\n\n\n有时候很多事情来的莫名其妙，中午在地铁上打瞌睡打盹点开Boss聊了一个，后来才知道那是合肥的一家美容公司。紧接着下午就视讯通话面试过了，傍晚给我发了Offer，在合肥，试用期税前9K，转正11K。可是我不知道为啥高兴不起来呢，是我过于贪恋一线城市夜晚的霓虹灯么？总是在心里告诉自己一线城市机会多，技术提升快？可是迟早终究要回到那个城市的，为何不早做打算，非要漫无目的的幻想么？\n\n\n现在这个机会就摆在我的面前了，我却踌躇满志，迈不开步子。可这又算什么呢？反正我的时间又不值钱，可以大把的浪费大把的挥霍。\n\n\n年轻就是这样的吧，都不确定，都在准备呢。试试又不是一个坏事。\n\n何况又不是最惨的时候。\n\n毕竟还有那么多希望。","updated":"2017-11-24T06:49:49.571Z","permalink":"http://yoursite.com/2017/02/19/要尝试逃离上广深了么？/","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://yoursite.com/tags/Essays/"}]}]